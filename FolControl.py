import pymel.core as pm
sel = pm.ls(sl = True)
ctrl = sel[1].replace('Ctrl', 'Master_ctrl')
closestPoint = pm.createNode('closestPointOnSurface', n = 'closestPointonSurface_node')
arcLength = pm.createNode('arcLengthDimension', n = 'arcLengthDimension_node')

pos = pm.xform(sel[1], q = True, t = True, ws = True)
pm.connectAttr(sel[0] + '.local', closestPoint + '.inputSurface',f=1)
pm.setAttr(closestPoint + '.inPosition', pos[0],pos[1],pos[2])

pm.connectAttr(sel[0] + '.worldSpace', arcLength + '.nurbsGeometry')

 

 

pm.group(em = True, n = 'temp')
pm.connectAttr(closestPoint +'.parameterU','temp.tx')
pm .connectAttr(closestPoint +'.parameterV','temp.ty')
paraU = pm.getAttr('temp.tx')
paraV = pm.getAttr('temp.ty')
pm.setAttr(arcLength + '.uParamValue',paraU)
pm.setAttr(arcLength + '.vParamValue',paraV)
pm.connectAttr(arcLength + '.arcLength', 'temp.sx')
pm.connectAttr(arcLength + '.arcLengthInV', 'temp.sy')
arclenU = pm.getAttr('temp.sx')
arclenV = pm.getAttr('temp.sy')

pm.delete('temp', pm.listRelatives(arcLength, p = True), arcLength, closestPoint)

flc = pm.createNode('follicle', n = ctrl + '_follicleShape')
pm.connectAttr(sel[0] + '.local', flc + '.inputSurface')
pm.connectAttr(sel[0] + '.worldMatrix', flc +'.inputWorldMatrix')
pm.setAttr(flc + '.parameterU',paraU)
pm.setAttr(flc + '.parameterV',paraV)

pm.connectAttr(flc + '.outTranslate', flc.replace('Shape','.t'))
pm.connectAttr(flc + '.outRotate', flc.replace('Shape','.r'))
pm.circle(nrx = 0, nry = 0, nrz = 1, d= 3, ch = False, n = ctrl)
grp = pm.group(em = True, n=ctrl+'_Group')

off = pm.group(em = True, n=ctrl+'_OffsetGroup')
pm.parent(ctrl, grp)
pm.parent(grp, off)

pm.delete(pm.parentConstraint(flc.replace('Shape',''),off,mo=False))
pm.parent(off, flc.replace('Shape',''))

pm.addAttr(ctrl, ln = 'ArcLengthU', at = 'float') 
pm.setAttr(ctrl + '.ArcLengthU', arclenU*2)
pm.addAttr(ctrl, ln = 'ArcLengthV', at = 'float')
pm.setAttr(ctrl + '.ArcLengthV', arclenV*2)
pm.addAttr(ctrl, ln = 'DefaultParameterU', at = 'float')
pm.setAttr(ctrl + '.DefaultParameterU', paraU)
pm.addAttr(ctrl, ln = 'DefaultParameterV', at = 'float')
pm.setAttr(ctrl + '.DefaultParameterV', paraV)
dmat = pm.createNode('decomposeMatrix', n = grp + '_DMAT')
pm.connectAttr(ctrl + '.inverseMatrix', dmat + '.inputMatrix')
pm.connectAttr(dmat + '.outputTranslate', grp + '.translate')
pm.connectAttr(dmat + '.outputRotate', grp + '.rotate') 
pm.connectAttr(dmat + '.outputScale', grp + '.scale')
md = pm.createNode('multiplyDivide', n = ctrl + '_Conversion_MD') 
pm.connectAttr(ctrl + '.ArcLengthU', md + '.input1X') 
pm.connectAttr(ctrl + '.ArcLengthV', md + '.input1Y') 
pm.setAttr(md + '.input2X', -1)
pm.setAttr(md + '.input2Y', -1)
sr = pm.createNode('setRange', n = ctrl + '_Conversion_SR') 
pm.connectAttr(md + '.outputX', sr + '.oldMinX') 
pm.connectAttr(md + '.outputY', sr + '.oldMinY') 
pm.connectAttr(ctrl + '.ArcLengthU', sr + '.oldMaxX') 
pm.connectAttr(ctrl + '.ArcLengthV', sr + '.oldMaxY') 
pm.setAttr(sr + '.minX', -1)
pm.setAttr(sr + '.minY', -1)
pm.setAttr(sr + '.maxX', 1)
pm.setAttr(sr + '.maxY', 1)
pm.connectAttr(ctrl + '.tx', sr + '.valueX') 
pm.connectAttr(ctrl + '.ty', sr + '.valueY')
pma = pm.createNode('plusMinusAverage', n = ctrl + '_Parameter_PMA') 
pm.connectAttr(ctrl + '.DefaultParameterU', pma + '.input2D[0].input2Dx')
pm.connectAttr(ctrl + '.DefaultParameterV', pma + '.input2D[0].input2Dy')
pm.connectAttr(sr + '.outValueX', pma + '.input2D[1].input2Dx')
pm.connectAttr(sr + '.outValueY', pma + '.input2D[1].input2Dy')
pm.connectAttr(pma + '.output2Dx', flc + '.parameterU')
pm.connectAttr(pma + '.output2Dy', flc + '.parameterV')
      