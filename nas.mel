//-------------------------------------------------------------------nas_rigging.mel---------------------------------------------------------------------
//this
//this script is split up into sections denoted by three lines of the following text
//=====================================================================================================================================
//=============================================================-sectionName=============================================================
//=====================================================================================================================================

//and each script is denoted by a single line with the following text
//-----------------------------------------------------------------scriptName---------------------------------------------------------------------

//comments and arguments that are passed and required selections will be described under each script name line
/*
$array = sort($nasRiggingProcs);
int $count = 0;
string $cmd = ("global string $nasRiggingProcs[] = {\"" + $array[0] + "\"");
for ($i=1; $i<size($array); $i++) {
    if ($count < 130) {
        $cmd += (", \"" + $array[$i] + "\"");
    } else {
        $cmd += (", \n\"" + $array[$i] + "\"");
        $count = 0;
    }
    $count += size($array[$i]);
}
$cmd += "};";
print $cmd
*/

string $nasRiggingProcs[] = {"nas_KFUpdateChars", "nas_KFUpdateCmd", "nas_addAttr", "nas_addMembership", "nas_assembleSystems", "nas_axisToVector", "nas_blackBox", "nas_boundingBox", "nas_breakConnection", "nas_buttonFormLayout", 
"nas_buttonLayout", "nas_centerCluster", "nas_channelBox", "nas_charNameFromDir", "nas_charNameFromFile", "nas_checkWeighting", "nas_clusters", "nas_colorControls", 
"nas_colorToIndex", "nas_connectAttr", "nas_connectEmoticons", "nas_constrainBetween", "nas_controls", "nas_copyAttrs", "nas_copyDeformerWeights", "nas_copySkinWeights", 
"nas_correctiveShape", "nas_createCurve", "nas_createLayers", "nas_createLayout", "nas_createNullCopy", "nas_createWireCurve", "nas_ctrlChecker", "nas_deformationToCluster", 
"nas_deformationToClusterInteractive", "nas_deformationToClusterUI", "nas_deleteUnusedShadingGroups", "nas_deleteUnusedShadingNodes", "nas_distance", 
"nas_distanceBetween", "nas_drawBoundingBoxCurve", "nas_duplicateLayoutJoints", "nas_fileLocation", "nas_fileResCheck", "nas_finalCharChecks", "nas_finalCharacterUI", 
"nas_findClosest", "nas_flipJoints", "nas_framePadding", "nas_geosToShaders", "nas_geosToShadingGroups", "nas_geosToShadingNetwork", "nas_getCBSelection", "nas_getDeformerInfo", 
"nas_getDeformerSet", "nas_getDeformerVerts", "nas_getEndVerts", "nas_getMirrorVerts", "nas_getNameFromBind", "nas_getSels", "nas_getSkinCluster", "nas_getTopJoints", 
"nas_getVisibleModelPanels", "nas_group", "nas_groupGroups", "nas_hideObjsWithoutMaterial", "nas_holdInfluences", "nas_importShaders", "nas_influencesFromVerts", 
"nas_isMember", "nas_joints", "nas_killWindows", "nas_layerEditor", "nas_layerEditorUI", "nas_limitAttrs", "nas_listCharShaders", "nas_listFileTextures", "nas_listNetwork", 
"nas_listWindow", "nas_locator", "nas_lockAttrs", "nas_lockHideAttrs", "nas_locsOnCurve", "nas_makeNonRenderable", "nas_markingMenu", "nas_massConstrain", "nas_massParentShape", 
"nas_matchPivots", "nas_matchTransforms", "nas_matchUVAssignment", "nas_matchWorld", "nas_mimic", "nas_mimicDeformerWeights", "nas_mimicDeformerWeightsSource", 
"nas_mirrorDeformerWeights", "nas_mirrorJoints", "nas_mirrorSkinWeights", "nas_mirrorXform", "nas_moveAttr", "nas_moveToOrigin", "nas_multiplyDeformerWeights", 
"nas_nurbsDefaultDisplay", "nas_openFile", "nas_orderHierarchy", "nas_orientJoints", "nas_orientToSurface", "nas_outlineLayout", "nas_outliner", "nas_parentShape", 
"nas_pasteDeformerWeights", "nas_pasteSkinWeights", "nas_percent", "nas_prefix", "nas_progress", "nas_pruneDeformerWeights", "nas_pruneDeformerWeightsFromSels", 
"nas_radioCheckBoxGrp", "nas_reconnectSmooths", "nas_reloadFile", "nas_reloadTextures", "nas_rename", "nas_renameShadingGroupsAndInfos", "nas_renameSmoothProxies", 
"nas_reorderHistory", "nas_rigBind", "nas_rigFK", "nas_rigFKFromBind", "nas_rigFoot", "nas_rigHand", "nas_rigHead", "nas_rigIK", "nas_rigJiggle", "nas_rigLimb", "nas_rigToes", 
"nas_riggingUI", "nas_roundTime", "nas_saveAsBrowser", "nas_saveNewVersion", "nas_saveSceneAs", "nas_sceneInfo", "nas_segments", "nas_selectByName", "nas_selectByType", 
"nas_selectionMask", "nas_setAttr", "nas_setAttrs", "nas_setHiresToRenderable", "nas_shadeControls", "nas_shadingGroupToShaders", "nas_showAttrs", "nas_showObjsWithoutMaterial", 
"nas_skinCluster", "nas_sortMultiple", "nas_stringArrayCatenate", "nas_stringArrayIntersection", "nas_stringArrayRemoveDuplicates", "nas_suffix", "nas_timeFormat", 
"nas_vectorToAxis", "nas_vertsInBoundingBox", "nas_weight", "nas_weightAverage", "nas_weightAverageBias", "nas_weightAverageGet", "nas_weightAverageLine", "nas_weightAverageMulti", 
"nas_weightAverageMultiSel", "nas_weightExact", "nas_weightPinch", "nas_window", "nas_wireDeformerSetup"};

//-----------------------------------------------------------------nas_riggingUI---------------------------------------------------------------------
global proc nas_riggingUI() {
        if (size(`lsUI -type window`) <= 0) return;
    
    global int $nasSelectionMaskToggle;
    string $window, $labels[], $cmds[], $notes[], $nas_groupCheckbox, $nas_groupCheckboxUI, $frameHeight, $frames[], $cmd, $frame, $form, $scroll, $helpline, $helpFrame;
    int $windowWidth, $windowHeight, $buttonWidth;
    
    clear $frames;
    
    $windowWidth = 513;
    $windowHeight = 357;
    $buttonWidth = 80;
    
    $window = `nas_window nas_riggingUI 1 0 0`;
    //window -e -wh $windowWidth $windowHeight $window;
    $windowWidth = `window -q -w $window`;
    $windowHeight = `window -q -h $window`;
    
    $form = `formLayout`;
    $helpFrame = `frameLayout -labelVisible false -borderStyle "etchedIn" -collapsable false -parent $form`;
    $helpline = `helpLine -parent $helpFrame`;
    $scroll = `scrollLayout -cr 1 -parent $form`;
    columnLayout -adjustableColumn true -parent $scroll;
    
    //File
    $cmd = ("frameLayout -e -h " + "(`nas_riggingUINumRows " + 3 + " " + $buttonWidth + " " + $window + "`*22+20) "); 
    $frame = `frameLayout -h ((nas_riggingUINumRows(3, $buttonWidth, $window))*22+20) -label "File" -collapsable 1 -borderVisible 1 -borderStyle "etchedOut"`;
    frameLayout -e -expandCommand ($cmd + $frame + ";window -e -w (`window -q -w " + $window + "`+1) " + $window + ";window -e -w (`window -q -w " + $window + "`-1) " + $window + ";") $frame;
        gridLayout -cellWidthHeight $buttonWidth 22 -columnsResizable 1;
            
            //save and open marking menu
            button -w $buttonWidth -al center -label "Save/Open" -ann "" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Version", "nas_saveNewVersion", "E", "0", "Saves a new version of the current scene file - nas_saveNewVersion", 
                "Save As", "nas_saveSceneAs", "S", "0", "Opens save scene as dialog in the folder above where the current file resides - nas_saveSceneAs", 
                "Open", "nas_openFile", "N", "0", "Opens open dialog box in the folder above where the current file resides - nas_openFile", 
                "Reload", "nas_reloadFile", "W", "0", "Re-opens current file without saving - nas_reloadFile"};
            //asset marking menu
            button -w $buttonWidth -al center -label "Asset" -ann "" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "File Name", "dkReturnPath 2", "SW", "0", "", 
                "Out WIP Name", "dkReturnPath 0", "SE", "0", ""};
            //reminder marking menu
            button -w $buttonWidth -al center -label "Reminder" -ann "" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "On", "nas_saveReminderFuncs start", "W", "0", "", 
                "Off", "nas_saveReminderFuncs end", "E", "0", "", 
                "Frequency", "nas_saveReminderFuncs increment", "N", "0", ""};
            setParent ..;
        setParent ..;
    $frames[size($frames)] = $frame;
    
    //General
    $cmd = ("frameLayout -e -h " + "(`nas_riggingUINumRows " + 5 + " " + $buttonWidth + " " + $window + "`*22+20) ");
    $frame = `frameLayout -h ((nas_riggingUINumRows(5, $buttonWidth, $window))*22+20) -label "General" -collapsable 1 -borderVisible 1 -borderStyle "etchedOut"`;
    frameLayout -e -expandCommand ($cmd + $frame + ";window -e -w (`window -q -w " + $window + "`+1) " + $window + ";window -e -w (`window -q -w " + $window + "`-1) " + $window + ";") $frame;
        gridLayout -cellWidthHeight $buttonWidth 22 -columnsResizable 1;
            $labels = {"Channels", "Slide", "Outliner", "Maskolimer"};
            $cmds = {"nas_channelBox", "nas_slideAttrsUI", "nas_outliner", "nas_quickUI"};
            $notes = { 
                "Creates a channel box in its own window with sensitivity settings", 
                "A tool to help change attrs on multiple attrs with sensitivity.",
                "A window for storing selections", 
                "Launches a mask and isolate window - nas_quickUI"};
            for ($i = 0; $i < size($labels); $i++) button -bgc .35 .95 .3 -w $buttonWidth -al center -label $labels[$i] -c $cmds[$i] -ann $notes[$i];
            
            //select marking menu
            button -w $buttonWidth -al center -label "Select" -ann "" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Bind Joints", "nas_selectByType bindjoint", "NW", "0", "", 
                "Controls", "nas_selectByType control", "W", "0", "",
                "Clusters", "nas_selectByType cluster", "N", "0", "",
                "Select by Name", "nas_selectByNameUI", "E", "0", "", 
                "Geometry", "", "S", "1", "",
                    "HiRes", "nas_selectByType hires", "W", "2", "",
                    "SmoothProxy", "nas_selectByType smoothproxy", "N", "2", "",
                    "Proxy", "nas_selectByType proxy", "E", "2", "",
                    "All", "nas_selectByType geo", "S", "0", ""};
            //window marking menu
            button -w $buttonWidth -al center -label "Window" -ann "tools to launch and kill windows" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Hypershade", "HypershadeWindow", "N", "0", "",
                "Script Editor", "ScriptEditor", "NE", "0", "",
                "Outliner", "OutlinerWindow;", "E", "0", "", 
                "Hyper: Connections", "HypergraphDGWindow;", "S", "0", "",
                "Hyper: Hierarchy", "HypergraphHierarchyWindow;", "SE", "0", "",
                "Connection Editor", "ConnectionEditor", "SW", "0", "",
                "Kill Windows", "nas_killWindows", "W", "0", "",
                "Graph Editor", "GraphEditor", "NW", "0", ""};
            
            setParent ..;
        setParent ..;
    $frames[size($frames)] = $frame;
    
    //Rigging
    $cmd = ("frameLayout -e -h " + "(`nas_riggingUINumRows " + 10 + " " + $buttonWidth + " " + $window + "`*22+20) ");
    $frame = `frameLayout -h ((nas_riggingUINumRows(10, $buttonWidth, $window))*22+20) -label "Rigging" -collapsable 1 -borderVisible 1 -borderStyle "etchedOut"`;
    frameLayout -e -expandCommand ($cmd + $frame + ";print \"" + ($cmd + $frame + ";window -e -w (`window -q -w " + $window + "`+1) " + $window + ";window -e -w (`window -q -w " + $window + "`-1) " + $window + ";") + "\";") $frame;
        gridLayout -cellWidthHeight $buttonWidth 22 -columnsResizable 1;
            
            button -w $buttonWidth -al center -label "Group" -c "nas_group 0 Group" -ann "Creates an identical group to selected objects";
            nas_markingMenu 3 "" {
                "Groups", "nas_groupGroups", "E", "0", ""};
            button -bgc .35 .95 .3 -w $buttonWidth -al center -label "Rename" -c "nas_renameUI" -ann "Renames, prefixes, and suffixes";
            
            //match marking menu
            button -w $buttonWidth -al center -label "Match" -ann "Match selections to the first selection" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Rotates", "nas_matchTransforms 0 0 0 1 1 1 0 0 0", "N", "0", "", 
                "Translates", "nas_matchTransforms 1 1 1 0 0 0 0 0 0", "W", "0", "", 
                "Scales", "nas_matchTransforms 0 0 0 0 0 0 1 1 1", "E", "0", "", 
                "Pivots", "nas_matchPivots", "S", "0", ""};
            nas_markingMenu 2 "" {
                "Origin", "dkMoveToOrigin 0", "NE", "0", "Moves selections to the origin according to their bounding box", 
                "Origin & Nuke", "dkMoveToOrigin 1", "SE", "0", "Moves selections to the origin according to their bounding box, freezes transforms, and deletes history", 
                "Slope X", "dkSlope x", "NW", "0", "",
                "Slope Y", "dkSlope y", "W", "0", "", 
                "Slope Z", "dkSlope z", "SW", "0", ""};
            nas_markingMenu 3 "" {
                "Ave All X", "dkAverageLocationAll x", "NW", "0", "",
                "Ave All Y", "dkAverageLocationAll y", "W", "0", "", 
                "Ave All Z", "dkAverageLocationAll z", "SW", "0", "", 
                "Ave Last X", "dkAverageLocationLast x", "NE", "0", "",
                "Ave Last Y", "dkAverageLocationLast y", "E", "0", "",
                "Ave Last Z", "dkAverageLocationLast z", "SE", "0", ""};
            
            //locator marking menu
            button -w $buttonWidth -al center -label "Locator" -ann "Create locators in various ways." -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Curve From Locators", "nas_createCurve", "N", "0", "",
                "At Each Point", "nas_locator -1", "SW", "0", "", 
                "At Center of Points", "nas_locator 0", "W", "0", "", 
                "At Rotate Pivot", "nas_locator 1", "E", "0", "", 
                "Create", "spaceLocator -p 0 0 0", "S", "0", "", 
                "Cluster At Each", "nas_clusters", "SE", "0", ""};
                
            $labels = {"Segments"};
            $cmds = {"nas_segmentsUI"};
            $notes = {"Creates locators between two objects."};
            for ($i = 0; $i < size($labels); $i++) button -bgc .35 .95 .3 -w $buttonWidth -al center -label $labels[$i] -c $cmds[$i] -ann $notes[$i];
            
            //controls marking menu
            button -w $buttonWidth -al center -label "Controls" -ann "Creates or colors controls" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Color List", "nas_colorControlsUI", "E", "0", "",
                "Display", "nas_nurbsDefaultDisplay", "W", "0", "", 
                "Create", "", "N", "1", "",
                    "Curves", "", "N", "1", "",
                        "Circle", "nas_controls curveCircle", "N", "2", "",
                        "Sphere", "nas_controls curveSphere", "W", "0", "", 
                    "Surfaces", "", "E", "1", "",
                        "Torus", "nas_controls surfaceCircle", "E", "2", "", 
                        "Sphere", "nas_controls surfaceSphere", "N", "2", "",
                        "Double Pin", "nas_controls surfaceDoublePin", "S", "2", "",
                        "Single Pin", "nas_controls surfaceSinglePin", "SE", "2", "",
                        "Foot", "nas_controls surfaceFoot", "NW", "2", "",
                        "Deformer Sphere", "nas_controls surfaceDeformerSphere", "NE", "0", ""};
            
            //parent marking menu
            button -w $buttonWidth -al center -label "Shape" -ann "Parents shapes in various ways" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Shape", "nas_parentShape 0", "E", "0", "", 
                "Replace", "nas_parentShape 1", "W", "0", "", 
                "Shape Each", "nas_massParentShape 0", "N", "0", "", 
                "Replace Each", "nas_massParentShape 1", "S", "0", ""};
            
            //constrain marking menu
            button -w $buttonWidth -al center -label "Constrain" -ann "Constrain multiple selections" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Parent", "parentConstraint", "SE", "0", "", 
                "Parent MO", "parentConstraint -mo", "E", "0", "", 
                "Point", "pointConstraint", "NE", "0", "", 
                "Point MO", "pointConstraint -mo", "N", "0", "", 
                "Scale", "scaleConstraint", "NW", "0", "", 
                "Scale MO", "scaleConstraint -mo", "W", "0", "", 
                "Orient", "orientConstraint", "SW", "0", "", 
                "Orient MO", "orientConstraint -mo", "S", "0", ""};
            nas_markingMenu 2 "" {
                "Parent Each", "nas_massConstrain 1 parent 0", "SE", "0", "", 
                "Parent Each MO", "nas_massConstrain 1 parent 1", "E", "0", "", 
                "Point Each", "nas_massConstrain 1 point 0", "NE", "0", "", 
                "Point Each MO", "nas_massConstrain 1 point 1", "N", "0", "", 
                "Scale Each", "nas_massConstrain 1 scale 0", "NW", "0", "", 
                "Scale Each MO", "nas_massConstrain 1 scale 1", "W", "0", "", 
                "Orient Each", "nas_massConstrain 1 orient 0", "SW", "0", "", 
                "Orient Each MO", "nas_massConstrain 1 orient 1", "S", "0", ""};
            nas_markingMenu 3 "" {
                "Parent All", "nas_massConstrain 0 parent 0", "SE", "0", "", 
                "Parent All MO", "nas_massConstrain 0 parent 1", "E", "0", "", 
                "Point All", "nas_massConstrain 0 point 0", "NE", "0", "", 
                "Point All MO", "nas_massConstrain 0 point 1", "N", "0", "", 
                "Scale All", "nas_massConstrain 0 scale 0", "NW", "0", "", 
                "Scale All MO", "nas_massConstrain 0 scale 1", "W", "0", "", 
                "Orient All", "nas_massConstrain 0 orient 0", "SW", "0", "", 
                "Orient All MO", "nas_massConstrain 0 orient 1", "S", "0", ""};
            nas_markingMenu 1 "shift" {
                "Parent Between", "nas_constrainBetween parent 0", "SE", "0", "", 
                "Parent MO Between", "nas_constrainBetween parent 1", "E", "0", "", 
                "Point Between", "nas_constrainBetween point 0", "NE", "0", "", 
                "Point MO Between", "nas_constrainBetween point 1", "N", "0", "", 
                "Scale Between", "nas_constrainBetween scale 0", "NW", "0", "", 
                "Scale MO Between", "nas_constrainBetween scale 1", "W", "0", "", 
                "Orient Between", "nas_constrainBetween orient 0", "SW", "0", "", 
                "Orient MO Between", "nas_constrainBetween orient 1", "S", "0", ""};
        
            //nudge marking menu
            button -w $buttonWidth -al center -label "Nudge" -ann "Nudge selections." -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Nudge Pivot", "", "W", "1", "",
                    "Get Nudge Pivot", "dkGetNudgePivot", "NW", "2", "", 
                    "Clear Nudge Pivot", "dkClearNudgePivot", "SW", "0", "",
                "Translate", "", "N", "1", "", 
                    "+X", "dkNudge \"translate\" \"x\" .1", "NE", "2", "",
                    "+Y", "dkNudge \"translate\" \"y\" .1", "E", "2", "",
                    "+Z", "dkNudge \"translate\" \"z\" .1", "SE", "2", "",
                    "-X", "dkNudge \"translate\" \"x\" -.1", "NW", "2", "",
                    "-Y", "dkNudge \"translate\" \"y\" -.1", "W", "2", "",
                    "-Z", "dkNudge \"translate\" \"z\" -.1", "SW", "0", "",
                "Rotate", "", "S", "1", "", 
                    "+X", "dkNudge \"rotate\" \"x\" 5", "NE", "2", "",
                    "+Y", "dkNudge \"rotate\" \"y\" 5", "E", "2", "",
                    "+Z", "dkNudge \"rotate\" \"z\" 5", "SE", "2", "",
                    "-X", "dkNudge \"rotate\" \"x\" -5", "NW", "2", "",
                    "-Y", "dkNudge \"rotate\" \"y\" -5", "W", "2", "",
                    "-Z", "dkNudge \"rotate\" \"z\" -5", "SW", "0", "",
                "Scale", "", "E", "1", "", 
                    "+X", "dkNudge \"scale\" \"x\" .1", "NE", "2", "",
                    "+Y", "dkNudge \"scale\" \"y\" .1", "E", "2", "",
                    "+Z", "dkNudge \"scale\" \"z\" .1", "SE", "2", "",
                    "+ALL", "dkNudge \"scale\" \"x\" .1;dkNudge \"scale\" \"y\" .1;dkNudge \"scale\" \"z\" .1;", "N", "2", "", 
                    "-X", "dkNudge \"scale\" \"x\" -.1", "NW", "2", "",
                    "-Y", "dkNudge \"scale\" \"y\" -.1", "W", "2", "",
                    "-Z", "dkNudge \"scale\" \"z\" -.1", "SW", "2", "",
                    "-ALL", "dkNudge \"scale\" \"x\" -.1;dkNudge \"scale\" \"y\" -.1;dkNudge \"scale\" \"z\" -.1;", "S", "0", ""};
            
            setParent ..;
        setParent ..;
    $frames[size($frames)] = $frame;
    
    //Skinning
    $cmd = ("frameLayout -e -h " + "(`nas_riggingUINumRows " + 3 + " " + $buttonWidth + " " + $window + "`*22+20) ");
    $frame = `frameLayout -h ((nas_riggingUINumRows(3, $buttonWidth, $window))*22+20) -label "Skinning" -collapsable 1 -borderVisible 1 -borderStyle "etchedOut"`;
    frameLayout -e -expandCommand ($cmd + $frame + ";window -e -w (`window -q -w " + $window + "`+1) " + $window + ";window -e -w (`window -q -w " + $window + "`-1) " + $window + ";") $frame;
        gridLayout -cellWidthHeight $buttonWidth 22 -columnsResizable 1;
            button -w $buttonWidth -al center -label "Bind" -c "nas_skinCluster" -ann "Select influences first and geo to bind last. Can only bind one object at a time";
            $labels = {"Joints", "Weight"};
            $cmds = {"nas_jointsUI", "nas_weightUI"};
            $notes = {"Creates and orients joints.", "Tool for weighting between two influences easily."};
            for ($i = 0; $i < size($labels); $i++) button -bgc .35 .95 .3 -w $buttonWidth -al center -label $labels[$i] -c $cmds[$i] -ann $notes[$i];
            //extrap marking menu
            button -w $buttonWidth -al center -label "Extrap" -ann "Tools to extrapolate weighting from deformers to joints" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" { 
                "Wire", "dkWiresToJoints 0", "S", "0", ""};
        
            setParent ..;
        setParent ..;
    $frames[size($frames)] = $frame;
    
    //Deformers
    $cmd = ("frameLayout -e -h " + "(`nas_riggingUINumRows " + 6 + " " + $buttonWidth + " " + $window + "`*22+20) ");
    $frame = `frameLayout -h ((nas_riggingUINumRows(6, $buttonWidth, $window))*22+20) -label "Deformers" -collapsable 1 -borderVisible 1 -borderStyle "etchedOut"`;
    frameLayout -e -expandCommand ($cmd + $frame + ";window -e -w (`window -q -w " + $window + "`+1) " + $window + ";window -e -w (`window -q -w " + $window + "`-1) " + $window + ";") $frame;
        gridLayout -cellWidthHeight $buttonWidth 22 -columnsResizable 1;
            //cluster marking menu
            button -w $buttonWidth -al center -label "Cluster" -ann "Tools to extrapolate weighting from deformers to joints" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" { 
                "DK Cluster", "nas_deformationToClusterInteractive 0", "E", "0", "Creates a cluster that mimics deformation. Select lattice points or clusters/controls followed by points that move before running",
                                //"DK Cluster", "deformDotCluster", "E", "0", "Creates a cluster that mimics deformation. Select lattice points or clusters/controls followed by points that move before running",
                "DK Cluster Each", "nas_deformationToClusterInteractive 1", "SE", "0", "Creates a cluster that mimics deformation. Select lattice points or clusters/controls followed by points that move before running"};
            //wire marking menu
            button -w $buttonWidth -al center -label "Wire" -ann "Tools to extrapolate weighting from deformers to joints" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" { 
                "Clusters from Wire", "nas_rigClustersFromWire", "E", "0", ""};
            //edit marking menu
            button -w $buttonWidth -al center -label "Edit" -ann "Tools to extrapolate weighting from deformers to joints" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Reorder History", "nas_reorderHistory", "W", "0", "Reorders history to the most commonly used order.",
                "Wire Curve", "nas_createWireCurve", "S", "0", "Creates the default wire curve. Select two transforms before running."};
            //mirror marking menu
            button -w $buttonWidth -al center -label "Mirror" -ann "Tools to extrapolate weighting from deformers to joints" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Create Mirror", "nas_mirrorDeformerWeights x 1", "E", "0", ""};
            //blendshape marking menu
            button -w $buttonWidth -al center -label "Blendshape" -ann "Tools to extrapolate weighting from deformers to joints" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" { 
                "Scroll Model", "nas_scrollModelUI", "W", "0", "Model your corrective shape with your mouse wheel!"};
            //setups marking menu
            button -w $buttonWidth -al center -label "Setups" -ann "Tools to extrapolate weighting from deformers to joints" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "dkLimb", "nas_wireDeformerSetup", "W", "0", "Select cvs on wire and run this to create controls and rotate clusters. Wire deformer must already be connected"};
            setParent ..;
        setParent ..;
    $frames[size($frames)] = $frame;
    
    //Finaling
    $cmd = ("frameLayout -e -h " + "(`nas_riggingUINumRows " + 8 + " " + $buttonWidth + " " + $window + "`*22+20) ");
    $frame = `frameLayout -h ((nas_riggingUINumRows(8, $buttonWidth, $window))*22+20) -label "Finaling" -collapsable 1 -borderVisible 1 -borderStyle "etchedOut"`;
    frameLayout -e -expandCommand ($cmd + $frame + "; print \"" + $cmd + $frame + "\"") $frame;
        gridLayout -cellWidthHeight $buttonWidth 22 -columnsResizable 1;
            //shade marking menu
            button -w $buttonWidth -al center -label "Shade" -ann "tools for manipulating shaders" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Consolidate Shaders", "dkConsolidateShaders", "S", "0", "",
                /*"Delete Shaders", "", "E", "1", "", 
                    "Consolidate Shaders", "dkConsolidateShaders", "E", "2", "",
                    "Remove Unused Shaders", "dkRemoveUnusedShadingNodes", "S", "0", "",*/
                "Set Hires Geo To Renderable", "nas_setHiresToRenderable", "SW", "0", "Sets all Render Stats to on for all geos in hires group",
                "Make Non-Renderable", "nas_makeNonRenderable", "SE", "0", "Sets all Render Stats except double sided to 0 for selection",
                "Import Shaders", "dkImportShaders", "NE", "0", "",
                "Shader Matches", "dkShaderMatches", "NW", "0", "Select shaders and run to see which shaders do not match shaders in the asset's shader directory"};
            //final marking menu
            button -w $buttonWidth -al center -label "Final" -ann "tools to help with finaling a character" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Smooth Proxy", "dkSmoothProxy", "W", "0", "",
                "Turn off LRAs", "for ($item in `ls -type \"transform\"`) if (`objExists ($item + \".displayLocalAxis\")`) setAttr ($item + \".displayLocalAxis\") 0;", "SE", "0", "Turns off all local axes in the scene", 
                "Connect Smooths", "nas_reconnectSmooths", "S", "0", "", 
                "Create Missing Layers", "nas_createLayers", "E", "0", "",  
                "Constrain To Group", "dkConstrainToGroup", "N", "0", ""};
            /*
            //review marking menu
            button -w $buttonWidth -al center -label "Review" -ann "tools to help with finishing a file" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "Kill & Version", "nas_killWindows;dkSaveNewVersion", "NW", "0", "", 
                //"Reload", "dkReloadFile", "SW", "0", "",
                //"File Path", "dkReturnPath 1", "SW", "0", "",
                //"File Name", "dkReturnPath 2", "E", "0", "", 
                //"Out WIP Name", "dkReturnPath 0", "SE", "0", ""
                //"Prop", "dkCheckProp", "W", "0", "",
                //"Character", "dkCheck", "E", "0", "", 
                //"Kill Windows", "nas_killWindows;", "NW", "0", ""
            };
            */
            //check button
            button -w $buttonWidth -al center -label "Check" -ann "tools to help with finishing a file" -backgroundColor .3 .65 1;
            nas_markingMenu 1 "" {
                "KF", "nas_finalCharChecks", "E", "0", "final character checks"
            };
            setParent ..;
        setParent ..;
    $frames[size($frames)] = $frame;
    
    //Labs
    $cmd = ("frameLayout -e -h " + "(`nas_riggingUINumRows " + 5 + " " + $buttonWidth + " " + $window + "`*22+20) ");
    $frame = `frameLayout -h ((nas_riggingUINumRows(5, $buttonWidth, $window))*22+20) -label "Labs" -collapsable 1 -borderVisible 1 -borderStyle "etchedOut"`;
    frameLayout -e -expandCommand ($cmd + $frame + ";window -e -w (`window -q -w " + $window + "`+1) " + $window + ";window -e -w (`window -q -w " + $window + "`-1) " + $window + ";") $frame;
        gridLayout -cellWidthHeight $buttonWidth 22 -columnsResizable 1;
            $labels = {"LatticeUI"};
            $cmds = {"dkWeightVertsUI"};
            $notes = {"Make sure that the x axis is going down the bone for your lattice"};
                        for ($i = 0; $i < size($labels); $i++) button -w $buttonWidth -al center -label $labels[$i] -c $cmds[$i] -ann $notes[$i];    
            setParent ..;
        setParent ..;
    $frames[size($frames)] = $frame;
    
    for ($frame in $frames) {
        frameLayout -e -collapse 1 $frame;
    }
    
    formLayout -e
        -af $helpFrame "top" 2    
        -af $helpFrame "left" 2
        -af $helpFrame "right" 2
                
        -ac $scroll "top" 2 $helpFrame
        -af $scroll "left" 0
        -af $scroll "right" 0
        -af $scroll "bottom" 0
        $form;
        
    $array[0] = `about -v`;
    $array = stringToStringArray($array[0], " ");
    if (`about -os` == "win64" && $array[0] == "2011") window -e -toolbox 1 $window;
    if (`about -os` == "win64" && $array[0] == "2012") window -e -toolbox 1 $window;
    
    showWindow $window;
    window -e -w (`window -q -w $window`+1) $window;
    window -e -w (`window -q -w $window`-1) $window;
}

//=====================================================================================================================================
//=============================================================nas_UI=============================================================
//=====================================================================================================================================

//---------------------------------------------------------------nas_window---------------------------------------------------------------------
//creates a window with version numbers in the title of the window
//user must provide the name of the window, followed by three integers that make up the version number
global proc string nas_window(string $name, int $major, int $minor, int $part) {
    for ($i = 0; $i <= $major; $i++) for ($j = 0; $j <= $minor; $j++) for ($k = 0; $k <= $part; $k++) if (`window -ex ($name + "_" + $i + "_" + $j + "_" + $k)`) deleteUI ($name + "_" + $i + "_" + $j + "_" + $k);
    string $window = `window -title ($name + " " + $major + "." + $minor + "." + $part) -menuBar true -minimizeButton true ($name + "_" + $major + "_" + $minor + "_" + $part)`;
    return $window;
}

//---------------------------------------------------------------nas_buttonLayout---------------------------------------------------------------------
//can create a button and all marking menus within it
//user specifies which mouse button activates 
global proc string[] nas_buttonLayout(string $array[]) {
    string $labels[], $commands[], $positions[], $annotations[], $buttons[];
    int $subMenus[], $currentSubMenus[], $subMenu, $ctrl, $shift, $alt, $mouseButton;
    vector $bgc;
    
    for ($i = 0; $i < size($array); $i+=5) { 
        $labels[size($labels)] = $array[$i];
        $commands[size($commands)] = $array[$i+1];
        $positions[size($positions)] = $array[$i+2];
        $subMenus[size($subMenus)] = $array[$i+3];
        $annotations[size($annotations)] = $array[$i+4];
    }
    
    for ($i = 0; $i < size($labels); $i++) {
        $ctrl = 0;
        $shift = 0;
        $alt = 0;
        if ($labels[$i+1] == "newPopup") $bgc = <<.3, .65, 1>>;
        else if (`endString $commands[$i] 2` == "UI") $bgc = <<.35, .95, .3>>;
        else if ($labels[$i] == "Refresh") $bgc = <<1, .5, 0>>;
        else $bgc = <<.925, .914, .847>>;
        
        if ($positions[$i] == "") {
            $buttons[size($buttons)] = `button -al center -label $labels[$i] -c $commands[$i] -ann $annotations[$i] -bgc ($bgc.x) ($bgc.y) ($bgc.z)`;
        } else {
            if ($labels[$i] == "newPopup") {
                if (`gmatch $positions[$i] "*ctrl*"`) $ctrl = 1;
                if (`gmatch $positions[$i] "*shift*"`) $shift = 1;
                if (`gmatch $positions[$i] "*alt*"`) $alt = 1;
                $mouseButton = $commands[$i];
                popupMenu -markingMenu 1 -b $mouseButton -ctrlModifier $ctrl -shiftModifier $shift -altModifier $alt -allowOptionBoxes true;
            } else {
                if ($subMenus[$i] == 2) $subMenu = 0;
                else $subMenu = $subMenus[$i];        
                menuItem
                    -ann $annotations[$i]
                    -label $labels[$i]
                    -divider 0 
                    -subMenu $subMenu 
                    -command $commands[$i] 
                    -altModifier 0
                    -optionModifier 0
                    -commandModifier 0
                    -ctrlModifier 0 
                    -shiftModifier 0
                    -optionBox 0
                    -enable 1
                    -data 0
                    -radialPosition $positions[$i] 
                    -enableCommandRepeat 1
                    -image "commandButton.xpm" 
                    -echoCommand 0
                    -italicized 0
                    -boldFont 0;
                if ($subMenus[$i] == 0) setParent -m ..;
            }
        }
    }
    return $buttons;
}

//---------------------------------------------------------------nas_buttonFormLayout---------------------------------------------------------------------
global proc string nas_buttonFormLayout(string $array[]) {
    string $form, $buttons[], $cmd;
    int $numButtons, $percent, $remainder, $rightPos;
    
    $form = `formLayout`;
    $buttons = `nas_buttonLayout $array`;
    
    $numButtons = size($buttons);
    $percent = 100 / $numButtons;
    $remainder = 100 - ($percent * $numButtons);
    
    //creates the cmd that will organize the form
    $cmd = "formLayout -e \n";
    $cmd += ("\t\t-af " + $buttons[0] + " \"top\" 0\n");
    $cmd += ("\t\t-af " + $buttons[0] + " \"bottom\" 0\n");
    $cmd += ("\t\t-af " + $buttons[0] + " \"left\" 0\n");
    
    if ($percent != 100) {
        if ($remainder) {
            $rightPos = $percent + 1;
            $remainder--;
        } else {
            $rightPos = $percent;
        }
        $cmd += ("\t\t-ap " + $buttons[0] + " \"right\" 0 " + $rightPos + "\n\n");
        
        for ($i = 1; $i < (size($buttons)-1); $i++) {
            $cmd += ("\t\t-af " + $buttons[$i] + " \"top\" 0\n");
            $cmd += ("\t\t-af " + $buttons[$i] + " \"bottom\" 0\n");
            $cmd += ("\t\t-ap " + $buttons[$i] + " \"left\" 0 " + ($rightPos) + "\n");
            
            if ($remainder) {
                $rightPos += $percent + 1;
                $remainder--;
            } else {
                $rightPos = ($percent*($i+1));
            }
            $cmd += ("\t\t-ap " + $buttons[$i] + " \"right\" 0 " + $rightPos + "\n\n");
        }
        
        $cmd += ("\t\t-af " + $buttons[size($buttons)-1] + " \"top\" 0\n");
        $cmd += ("\t\t-ap " + $buttons[size($buttons)-1] + " \"left\" 0 " + $rightPos + "\n");
        $cmd += ("\t\t-af " + $buttons[size($buttons)-1] + " \"right\" 0\n");
        $cmd += ("\t\t-af " + $buttons[size($buttons)-1] + " \"bottom\" 0\n\n");
    } else {
        $cmd += ("\t\t-af " + $buttons[0] + " \"right\" 0\n");
    }
    $cmd += ("\t\t" + $form + ";");
    
    print ("\n\n" + $cmd + "\n\n");
    eval($cmd);
    
    return $form;
}

//---------------------------------------------------------------nas_radioCheckBoxGrp---------------------------------------------------------------------
global proc string[] nas_radioCheckBoxGrp (string $textLabel, int $textWidth, string $radioLabels[], string $defaults[], string $checkBoxLabel, int $checkBoxWidth, string $commands[]) {
    string $form, $text, $radioForm, $radioButtons[], $formLayoutCommand, $array[], $checkBox;
    $form = `formLayout`;
        $text = `text -align left -w $textWidth -label $textLabel`;
        $radioForm = `formLayout`;
            radioCollection;
                for ($i = 0; $i < size($radioLabels); $i++) {
                    $radioButtons[$i] = `radioButton -align left -label $radioLabels[$i] -onCommand $commands[$i]`;
                    if ($defaults[$i] == "1") radioButton -e -select $radioButtons[$i];
                }
            setParent..;
        $formLayoutCommand = "formLayout -e \n";
        for ($i = 0; $i < size($radioButtons); $i++) {
            if ($i == 0) $formLayoutCommand += ("-af " + $radioButtons[$i] + " \"top\" 0 \n-ap " + $radioButtons[$i] + " \"right\" 0 " + ((100/size($radioButtons)) * ($i+1)) + " \n-af " + $radioButtons[$i] + " \"bottom\" 0 \n-af " + $radioButtons[$i] + " \"left\" 0 \n\n");
            else if ($i == (size($radioButtons)-1)) $formLayoutCommand += ("-af " + $radioButtons[$i] + " \"top\" 0 \n-af " + $radioButtons[$i] + " \"right\" 0 \n-af " + $radioButtons[$i] + " \"bottom\" 0 \n-ap " + $radioButtons[$i] + " \"left\" 0 " + ((100/size($radioButtons)) * $i) + " \n");
            else $formLayoutCommand += ("-af " + $radioButtons[$i] + " \"top\" 0 \n-ap " + $radioButtons[$i] + " \"right\" 0 " + ((100/size($radioButtons)) * ($i+1)) + " \n-af " + $radioButtons[$i] + " \"bottom\" 0 \n-ac " + $radioButtons[$i] + " \"left\" 0 " + $radioButtons[$i-1] + " \n\n");
        }
        $formLayoutCommand += ($radioForm + ";");
        eval $formLayoutCommand;
        if (size($checkBoxLabel)) {
            if (size($commands) >= (size($radioLabels)+2)) $checkBox = `checkBoxGrp -numberOfCheckBoxes 1 -label1 $checkBoxLabel -cw 1 $checkBoxWidth -cal 1 center -onCommand $commands[size($commands)-2] -offCommand $commands[size($commands)-1]`;
            else $checkBox = `checkBoxGrp -numberOfCheckBoxes 1 -label1 $checkBoxLabel -cw 1 $checkBoxWidth -cal 1 center`;
            formLayout -e 
            -af $text "top" 0
            -af $text "bottom" 0
            -af $text "left" 0
            
            -af $radioForm "top" 0
            -ac $radioForm "left" 0 $text
            -ac $radioForm "right" 0 $checkBox
            -af $radioForm "bottom" 0
            
            -af $checkBox "top" 0
            -af $checkBox "right" 0
            -af $checkBox "bottom" 0
            $form;
        } else {
            formLayout -e 
            -af $text "top" 0
            -af $text "left" 0
            -af $text "bottom" 0
            
            -af $radioForm "top" 0
            -ac $radioForm "left" 0 $text
            -af $radioForm "right" 5
            -af $radioForm "bottom" 0
            $form;
        }
    setParent..;
    $array[0] = $form;
    $array = stringArrayCatenate ($array, $radioButtons);
    if (size($checkBoxLabel)) $array[size($array)] = $checkBox;
    return $array;
}

//=====================================================================================================================================
//=============================================================nas_save=============================================================
//=====================================================================================================================================

//---------------------------------------------------------------nas_sceneInfo---------------------------------------------------------------------
global proc string[] nas_sceneInfo() {
    string $location, $locations[], $oldName, $array[];
    int $lastLen, $totalLen, $locationLen;

    $locations = `file -q -l`;
    $oldName = `file -q -shortName -location`;
    $lastLen = size($oldName);
    $totalLen = size($locations[0]);
    $locationLen = $totalLen - $lastLen;
    $location = `substring $locations[0] 1 $locationLen`;
    tokenize $oldName "." $array;
    $array = {$location, $array[0]};
    return $array;
}

//---------------------------------------------------------------nas_saveNewVersion---------------------------------------------------------------------
global proc nas_saveNewVersion() {
    string $location, $locations[], $parts[], $newName, $array[], $name, $panels[], $windows[], $appearances[];
    int $lastLen, $totalLen, $locationLen, $versionNum, $winToggles[], $wireframes[];
    global int $dkAutoSaveClicks;
    $dkAutoSaveClicks = 0;

    $array = `nas_sceneInfo`;
    $location = $array[0];
    $name = $array[1];
    
    $parts = stringToStringArray($name, "_");
    $newName = $parts[0];
    for ($i = 1; $i < size($parts); $i++) {
        if (`gmatch $parts[$i] "v*[0-9]"` || `gmatch $parts[$i] "V*[0-9]"`) {
            $version = `substring $parts[$i] 2 (size($parts[$i]))`;
            $versionNum = $version;
            $versionNum++;
            $command = "nas_framePadding \"v";
            for ($j = 0; $j < size($version); $j++) $command += "#";
            $command += ("\" " + $versionNum);
            $parts[$i] = `eval $command`;
        } else if ($parts[$i] == "CG" || $parts[$i] == "PS" || $parts[$i] == "DQ" || $parts[$i] == "OK" || $parts[$i] == "TC") {
            $parts[$i] = "NK";
        }
        $newName += ("_" + $parts[$i]);
    }
    $newName += ".ma";
    
    //get panel and window vis info
    $panels  = `nas_getVisibleModelPanels`;
    for ($i = 0; $i < size($panels); $i++) {
        $wireframes[$i] = `modelEditor -q -wireframeOnShaded $panels[$i]`; 
        if ($wireframes[$i] != 0) modelEditor -e -wireframeOnShaded 0 $panels[$i];
        $appearances[$i] = `modelEditor -q -displayAppearance $panels[$i]`; 
        if ($appearances[$i] != "boundingBox") modelEditor -e -displayAppearance boundingBox $panels[$i];
    }
    
    //rename file and save
    file -rename ($location + $newName);
    file -f -s -type "mayaAscii";
    
    //bring panel windows and panel displays back
    for ($i = 0; $i < size($panels); $i++) {
        modelEditor -e -wireframeOnShaded $wireframes[$i] $panels[$i]; 
        modelEditor -e -displayAppearance $appearances[$i] $panels[$i]; 
    }
    
    print ("New version saved as " + $location + $newName);
}

//---------------------------------------------------------------nas_saveSceneAs---------------------------------------------------------------------
//opens the file browser in the folder above the one you are working in
global proc nas_saveSceneAs() {
    global string $gOptBoxForm;
    string $fileLoc, $array[], $refs[], $version, $file[], $path;
    
    $fileLoc = `file -q -sn`;
    $array = stringToStringArray($fileLoc, "/");
    stringArrayRemoveAtIndex(size($array)-1, $array);
    stringArrayRemoveAtIndex(size($array)-1, $array);
    $fileLoc = stringArrayToString($array, "/");
    optionVar -sv "browserLocationmayaAsciiscene" $fileLoc;
    setWorkingDirectory `workspace -fn` "mayaAscii" "scene";
    $version = `about -v`;
    $array = stringToStringArray($version, " ");
    if ($array[0] == "2011" || $array[0] == "2012") {
        if ("" != $gOptBoxForm && `layout -exists $gOptBoxForm`) hideOptionBoxNow();
        $file = `fileDialog2 -dialogStyle 1 -caption "Save As" -fileMode 0 -okCaption "Save As" -optionsUICreate "fileOperationsOptionsUISetup SaveAs" -optionsUIInit "fileOperationsOptionsUIInitValues SaveAs" -selectionChanged "fileOperationsSelectionChangedCallback SaveAs" -optionsUICommit "fileOperationsOptionsUICallback SaveAs" -fileTypeChanged "setCurrentFileTypeOption SaveAs" -fileFilter "Maya ASCII (*.ma);;Maya Binary (*.mb)" -selectFileFilter "mayaAscii" -startingDirectory $fileLoc`;
        
        if(size($file) > 0 && $file[0] != "") {
            string $path = fromNativePath($file[0]);
            eval ("performFileAction \"" + $path + "\" \"SaveAs\"");
            }
    } else {
        fileBrowserDialog -mode 1 -fileCommand "dkSaveAsBrowser" -fileType "mayaAscii" -actionName "Save";
    }
}

//---------------------------------------------------------------nas_saveAsBrowser---------------------------------------------------------------------
global proc nas_saveAsBrowser(string $path, string $type) {
    file -rename $path;
    file -f -s -type $type;
}

//---------------------------------------------------------------nas_openFile---------------------------------------------------------------------
//opens the file browser in the folder above the one you are working in
global proc nas_openFile() {
    global string $gDefaultFileBrowserDir;
    string $fileLoc, $array[], $version;
    
    $fileLoc = `file -q -sn`;
    $array = stringToStringArray($fileLoc, "/");
    stringArrayRemoveAtIndex(size($array)-1, $array);
    $fileLoc = stringArrayToString($array, "/");
    optionVar -sv "browserLocationmayaAsciiscene" $fileLoc;
    $gDefaultFileBrowserDir = $fileLoc;
    
    $version = `about -v`;
    $array = stringToStringArray($version, " ");
    if ($array[0] == "2011" || $array[0] == "2012") {
        $file = `fileDialog2 -dialogStyle 1 -caption "Open" -fileMode 1 -okCaption "Open" -optionsUICreate "fileOperationsOptionsUISetup Open" -optionsUIInit "fileOperationsOptionsUIInitValues Open" -selectionChanged "fileOperationsSelectionChangedCallback Open" -optionsUICommit "fileOperationsOptionsUICallback Open" -fileTypeChanged "setCurrentFileTypeOption Open" -fileFilter "Maya Scenes (*.ma *.mb);;Maya ASCII (*.ma);;Maya Binary (*.mb);;All Files (*)" -selectFileFilter "mayaAscii" -startingDirectory $fileLoc`;
        if (size($file) > 0 && $file[0] != "") {
            file -f -options "v=0" -typ "mayaAscii" -o $file[0];
            addRecentFile($file[0], "mayaAscii");
        }
    } else {
        OpenScene;
    }
}

//---------------------------------------------------------------nas_reloadFile---------------------------------------------------------------------
global proc nas_reloadFile() {
    if (`confirmDialog -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -message "Are you sure you want to re-open the file without saving?"` == "OK") {
        file -f -o `file -q -sn`;
    }
}

//=====================================================================================================================================
//=============================================================nas_interactive=============================================================
//=====================================================================================================================================

//---------------------------------------------------------------nas_getVisibleModelPanels---------------------------------------------------------------------
//returns model panels (i.e. modelPanel4) that are being used
global proc string[] nas_getVisibleModelPanels() {
    string $modelPanels[], $panels[];
    $modelPanels = `getPanel -type modelPanel`;
    $panels = stringArrayRemove((stringArrayRemove(`getPanel -vis`, $modelPanels)), $modelPanels);
    return $panels;
}

//=====================================================================================================================================
//=============================================================nas_generalist=============================================================
//=====================================================================================================================================

//---------------------------------------------------------------nas_moveToOrigin---------------------------------------------------------------------
//moves selected geos to the origin and makes sure lowest vert in selected geo transforms is at 0 in translateY
//user inputs a freeze option if geos must be zero'd out at origin
global proc nas_moveToOrigin(int $freeze) {
    string $array[], $sels[];
    float $wp[], $bb[];

    $sels = `ls -sl -long`;
    
    if ($freeze) makeIdentity -apply true -t 1 -r 1 -s 1 $sels;
    $bb = `nas_boundingBox $sels`;
    $wp = {(($bb[0]+$bb[3])/2), $bb[1], (($bb[2]+$bb[5])/2)};
    move -r (-1*$wp[0]) (-1*$wp[1]) (-1*$wp[2]) $sels;
    if ($freeze) {
        makeIdentity -apply true -t 1 -r 1 -s 1 $sels;
        delete -ch $sels;
    }
}

//=====================================================================================================================================
//=============================================================nas_utilities=============================================================
//=====================================================================================================================================

//---------------------------------------------------------------nas_boundingBox---------------------------------------------------------------------
global proc float[] nas_boundingBox(string $sels[]) {
    string $geos[], $array[], $currGeos[];
    float $trialbb[], $bb[];
    
    for ($sel in $sels) {
        $array = stringToStringArray($sel, ".");
        if (`nodeType $array[0]` == "mesh" || `nodeType $array[0]` == "lattice" || `nodeType $array[0]` == "nurbsSurface" || `nodeType $array[0]` == "transform") $geos[size($geos)] = $array[0];
    }
    $geos = stringArrayRemoveDuplicates($geos);
    
    for ($i = 0; $i < size($geos); $i++) {
        clear $currGeos;
        for ($sel in $sels) {
            $array = stringToStringArray($sel, ".");
            if ($array[0] == $geos[$i]) $currGeos[size($currGeos)] = $sel;
        }
        $trialbb = `xform -ws -q -bb $currGeos`;
        if ($i == 0) {
            $bb = $trialbb;
        } else {
            for ($j = 0; $j < 3; $j++) if ($trialbb[$j] < $bb[$j]) $bb[$j] = $trialbb[$j];
            for ($j = 3; $j < 6; $j++) if ($trialbb[$j] > $bb[$j]) $bb[$j] = $trialbb[$j];
        }
    }
    return $bb;
}

//---------------------------------------------------------------nas_group---------------------------------------------------------------------
//Creates a new group that matches the rotate pivot point of selection
//User must pass in 0 or 1 for not replacing and replacing the suffix of selection respectively when naming new group
//If no suffix is passed a "_Group" suffix will be attached

global proc string[] nas_group(int $suffix, string $list) {
    string $array[], $sels[], $object, $parent, $parts[], $nodes[], $groups[], $groupName, $group;
    float $wp[];
    
    $suffixNames = stringToStringArray($list, ", ");
    $sels = `ls -sl -long -type transform`;
    for ($sel in $sels) {
        for ($suffixName in $suffixNames) {
            //grouping
            $group = `group -em -n "nas_group_emptyGroup_Stewart_Joseph_Shaw"`;
            $array = `listRelatives -p -fullPath $sel`;
            $parent = $array[0];
            if (`objExists ($sel + ".rotateOrder")`) setAttr ($group + ".rotateOrder") `getAttr ($sel + ".rotateOrder")`;
            $wp = `xform -ws -q -rp $sel`;
            xform -ws -rp $wp[0] $wp[1] $wp[2] $group;
            xform -ws -sp $wp[0] $wp[1] $wp[2] $group;
            parent $group $sel;
            makeIdentity -apply true -t 1 -r 1 -s 1 $group;
            
            //figuring out what the group's name should be
            if ($suffixName == "") {
                $groupName = ($sel + "_Group");
            } else {
                if ($suffix) {
                    $array = stringToStringArray($sel, "|");
                    $array = stringToStringArray($array[size($array)-1], "_");
                    stringArrayRemoveAtIndex((size($array)-1), $array);
                    $groupName = ((stringArrayToString($array, "_")) + "_" + $suffixName);
                } else {
                    $array = stringToStringArray($sel, "|");
                    $groupName = ($array[size($array)-1] + "_" + $suffixName);
                }
            }
            
            //parent group to parent
            if (size($parent)) parent $group $parent;
            else parent -w $group;
            parent $sel $group;
            $group = `rename $group $groupName`;
            $groups[size($groups)] = $group;            
        }
    }
    select -r $groups;
    return $groups;
}

global proc nas_groupUI() {
    global string $nas_groupCheckbox;
    string $result, $input;
    $result = `promptDialog -title "nas_group" -ma "center" -message "Comma separated suffixes:" -text "Group" -button "Group" -button "Cancel" -defaultButton "Group" -cancelButton "Cancel" -dismissString "Cancel"`;    
    if ($result == "Group") {
         $input = `promptDialog -query -text`;
         if (`menuItem -q -cb $nas_groupCheckbox`) nas_group 1 $input;
        else nas_group 0 $input;    
    }
}

//---------------------------------------------------------------nas_rename---------------------------------------------------------------------
//Renames selection in the order selected
//User must a # sign to signify where to number names
global proc string[] nas_rename(string $name) {
    string $sels[], $rename, $array[], $newNames[];
    $sels = `ls -sl`;
    if (`gmatch $name "*#*"`) {
        for ($i = (size($sels)-1); $i >= 0; $i--) {
            $rename = `nas_framePadding $name ($i+1)`;
            $newNames[$i] = `rename $sels[$i] $rename`;
        }
    } else {
        for ($sel in $sels) $newNames[size($newNames)] = `rename $sel $name`;
    }
    return $newNames;
}

global proc nas_renameUI() {
    string $result, $prefix, $suffix, $input, $array[];
    $array = `ls -sl`;
    $result = `promptDialog 
         -title "nas_rename"
         -ma "center"
         -message "Use \">\" for prefixes\n\"#\" for number placement\n\"<\" for suffixes"
        -text $array[0] 
         -button "Rename" -button "Cancel" 
         -defaultButton "Rename" -cancelButton "Cancel"
         -dismissString "Cancel"`;
         
     if ($result == "Rename") {
         $input = `promptDialog -query -text`;
        if (`gmatch $input "*>*"`) {
            $array = stringToStringArray($input, ">");
            if (size($array) > 2) error "Input must contain only one \">\" sign";
            $prefix = $array[0];
            $input = $array[1];
        }
        if (`gmatch $input "*<*"`) {
            $array = stringToStringArray($input, "<");
            if (size($array) > 2) error "Input must contain only one \"<\" sign";
            if (size($array) > 1) {
                $suffix = $array[1];
                $input = $array[0];
            } else $suffix = $array[0];
        }
        if (`gmatch $input "*#*"`) {
            $array = stringToStringArray($input, "#");
            if (size($array) > 2) error "Input must contain \"#\" signs in only one place";
            nas_rename $input;
        } else {
            nas_rename $input;
        }
        if (size($prefix)) nas_prefix $prefix;
        if (size($suffix)) nas_suffix $suffix;
    }
}

//---------------------------------------------------------------nas_prefix---------------------------------------------------------------------
//adds prefix to selected objects' names
global proc nas_prefix(string $prefix) {
    string $sels[] = `ls -sl`;
    for ($sel in $sels) rename $sel ($prefix + "_" + $sel);
}

//---------------------------------------------------------------nas_suffix---------------------------------------------------------------------
//adds suffix to selected objects' names
global proc nas_suffix(string $suffix) {
    string $sels[] = `ls -sl`;
    for ($sel in $sels) rename $sel ($sel + "_" + $suffix);
}

//---------------------------------------------------------------nas_segments---------------------------------------------------------------------
//creates a user defined number of locators in between two selected objects
global proc string[] nas_segments(int $num) {
    string $constraint, $startLoc, $endLoc, $parent, $rename;
    string $array[], $locators[], $group;
    float $increment;
    
    $array = `ls -sl`;
    if (size($array) != 2) error "Must select two objects to create locators between.";
    $startLoc = $array[0];
    $endLoc = $array[1];

    if ($num <= 0) {
       $locators[0] = $startLoc;
       $locators[1] = $endLoc;
       return $locators;
    }
    
    $array = `listRelatives -p $startLoc`;
    $parent = $array[0];
    $locators[0] = $startLoc;
    $increment = 1.000 / ($num + 1);
    for ($i = 0; $i < $num; $i++) {
        $array = `spaceLocator -p 0 0 0`;
        //scale -r .1 .1 .1 $array[0];
        $locators[$i+1] = $array[0];
        $array = `pointConstraint $startLoc $endLoc $locators[$i+1]`;
        $constraint = $array[0];
        setAttr ($constraint + "." + $startLoc + "W0") (1 - (($i + 1) * $increment));
        setAttr ($constraint + "." + $endLoc + "W1") (($i + 1) * $increment);
        delete $constraint;
    }
    $locators[$num+1] = $endLoc;
    $group = `group $locators`;
    if ($parent != "") parent $locators $parent;
    else parent -w $locators;
    delete $group;
    select -r $locators;
    return $locators;
}

global proc nas_segmentsUI() {
    int $num;
    $result = `promptDialog -b "OK" -b "Cancel" -db "OK" -message "How many locators in between?" -messageAlign "center" -text "duuuuuude" -title "# of Locators" -dismissString "Cancel"`;
    if ($result == "OK") $num = `promptDialog -q -text`;
    nas_segments $num;
}

//-------------------------------------------------------------nas_joints---------------------------------------------------------------------
//creates joints from selected locators that are oriented by aim axis, up axis, and worldUp axis (wherever the up axis is supposed to point)
global proc string[] nas_joints(string $name, string $aimAxis, string $upAxis, string $worldUpAxis, int $useUpObject) {
    string $locs[], $endLoc, $array[], $joints[], $incrementedName, $upObject;
    float $locsRp[];
    vector $aimVector, $upVector, $worldUpVector;
    
    if ($useUpObject) {
        $array = `ls -sl`;
        $upObject = $array[size($array)-1];
        $locs = stringArrayRemove({$upObject}, $array);
    } else {
        $locs = `ls -sl`;
    }

    //error checking
    if ($name == "") error "Must provide a name for your joints.\n";
    if ($useUpObject && size($locs) < 3) error "Must select at least 3 locators for nas_joints with upObject to work.\n";
    else if (size($locs) < 2) error "Must select at least 2 locators for nas_joints without upObject to work.\n";
    for ($i = 0; $i < size($locs); $i++) if (`nodeType $locs[$i]` != "transform") error "Selection must be of type: transform.\n";
    
    //vector assignment to specified aim and up axis
    $aimVector = `nas_axisToVector $aimAxis`;
    $upVector = `nas_axisToVector $upAxis`;
    $worldUpVector = `nas_axisToVector $worldUpAxis`;

    //joints at locators
    for ($i = 0; $i < size($locs); $i++) {
        select -cl;
        $locsRp = `xform -q -ws -rp $locs[$i]`;
        $incrementedName = `nas_framePadding $name ($i+1)`;
        $joints[$i] = `joint -n $incrementedName -p $locsRp[0] $locsRp[1] $locsRp[2]`;
        setAttr ($joints[$i] + ".rotateOrder") `getAttr ($locs[$i] + ".rotateOrder")`;
    }

    //orients each of the joints
    for ($i = 0; $i < size($joints); $i++) {
        if ($i < (size($joints) - 1)) {
            if (size($upObject)) delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector ($aimVector.x) ($aimVector.y) ($aimVector.z) -upVector ($upVector.x) ($upVector.y) ($upVector.z) -worldUpType "object" -worldUpObject $upObject $joints[$i+1] $joints[$i]`;
            else delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector ($aimVector.x) ($aimVector.y) ($aimVector.z) -upVector ($upVector.x) ($upVector.y) ($upVector.z) -worldUpType "vector" -worldUpVector ($worldUpVector.x) ($worldUpVector.y) ($worldUpVector.z) $joints[$i+1] $joints[$i]`;
        } else {
            if (size($upObject)) delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector (-1*($aimVector.x)) (-1*($aimVector.y)) (-1*($aimVector.z)) -upVector ($upVector.x) ($upVector.y) ($upVector.z) -worldUpType "object" -worldUpObject $upObject $joints[$i-1] $joints[$i]`;
            else delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector (-1*($aimVector.x)) (-1*($aimVector.y)) (-1*($aimVector.z)) -upVector ($upVector.x) ($upVector.y) ($upVector.z) -worldUpType "vector" -worldUpVector ($worldUpVector.x) ($worldUpVector.y) ($worldUpVector.z) $joints[$i-1] $joints[$i]`;
        }
        if ($i > 0) parent $joints[$i] $joints[$i-1];
    }

    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $joints;
    select -r $joints;
    return $joints;
}

global proc nas_jointsUI() {
    string $window, $form, $row, $button, $separator1, $separator2, $separator3;
    global string $nasJointsAimAxisGrp[], $nasJointsUpAxisGrp[], $nasJointsUpDirectionGrp[], $nasJointsName, $nasJointsModeGrp[];

    $window = `nas_window nas_joints 1 0 0`;
        $form = `formLayout`;
            $separator = `separator`;
            $row = `rowLayout -numberOfColumns 2 -cw 1 35 -adj 2`;
                text -label "Name:";
                $nasJointsName = `textField`;
                setParent..;
            $separator2 = `separator`;
            $nasJointsAimAxisGrp = `nas_radioCheckBoxGrp "Aim Axis:" 65 {"X", "Y", "Z"} {"1", "", ""} "Negative" 65 {}`;
            $separator3 = `separator`;
            $nasJointsUpAxisGrp = `nas_radioCheckBoxGrp "2nd Axis:" 65 {"X", "Y", "Z"} {"", "1", ""} "Negative" 65 {}`;
            $nasJointsUpDirectionGrp = `nas_radioCheckBoxGrp "2nd Axis Aim:" 65 {"X", "Y", "Z"} {"", "1", ""} "Negative" 65 {}`;
            $button = `button -label "Create Joints" -command nas_jointsUIExecute`;
            $nasJointsModeGrp = `nas_radioCheckBoxGrp "Mode" 35 {"Create", "Orient"} {"1", ""} "2nd Axis Aim Object" 115 {
                ("rowLayout -e -visible 1 " + $row + ";separator -e -visible 1 " + $separator2 + ";button -e -label \"Create Joints\" " + $button), 
                ("rowLayout -e -visible 0 " + $row + ";separator -e -visible 0 " + $separator2 + ";button -e -label \"Orient Joints\" " + $button), 
                ("formLayout -e -visible 0 " + $nasJointsUpDirectionGrp[0]), 
                ("formLayout -e -visible 1 " + $nasJointsUpDirectionGrp[0])}`;
            
        formLayout -e
            -af $nasJointsModeGrp[0] "top" 5 
            -af $nasJointsModeGrp[0] "right" 5
            -af $nasJointsModeGrp[0] "left" 5
            
            -ac $separator "top" 5 $nasJointsModeGrp[0]
            -af $separator "right" 5
            -af $separator "left" 5
            
            -ac $row "top" 5 $separator
            -af $row "right" 5
            -af $row "left" 5
            
            -ac $separator2 "top" 5 $row
            -af $separator2 "right" 5
            -af $separator2 "left" 5
            
            -ac $nasJointsAimAxisGrp[0] "top" 5 $separator2
            -af $nasJointsAimAxisGrp[0] "right" 5
            -af $nasJointsAimAxisGrp[0] "left" 5
            
            -ac $separator3 "top" 5 $nasJointsAimAxisGrp[0]
            -af $separator3 "right" 5
            -af $separator3 "left" 5
            
            -ac $nasJointsUpAxisGrp[0] "top" 5 $separator3
            -af $nasJointsUpAxisGrp[0] "right" 5
            -af $nasJointsUpAxisGrp[0] "left" 5
            
            -ac $nasJointsUpDirectionGrp[0] "top" 5 $nasJointsUpAxisGrp[0]
            -af $nasJointsUpDirectionGrp[0] "right" 5
            -af $nasJointsUpDirectionGrp[0] "left" 5
            
            -ac $button "top" 5 $nasJointsUpDirectionGrp[0]
            -af $button "right" 5
            -af $button "bottom" 5
            -af $button "left" 5
            $form;
        setParent..;
    window -e -wh 280 210 $window;
    showWindow $window;
}

global proc nas_jointsUIExecute() {
    string $name, $aimAxis, $upAxis, $upDirectionAxis, $mode;
    vector $aimAxisVector, $upVector, $upDirectionVector;
    int $x, $y, $z, $useUpObject;
    global string $nasJointsAimAxisGrp[], $nasJointsUpAxisGrp[], $nasJointsUpDirectionGrp[], $nasJointsName, $nasJointsModeGrp[];
    
    if (`radioButton -q -select $nasJointsModeGrp[1]` == 1) $mode = "create";
    else if (`radioButton -q -select $nasJointsModeGrp[2]` == 1) $mode = "orient";
    $useUpObject = `checkBoxGrp -q -v1 $nasJointsModeGrp[3]`; 
    
    $name = `textField -q -text $nasJointsName`;
    $x = `radioButton -q -select $nasJointsAimAxisGrp[1]`;
    $y = `radioButton -q -select $nasJointsAimAxisGrp[2]`;
    $z = `radioButton -q -select $nasJointsAimAxisGrp[3]`;
    $aimAxisVector = <<$x, $y, $z>>;
    $aimAxis = `nas_vectorToAxis $aimAxisVector`;
    $x = `radioButton -q -select $nasJointsUpAxisGrp[1]`;
    $y = `radioButton -q -select $nasJointsUpAxisGrp[2]`;
    $z = `radioButton -q -select $nasJointsUpAxisGrp[3]`;
    $upAxisVector = <<$x, $y, $z>>;
    $upAxis = `nas_vectorToAxis $upAxisVector`;
    $x = `radioButton -q -select $nasJointsUpDirectionGrp[1]`;
    $y = `radioButton -q -select $nasJointsUpDirectionGrp[2]`;
    $z = `radioButton -q -select $nasJointsUpDirectionGrp[3]`;
    $upDirectionVector = <<$x, $y, $z>>;
    $upDirectionAxis = `nas_vectorToAxis $upDirectionVector`;
    
    if (`checkBoxGrp -q -v1 $nasJointsAimAxisGrp[4]`) $aimAxis = ("-" + $aimAxis);
    if (`checkBoxGrp -q -v1 $nasJointsUpAxisGrp[4]`) $upAxis = ("-" + $upAxis);
    if (`checkBoxGrp -q -v1 $nasJointsUpDirectionGrp[4]`) $upDirectionAxis = ("-" + $upDirectionAxis);
    
    if ($mode == "create") nas_joints $name $aimAxis $upAxis $upDirectionAxis $useUpObject;
    else if ($mode == "orient") nas_orientJoints $aimAxis $upAxis $upDirectionAxis $useUpObject;
}

//-------------------------------------------------------------nas_orientJoints---------------------------------------------------------------------
//must select a component and joints before running
global proc nas_orientJoints(string $aimAxis, string $upAxis, string $worldUpAxis, int $useUpObject) {
    string $array[], $joints[], $upObject, $aimJoints[], $parents[], $locator;
    float $wp[];
    int $childChecks[];
    vector $aimVector, $upVector, $worldUpVector;
    
    $aimVector = `nas_axisToVector $aimAxis`;
    $upVector = `nas_axisToVector $upAxis`;
    $worldUpVector = `nas_axisToVector $worldUpAxis`;
    
    $array = `ls -sl`;                            //parse the selection into variables
    $joints = `ls -sl -type joint`;
    $joints = `sort $joints`;
    $array = stringArrayRemove($joints, $array);
    if ($useUpObject) {
        $upObject = $array[0];
        if (size($upObject)) {
            if (`gmatch $upObject "*.vtx*"` || `gmatch $upObject "*.pt*"` || `gmatch $upObject "*.cv*"`) $wp = `xform -q -ws -translation $upObject`;
            else $wp = `xform -q -ws -rp $upObject`;
            $array = `spaceLocator -p 0 0 0`;
            move -ws $wp[0] $wp[1] $wp[2] $array[0];
            $upObject = $array[0];
        }
    }

    for ($i=0;$i<size($joints);$i++) {
        $array = `listRelatives -c -type joint $joints[$i]`;
        if (size($array)) {
            $aimJoints[$i] = $array[0];
            $childChecks[$i] = 1;
        } else {
            $array = `listRelatives -p -type joint $joints[$i]`;
            if (`nodeType $array[0]` == "joint") $aimJoints[$i] = $array[0];
            $childChecks[$i] = 0;
        }
    }
    
    for ($i = 0; $i < size($aimJoints); $i++) { 
        $array = `listRelatives -p $aimJoints[$i]`;
        $parents[$i] = $array[0];
        if(size($parents[$i])) parent -w $aimJoints[$i];
    }
    
    for ($i = 0; $i < size($joints); $i++) {
        if (size($aimJoints[$i])) {
            if ($childChecks[$i]) {
                if (size($upObject)) delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector ($aimVector.x) ($aimVector.y) ($aimVector.z) -upVector ($upVector.x) ($upVector.y) ($upVector.z) -worldUpType "object" -worldUpObject $upObject $aimJoints[$i] $joints[$i]`;
                else delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector ($aimVector.x) ($aimVector.y) ($aimVector.z) -upVector ($upVector.x) ($upVector.y) ($upVector.z) -worldUpType "vector" -worldUpVector ($worldUpVector.x) ($worldUpVector.y) ($worldUpVector.z) $aimJoints[$i] $joints[$i]`;
            } else {
                if (size($upObject)) delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector (-1*($aimVector.x)) (-1*($aimVector.y)) (-1*($aimVector.z)) -upVector ($upVector.x) ($upVector.y) ($upVector.z) -worldUpType "object" -worldUpObject $upObject $aimJoints[$i] $joints[$i]`;
                else delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector (-1*($aimVector.x)) (-1*($aimVector.y)) (-1*($aimVector.z)) -upVector ($upVector.x) ($upVector.y) ($upVector.z) -worldUpType "vector" -worldUpVector ($worldUpVector.x) ($worldUpVector.y) ($worldUpVector.z) $aimJoints[$i] $joints[$i]`;
            }        
        }
            setAttr($joints[$i]+".rotateAxisX") 0;
            setAttr($joints[$i]+".rotateAxisY") 0;
            setAttr($joints[$i]+".rotateAxisZ") 0;
    }
    if (size($upObject)) delete $upObject;
    for ($i = 0; $i < size($aimJoints); $i++) if (size($parents[$i])) parent $aimJoints[$i] $parents[$i];
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $joints;
    select -r $joints[0];
    print "Joints have been successfully oriented!";
}

//-------------------------------------------------------------nas_reconnectSmooths---------------------------------------------------------------------
global proc nas_reconnectSmooths() {
    string $smooths[], $array[], $meshes[], $polys[], $hiresGroups[];
    
    delete `ls -type polySmoothFace`;
    
    $hiresGroups = stringArrayCatenate(`ls -type transform "*HiRes*"`, `ls -type transform "*Hires*"`);
    for ($group in $hiresGroups) $meshes = stringArrayCatenate($meshes, `listRelatives -fullPath -ad -type mesh $group`);
    $polys = `listRelatives -fullPath -p $meshes`;
    $polys = stringArrayRemoveDuplicates($polys);
    for ($poly in $polys) {
        $array = `polySmooth  -mth 0 -dv 0 -c 1 -keepBorder 0 -keepSelectionBorder 0 -keepHardEdge 0 -keepMapBorders 0 -smoothUVs 1 -kt 1 -peh 0 -sl 1 -dpe 1 -ps 0.1 -ro 1 -ch 1 $poly`;
        $smooths[size($smooths)] = $array[0];
    }

    for ($smooth in $smooths) {
        if (`objExists "Transform.geoSmooth"`) catch(`connectAttr -f ("Transform.geoSmooth") ($smooth + ".divisions")`);
        else if (`objExists "Transform.Smooth"`) catch(`connectAttr -f ("Transform.Smooth") ($smooth + ".divisions")`);
        else for ($item in `ls "*Transform"`) catch(`connectAttr -f ($item + ".Smooth") ($smooth + ".divisions")`);
    }
    if (`objExists "Transform.Smooth"`) select -r Transform;
    print "Applied smooth and connected to Transform.Smooth!";
}

//=====================================================================================================================================
//=============================================================nas_scripting=============================================================
//=====================================================================================================================================

//-------------------------------------------------------------nas_fileLocation---------------------------------------------------------------------
//user inputs a procedure name and this script returns the file location of that procedure
global proc string nas_fileLocation(string $procName) {
    string $location, $array[];
    $location = substring(`whatIs $procName`, 25, size(`whatIs $procName`));
    $array = stringToStringArray($location, "/");
    if (size($array) == 1) $array = stringToStringArray($location, "\\"); 
    stringArrayRemoveAtIndex((size($array)-1), $array);
    $location = stringArrayToString($array, "/");
    return $location;
}

//-------------------------------------------------------------nas_axisToVector---------------------------------------------------------------------
global proc vector nas_axisToVector(string $axis) {
    vector $axisVector;
    if ($axis == "x" || $axis == "X") $axisVector = <<1, 0, 0>>;
    else if ($axis == "y" || $axis == "Y") $axisVector = <<0, 1, 0>>;
    else if ($axis == "z" || $axis == "Z") $axisVector = <<0, 0, 1>>;
    else if ($axis == "-x" || $axis == "-X") $axisVector = <<-1, 0, 0>>;
    else if ($axis == "-y" || $axis == "-Y") $axisVector = <<0, -1, 0>>;
    else if ($axis == "-z" || $axis == "-Z") $axisVector = <<0, 0, -1>>;
    return $axisVector;
}

//-------------------------------------------------------------nas_vectorToAxis---------------------------------------------------------------------
global proc string nas_vectorToAxis(vector $vector) {
    string $axis;
    if (($vector.x) >= 1 && ($vector.y) == 0 && ($vector.z) == 0) $axis = "x";
    else if (($vector.x) == 0 && ($vector.y) >= 1 && ($vector.z) == 0) $axis = "y";
    else if (($vector.x) == 0 && ($vector.y) == 0 && ($vector.z) >= 1) $axis = "z";
    else if (($vector.x) <= -1 && ($vector.y) == 0 && ($vector.z) == 0) $axis = "-x";
    else if (($vector.x) == 0 && ($vector.y) <= -1 && ($vector.z) == 0) $axis = "-y";
    else if (($vector.x) == 0 && ($vector.y) == 0 && ($vector.z) <= -1) $axis = "-z";
    else error "Value in more than one of the three vector axes.\n";
    return $axis;
}

//=====================================================================================================================================
//=============================================================nas_shading=============================================================
//=====================================================================================================================================

//-------------------------------------------------------------nas_listNetwork---------------------------------------------------------------------
//lists connections of specified node in the input or output direction
//also allows user to specify how deep the script looks for new nodes
global proc string[] nas_listNetwork(string $node, int $dir, int $iter) {
    string $nodes[], $array[], $conns[], $catches[];
    
    if ($dir > 0) $conns = `listConnections -s 0 -d 1 $node`;
    else $conns = `listConnections -s 1 -d 0 $node`;
    $conns = stringArrayRemoveDuplicates($conns);
    $nodes = $conns;
    
    for ($i = 0; $i < $iter; $i++) {
        for ($conn in $conns) {
            //print ($i + " - Working on " + $conn + "\n");
            if ($dir > 0) $array = `listConnections -s 0 -d 1 $conn`;
            else $array = `listConnections -s 1 -d 0 $conn`;
            $catches = stringArrayCatenate($catches, $array);
        }
        if (size($catches)) {
            $conns = stringArrayRemoveDuplicates($catches);
            $conns = stringArrayRemove({$node}, $conns);
            $nodes = stringArrayCatenate($nodes, $conns);
            //for ($conn in $conns) print ("Found " + $conn + " in list of connections.\n");
        } else {
            break;
        }
        clear $catches;
    }
    $nodes = stringArrayCatenate($nodes, {$node});
    $nodes = stringArrayRemoveDuplicates($nodes);
    $nodes = `sort $nodes`;
    
    return $nodes;
}

//-------------------------------------------------------------nas_matchUVAssignment---------------------------------------------------------------------
//assigns shaders to faces according to UV file
//user must input a search string and a replace string for names at beginning of faces and SGs
global proc nas_matchUVAssignment(string $origName, string $newName) {
    string $sels[], $faces[], $shadingGroup, $array[], $assignFaces[];

    //select shading groups and store faces that are assigned to them
    $sels = `ls -sl`;
    for ($sel in $sels) {
        $faces[size($faces)] = $sel;
        hyperShade -objects $sel;
        $faces = stringArrayCatenate($faces, `ls -sl`);
    }
    
    //change name of faces
    for ($i = 0; $i < size($faces); $i++) {
        $array = stringToStringArray($faces[$i], "_");
        if ($array[0] == $origName) $array[0] = $newName;
        $faces[$i] = stringArrayToString($array, "_");
    }

    //assign shaders to faces
    $shadingGroup = $faces[0];
    for ($i = 1; $i < size($faces); $i++) {
        $array = stringToStringArray($faces[$i], "_");
        if ($array[size($array)-1] == "SG") {
            select -r $assignFaces;
            sets -e -forceElement $shadingGroup;
            $shadingGroup = $faces[$i];
            clear $assignFaces;
        } else {
            $assignFaces[size($assignFaces)] = $faces[$i];
        }
    }
}

//-------------------------------------------------------------nas_importShaders---------------------------------------------------------------------
global proc nas_importShaders() {
    string $shaders[], $faces[], $shaderLoc, $array[], $sceneName, $shaderFiles[], $shadingGroup, $name, $smoothProxies[], $parts[], $matchedShaders[], $removeFolders[];
    string $types[], $allShaders[], $charName, $deletes[];

    $sceneName = `file -q -sceneName`;
    $array = stringToStringArray($sceneName, "/");
    stringArrayRemoveAtIndex(size($array)-1, $array);
    if ($array[0] == "P:") {
        $array[2] = "renderData/shaders";
    } else {
        if ($array[1] == "Fanboy") $array[3] = "renderData/shaders";
        else if ($array[1] == "KFP") $array[3] = "renderData/shaders";
    }

    $removeFolders = {"Old", "Rig", "Clean", "old", "rig", "clean", "Rigging", "WIP"};
    for ($removeFolder in $removeFolders) {
        for ($i = 0; $i < size($array); $i++) if ($array[$i] == $removeFolder) {
            stringArrayRemoveAtIndex($i, $array);
            break;
        }
    }
    $shaderLoc = stringArrayToString($array, "/");
    $shaderLoc += "/";
    $shaderFiles = `getFileList -folder $shaderLoc`;
    for ($i = 0; $i < size($shaderFiles); $i++) {
        $shaderFiles[$i] = basenameEx($shaderFiles[$i]);
    }

    $shaders = `nas_geosToShaders {"Geometry"}`;

    $shaders = nas_stringArrayIntersection($shaders, $shaderFiles);
    
    if (size($shaderFiles) < 2) {
        error ("No shaders found in " + $shaderLoc);
    } else {
        for ($shader in $shaders) {
            $shadingGroup = "";
            if (`objExists ($shader + ".outColor")`) $array = `listConnections -s on ($shader + ".outColor")`;
            else $array = `listConnections -s on ($shader + ".message")`;
            for ($item in $array) {
                if (`nodeType $item` == "shadingEngine") {
                    $shadingGroup = $item;
                    break;
                }
            } 
            hyperShade -objects $shader;
            $faces = `ls -sl`;
            $deletes = `nas_listNetwork $shader -1 20`;
            $array = `nas_listNetwork $shader 1 20`;
            for ($item in $array) if (`nodeType $item` == "shadingEngine") $deletes = stringArrayCatenate($deletes, {$item});
            delete $deletes;
            
            for ($shaderFile in $shaderFiles) {
                if ($shaderFile == $shader) {
                    file -import -type "mayaAscii" -gr -rdn -rpr $shader -options "v=0" -pr -loadReferenceDepth "all" ($shaderLoc + $shader + ".ma");
                    select -r $faces;
                    hyperShade -assign $shader;
                }
            }
        }
        for ($shader in $shaders) print ("Replaced \t" + $shader + "\t with file in shader folder.\n");
    }
}

//-------------------------------------------------------------nas_geosToShadingGroups---------------------------------------------------------------------
global proc string[] nas_geosToShadingGroups(string $geos[]) {
    string $shapes[], $proxies[], $array[], $parts[], $SGs[];
    int $found;
    
    $shapes = `listRelatives -ad -fullPath -type shape $geos`;
    for ($shape in $shapes) {
        $array = stringToStringArray($shape, "|");
        for ($item in $array) {
            $found = 0;
            $parts = stringToStringArray($item, "_");
            for ($part in $parts) {
                //$part == "SmoothProxy" || 
                if ($part == "Proxy" || $part == "GeoShapeOrig") {
                    $proxies[size($proxies)] = $shape;
                    $found = 1;
                    break;
                }
            }
            if ($found) break;
        }
    }
    
    $shapes = stringArrayRemove($proxies, $shapes);
    for ($shape in $shapes) {
        $nodes = `nas_listNetwork $shape 1 20`;
        for ($node in $nodes) {
            if (`nodeType $node` == "shadingEngine") {
                $SGs[size($SGs)] = $node;
            }
        }
    }
    
    $SGs = stringArrayRemoveDuplicates($SGs);
    return $SGs;
}

//-------------------------------------------------------------nas_shadingGroupToShaders---------------------------------------------------------------------
//returns shaders of specified shading groups
global proc string[] nas_shadingGroupToShaders(string $SGs[]) {
    string $shaders[], $array[], $nodes[];
    
    for ($SG in $SGs) {
        $nodes = stringArrayCatenate($nodes,`nas_listNetwork $SG -1 1`);
    }
    $nodes = stringArrayRemoveDuplicates($nodes);
    $nodes = nas_stringArrayIntersection($nodes, `ls -mat`);
    return $nodes;
}

//-------------------------------------------------------------nas_geosToShaders---------------------------------------------------------------------
global proc string[] nas_geosToShaders(string $geos[]) {
    string $SGs[], $shaders[];
    
    $SGs = `nas_geosToShadingGroups $geos`;
    $shaders = `nas_shadingGroupToShaders $SGs`;
    return $shaders;
}

//-------------------------------------------------------------nas_renameShadingGroupsAndInfos---------------------------------------------------------------------
global proc nas_renameShadingGroupsAndInfos() {
    string $SG, $array[], $cmd, $material, $infos[], $sels[];

    $infos = `ls -type materialInfo`;
    for ($info in $infos) {
        $array = `listConnections -s 1 ($info + ".shadingGroup")`;
        $SG = $array[0];
        $array = `listConnections -s 1 -d 0 ($info + ".material")`;
        if (size($array)) {
            $material = $array[0];
            $array = stringToStringArray($material, "_");
            if (size($array)) {
                $array[size($array)-1] = "MaterialInfo";
                $cmd = ("rename " + $info + " " + (stringArrayToString($array, "_")));
                catchQuiet(eval($cmd));
                //print ("\ntried renaming " + $info + " to " + (stringArrayToString($array, "_")));

                $array[size($array)-1] = "SG";
                if (size($SG)) {
                    $cmd = ("rename " + $SG + " " + (stringArrayToString($array, "_")));
                    catchQuiet(eval($cmd));
                }
                //print ("\ntried renaming " + $SG + " to " + (stringArrayToString($array, "_")));
            }
        }
    }
    print "Renaming done.";
}


//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//-------------------------------------------------------------nas_rigFK---------------------------------------------------------------------
global proc string[] nas_rigFK(string $name, int $auto, int $curl, string $axis, int $showLast) {
    string $joints[], $array[], $sels[], $ctrls[], $parent, $ctrlGroups[], $connectGroups[], $attrs[], 
    $nices[], $activeCtrl, $mdn, $autoGroups[], $condition, $group, $groups[], $selectCtrls[], $tConstraints[], $rConstraints[], 
    $masterLoc, $translateMDs[];
        
    if (`objExists ($name + "_FK_Ctrl_Group")`) error ("An FK rig with the name " + $name + " already exists. Please choose a unique name.");
    
//BASIC FK SYSTEM
    $sels = `ls -sl -type joint`;
    if (size($sels) != 1) error "Please select top-level joint of target FK joint chain.";
    $array = stringArrayCatenate(`listRelatives -ad -type joint $sels[0]`, {$sels[0]});
    for ($i = size($array)-1; $i >= 0; $i--) $joints[size($joints)] = $array[$i];
    
    //......................................create ctrls and ctrl groups......................................
    select -r $joints;
    $ctrls = `nas_controls surfaceCircle`;
    for ($i = 0; $i < size($ctrls); $i++) {
        $ctrls[$i] = `rename $ctrls[$i] ($name + "_FK_" + nas_framePadding("##", ($i+1)) + "_Ctrl")`;
        setAttr -type "string" ($ctrls[$i] + ".nickCtrlType") "char";
    }
    $ctrlGroups = `nas_group 0 "Group"`;
    for ($group in $ctrlGroups) setAttr ($group + ".inheritsTransform") 1;
    for ($i = 1; $i < size($joints); $i++) catchQuiet(`parent -w $joints[$i]`);
    
    //......................................constrain joints to ctrls......................................
    select -r $ctrls $joints;
    nas_massConstrain 1 "parent" 1;
    nas_massConstrain 1 "scale" 1;
    
    //......................................constrain ctrl groups to ctrls......................................
    $array = `spaceLocator -n ($name + "_FK_Master_Loc") -p 0 0 0`;
    $masterLoc = $array[0];
    delete `parentConstraint $ctrls[0] $masterLoc`;
    select -r $masterLoc (stringArrayRemove({$ctrls[size($ctrls)-1]}, $ctrls)) $ctrlGroups;
    $tConstraints = `nas_massConstrain 1 "parentTranslate" 1`;
    $rConstraints = `nas_massConstrain 1 "parentRotate" 1`;
    
    //......................................setup follow attributes......................................
    for ($i = 0; $i < size($ctrls); $i++) {
        addAttr -ln "FollowTranslates" -dv 1 -min 0 -max 1 -at double $ctrls[$i];
        setAttr -e -keyable true ($ctrls[$i] + ".FollowTranslates");
        addAttr -ln "FollowRotates" -dv 1 -min 0 -max 1 -at double $ctrls[$i];
        setAttr -e -keyable true ($ctrls[$i] + ".FollowRotates");
        
        if ($i == 0) {
            connectAttr ($ctrls[$i] + ".FollowTranslates") ($tConstraints[$i] + "." + $masterLoc + "W0");
            connectAttr ($ctrls[$i] + ".FollowRotates") ($rConstraints[$i] + "." + $masterLoc + "W0");
        } else {
            connectAttr ($ctrls[$i] + ".FollowTranslates") ($tConstraints[$i] + "." + $ctrls[$i-1] + "W0");
            connectAttr ($ctrls[$i] + ".FollowRotates") ($rConstraints[$i] + "." + $ctrls[$i-1] + "W0");
        }
    }
    if (size($ctrls) > 1 && $showLast == 0) setAttr ($ctrls[size($ctrls)-1] + ".v") 0;
    
//CONNECT
    if ($curl) {
        select -r (stringArrayRemove({$ctrls[0], $ctrls[size($ctrls)-1]}, $ctrls));
        $connectGroups = `nas_group 0 "Connect_Group"`;
        
        if (size($connectGroups) == 2) {
            $attrs = {"MidRotate", "LastRotate"};
            $nices = {"Mid Rotate", "Last Rotate"};
        } else if (size($connectGroups) == 1) {
            $attrs = {"MidRotate"};
            $nices = {"Mid Rotate"};
        } else {
            for ($i = 0; $i < size($connectGroups); $i++) {
                $attrs[size($attrs)] = ("FK" + `nas_framePadding "##" ($i+2)` + "Rotate");
                $nices[size($nices)] = ("FK " + `nas_framePadding "##" ($i+2)` + " Rotate");
            }
        }
        
        addAttr -ln "CtrlVis" -at enum -en "Off:On" -dv 0 $ctrls[0];
        setAttr -e -cb 1 -k 0 ($ctrls[0] + ".CtrlVis");
        for ($i = 0; $i < size($connectGroups); $i++) {
            addAttr -ln $attrs[$i] -nn $nices[$i] -at double $ctrls[0];
            setAttr -e -keyable true ($ctrls[0] + "." + $attrs[$i]);
            connectAttr ($ctrls[0] + "." + $attrs[$i]) ($connectGroups[$i] + ".r" + $axis);
            connectAttr ($ctrls[0] + ".CtrlVis") ($ctrls[$i+1] + ".v");
        }
    }
    
//AUTO ROTATE
    if ($auto > 1) {
        for ($i = 0; $i < size($ctrls); $i++) {
            if ($i%$auto == 0) {
                $activeCtrl = $ctrls[$i];
                addAttr -ln "AutoFK" -dv 1 -min 0 -max 1 -at double $activeCtrl;
                setAttr -e -keyable true ($activeCtrl + ".AutoFK");
                if ($i > 0) {        
                    for ($translateMD in $translateMDs) {
                        connectAttr ($ctrls[$i] + ".tx") ($translateMD + ".input1X");
                        connectAttr ($ctrls[$i] + ".ty") ($translateMD + ".input1Y");
                        connectAttr ($ctrls[$i] + ".tz") ($translateMD + ".input1Z");
                        connectAttr ($ctrls[$i] + ".AutoFK") ($translateMD + ".input2X");
                        connectAttr ($ctrls[$i] + ".AutoFK") ($translateMD + ".input2Y");
                        connectAttr ($ctrls[$i] + ".AutoFK") ($translateMD + ".input2Z");
                    }
                    
                    clear $translateMDs;
                }
            } else {
                select -r $ctrls[$i];
                $array = `nas_group 0 "Auto_Group"`;
                $group = $array[0];
                $array = stringToStringArray($ctrls[$i], "_");
                
                $array[size($array)-1] = "Auto_Translate_MD";
                $mdn = `createNode -n (stringArrayToString($array, "_")) multiplyDivide`;
                //$halfMD = `createNode -n ($name + "_FK_Auto_Half_MD") multiplyDivide`;
                connectAttr ($mdn + ".outputX") ($group + ".tx");
                connectAttr ($mdn + ".outputY") ($group + ".ty");
                connectAttr ($mdn + ".outputZ") ($group + ".tz");
                $translateMDs[size($translateMDs)] = $mdn;
                
                $array[size($array)-1] = "Auto_Rotate_MD";
                $mdn = `createNode -n (stringArrayToString($array, "_")) multiplyDivide`;
                connectAttr ($activeCtrl + ".rx") ($mdn + ".input1X");
                connectAttr ($activeCtrl + ".ry") ($mdn + ".input1Y");
                connectAttr ($activeCtrl + ".rz") ($mdn + ".input1Z");
                connectAttr ($activeCtrl + ".AutoFK") ($mdn + ".input2X");
                connectAttr ($activeCtrl + ".AutoFK") ($mdn + ".input2Y");
                connectAttr ($activeCtrl + ".AutoFK") ($mdn + ".input2Z");
                connectAttr ($mdn + ".outputX") ($group + ".rx");
                connectAttr ($mdn + ".outputY") ($group + ".ry");
                connectAttr ($mdn + ".outputZ") ($group + ".rz");
                
                $array[size($array)-1] = "Auto_Scale_Blender";
                $blender = `createNode -n (stringArrayToString($array, "_")) blendColors`;
                connectAttr ($activeCtrl + ".AutoFK") ($blender + ".blender");
                connectAttr ($activeCtrl + ".sx") ($blender + ".color1R");
                connectAttr ($activeCtrl + ".sy") ($blender + ".color1G");
                connectAttr ($activeCtrl + ".sz") ($blender + ".color1B");
                setAttr ($blender + ".color2R") 1;
                setAttr ($blender + ".color2G") 1;
                setAttr ($blender + ".color2B") 1;
                connectAttr ($blender + ".outputR") ($group + ".sx");
                connectAttr ($blender + ".outputG") ($group + ".sy");
                connectAttr ($blender + ".outputB") ($group + ".sz");
                
                $array[size($array)-1] = "Auto_Condition";
                $condition = `createNode -n (stringArrayToString($array, "_")) condition`;
                connectAttr ($activeCtrl + ".AutoFK") ($condition + ".firstTerm");
                setAttr ($condition + ".colorIfTrueR") 1;
                setAttr ($condition + ".colorIfFalseR") 0;
                connectAttr ($condition + ".outColorR") ($group + ".v");
            }
        }
    }
    
//CLEAN UP
    //......................................create main rig groups......................................
    $jointGroup = ($name + "_FK_Jnt_Group");
    if (!`objExists $jointGroup`) $jointGroup = `group -em -n $jointGroup`;
    parent $joints $jointGroup;
    $ctrlGroup = ($name + "_FK_Ctrl_Group");
    if (!`objExists $ctrlGroup`) $ctrlGroup = `group -em -n ($name + "_FK_Ctrl_Group")`;
    //delete `parentConstraint $ctrls[0] $ctrlGroup`;
    parent $ctrlGroups $ctrlGroup;
    scaleConstraint -mo $masterLoc $ctrlGroup;
    
    for ($ctrl in $ctrls) {
        if (`getAttr ($ctrl + ".v")` == 1) $selectCtrls[size($selectCtrls)] = $ctrl;
        setAttr -l 1 -cb 0 -k 0 ($ctrl + ".v");
    }
    select -r $selectCtrls;
    
    clear $array;
    $array[0] = $jointGroup;
    $array[1] = $ctrlGroup;
    $array[2] = $masterLoc;
    $array = stringArrayCatenate($array, $ctrls); 
    
    setAttr ($masterLoc + ".v") 0;
    
    print ($name + " FK System Rigged!");
    return $array;
}

global proc nas_rigFKUI() {
    global string $nas_rigFKField, $nas_rigFKRadios[], $nas_rigFKAutoSlider, $nas_rigFKAutoCheckBox, $nas_rigFKAutoShowLast;
    string $window, $form, $text, $field, $autoText1, $autoText2, $autoText, $radios[], $radioForm, $cmd, $button, $checkBox, $showLast;

    $window = `nas_window "nas_rigFK" 1 0 0`;
    $form = `formLayout`;
    $text = `text -w 60 -label "Body Part"`;
    $field = `textField`;
    $slider = `intSliderGrp -label "Ctrls Every" -extraLabel "Joints" -field true -fieldMinValue 1 -fieldMaxValue 1000 -minValue 1 -maxValue 4 -value 1 -columnAlign 1 "left" -cw4 60 21 150 40 -adj 3`;
    $button = `button -label "Create FK System" -c "nas_rigFKExecute"`;
    $checkBox = `checkBox -v 0 -label "Curl" -w 60`;
    $radioForm = `formLayout`;
        radioCollection;
            $radios[0] = `radioButton -label "X"`;
            $radios[1] = `radioButton -label "Y"`;
            $radios[2] = `radioButton -select -label "Z"`;
            setParent..;
    $cmd = "formLayout -e \n";
    for ($i = 0; $i < size($radios); $i++) {
        if ($i == 0) $cmd += ("-af " + $radios[$i] + " \"top\" 0 \n-ap " + $radios[$i] + " \"right\" 0 " + ((100/size($radios)) * ($i+1)) + " \n-af " + $radios[$i] + " \"bottom\" 0 \n-af " + $radios[$i] + " \"left\" 0 \n\n");
        else if ($i == (size($radios)-1)) $cmd+= ("-af " + $radios[$i] + " \"top\" 0 \n-af " + $radios[$i] + " \"right\" 0 \n-af " + $radios[$i] + " \"bottom\" 0 \n-ap " + $radios[$i] + " \"left\" 0 " + ((100/size($radios)) * $i) + " \n");
        else $cmd+= ("-af " + $radios[$i] + " \"top\" 0 \n-ap " + $radios[$i] + " \"right\" 0 " + ((100/size($radios)) * ($i+1)) + " \n-af " + $radios[$i] + " \"bottom\" 0 \n-ac " + $radios[$i] + " \"left\" 0 " + $radios[$i-1] + " \n\n");
    }
    $cmd += ($radioForm + ";");
    eval $cmd;
    $showLast = `checkBox -v 0 -label "Show Last Ctrl" -w 18`;

    formLayout -e 
        -af $text "top" 10
        -af $text "left" 5
        
        -af $field "top" 5
        -af $field "right" 5
        -ac $field "left" 0 $text
        
        -af $slider "left" 5
        -af $slider "right" 5
        -ac $slider "top" 5 $field
        
        -ac $checkBox "top" 5 $slider 
        -af $checkBox "left" 5

        -ac $radioForm "left" 0 $checkBox
        -ac $radioForm "top" 5 $slider 
        -af $radioForm "right" 5
        
        -ac $showLast "top" 5 $radioForm 
        -af $showLast "left" 5
        -af $showLast "right" 5
        
        -ac $button "top" 5 $showLast 
        -af $button "left" 5
        -af $button "right" 5
        -af $button "bottom" 5
    $form;
    window -e -wh 220 180 $window;
    showWindow $window;
    
    $nas_rigFKField = $field;
    $nas_rigFKRadios = {$radios[0], $radios[1], $radios[2]};
    $nas_rigFKAutoSlider = $slider;
    $nas_rigFKAutoCheckBox = $checkBox;
    $nas_rigFKAutoShowLast = $showLast;
}

global proc nas_rigFKExecute() {
    global string $nas_rigFKField, $nas_rigFKRadios[], $nas_rigFKAutoSlider, $nas_rigFKAutoCheckBox, $nas_rigFKAutoShowLast;
    string $name, $axis;
    int $auto, $curl, $showLast;
    
    $name = `textField -q -tx $nas_rigFKField`;
    if (`radioButton -q -select $nas_rigFKRadios[0]` == 1) $axis = "x";
    else if (`radioButton -q -select $nas_rigFKRadios[1]` == 1) $axis = "y";
    else if (`radioButton -q -select $nas_rigFKRadios[2]` == 1) $axis = "z";
    $auto = `intSliderGrp -q -v $nas_rigFKAutoSlider`;
    $curl = `checkBox -q -v $nas_rigFKAutoCheckBox`;
    $showLast = `checkBox -q -v $nas_rigFKAutoShowLast`;
    
    $array = `nas_rigFK $name $auto $curl $axis $showLast`;
    if ($curl) setAttr ($array[3] + ".CtrlVis") 1;
}
//global proc string[] nas_rigFK(string $name, int $auto, int $curl, string $axis, int $showLast) {
//-------------------------------------------------------------nas_massConstrain---------------------------------------------------------------------
//massively constrains selection in two different ways
//each = second half of your selection will be constrained to the first half one by one if on, otherwise all selection will be constrained to the first
//type = type of constraint
//maintain offset = maintain offset on or off
global proc string[] nas_massConstrain(int $each, string $type, int $maintainOffset) {
    string $sels[], $constrainCommand, $constraints[];
    if ($each) {
        $sels = `ls -sl -long`;
        $sels = `nas_sortMultiple 2 $sels`;
        for ($i = 0; $i < size($sels); $i+=2) {
            if ($type == "parentTranslate") {
                $constrainCommand = ("parentConstraint -skipRotate x -skipRotate y -skipRotate z ");
            } else if ($type == "parentRotate") {
                $constrainCommand = ("parentConstraint -skipTranslate x -skipTranslate y -skipTranslate z ");
            } else {
                $constrainCommand = ($type + "Constraint ");
            }
            if ($maintainOffset) $constrainCommand += "-mo ";
            $constrainCommand += ($sels[$i] + " " + $sels[$i+1]);
            $array = `eval $constrainCommand`;
            $constraints[size($constraints)] = $array[0];
        }
    } else {
        $sels = `ls -sl -long`;
        for ($i = 1; $i < size($sels); $i++) {
            if ($type == "parentTranslate") {
                $constrainCommand = ("parentConstraint -skipRotate x -skipRotate y -skipRotate z ");
            } else if ($type == "parentRotate") {
                $constrainCommand = ("parentConstraint -skipTranslate x -skipTranslate y -skipTranslate z ");
            } else {
                $constrainCommand = ($type + "Constraint ");
            }
            if ($maintainOffset) $constrainCommand += "-mo ";
            $constrainCommand += ($sels[0] + " " + $sels[$i]);
            $array = `eval $constrainCommand`;
            $constraints[size($constraints)] = $array[0];
        }
    }
    return $constraints;
}

//-------------------------------------------------------------nas_sortMultiple---------------------------------------------------------------------
//takes string array of equally sized groups and returns a list
//if original string array is {redOne, redTwo, blueOne, blueTwo}, the resulting string array will be {redOne, blueOne, redTwo, blueTwo} if a multiple of two is used
global proc string[] nas_sortMultiple(int $multiple, string $array[]) {
    string $resultString[];
    if (size($array) % $multiple) error ("input array is not a multiple of " + $multiple + "!\n");
    for ($i = 0; $i < size($array)/$multiple; $i++) {
        for ($j = 0; $j < $multiple; $j++) $resultString[size($resultString)] = $array[$i + (size($array)/$multiple) * $j];
    }
    return $resultString;
}

//-------------------------------------------------------------nas_controls---------------------------------------------------------------------
//types are curveCircle, curveSphere, 
//surfaceCircle, 
//surfaceSinglePin, surfaceDoublePin, 
//surfaceSphere, surfaceDeformerSphere, 
//surfaceNeck, surfaceFoot, 
//curveArrow
global proc string[] nas_controls(string $type) {
    string $sels[], $array[], $targetJoint, $name, $ctrls[], $components[], $shapes[], $attrs[], $axis, $tempLoc, $shapes[];
    float $transforms[], $size;
    vector $normals;

    $size = 1;
    $name = "nas_ctrl";
    $sels = `ls -sl -long`;
    if (size($sels) == 0) {
        $array = `spaceLocator -p 0 0 0`;
        $tempLoc = $array[0];
        $sels[0] = $array[0];
    }
    
    for ($i = 0; $i < size($sels); $i++) {
    //sets the normal direction
        if (`nodeType $sels[$i]` == "joint") {
            $array = `listRelatives -c -type joint $sels[$i]`;
            if ($array[0] == "") $targetJoint = $sels[$i];
            else $targetJoint = $array[0];

            if (`getAttr ($targetJoint + ".tx")` > .000001 || `getAttr ($targetJoint + ".tx")` < -.000001) {
                $normals = <<1, 0, 0>>;
                $axis = "x";
            } else if (`getAttr ($targetJoint + ".ty")` > .000001 || `getAttr ($targetJoint + ".ty")` < -.000001) {
                $normals = <<0, 1, 0>>;
                $axis = "y";
            } else if (`getAttr ($targetJoint + ".ty")` > .000001 || `getAttr ($targetJoint + ".ty")` < -.000001) {
                $normals = <<0, 0, 1>>;
                $axis = "z";
            }
        } else {
            $normals = <<1, 0, 0>>;
            $axis = "x";
        }
        
    //creates the control depending on shape name
        if ($type == "curveCircle" || $type == "surfaceCircle" || $type == "surfaceDeformerSphere" || $type == "surfaceSphere" || $type == "surfaceCone" || $type == "curveArrow" || $type == "surfaceCube" || $type == "curveLocator" || $type == "curveSquare") {
            if ($type == "curveCircle") {
                $array = `circle -c 0 0 0 -nr 0 0 0 -sw 360 -r $size -d 3 -ut 0 -tol 0.01 -s 8 -ch 1`;
            } else if ($type == "curveArrow") {
                $array[0] = `curve -d 1 -p 0 0 0 -p 0 2 0 -p 0 1.25 -0.25 -p 0 1.25 0.25 -p 0 2 0 -p 0.25 1.25 0 -p -0.25 1.25 0 -p 0 2 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7`;
            } else if ($type == "surfaceCircle") {
                $array = `torus -ch on -o on -po 0 -ax ($normals.x) ($normals.y) ($normals.z) -r $size -nsp 4 -hr 0.1`;
            } else if ($type == "surfaceDeformerSphere") {
                $array = `sphere -ch on -o on -po 0 -ax ($normals.z) ($normals.x) ($normals.y) -nsp 4 -r $size`;
                scale .125 .52 .125 $array[0];
            } else if ($type == "surfaceSphere") {
                $array = `sphere -ch on -o on -po 0 -ax ($normals.z) ($normals.x) ($normals.y) -nsp 4 -r $size`;
            } else if ($type == "surfaceCone") {
                $array = `cone -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r $size -hr 2 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 1`;
            } else if ($type == "surfaceCube") {
                $array = `nurbsCube -p 0 0 0 -ax 0 1 0 -w .5 -lr 1 -hr 1 -d 3 -u 1 -v 1 -ch 0`;
                select -r `listRelatives -ad -type "transform" $array[0]`;
                $array[1] = `rename (nas_parentShape(0)) $name`;
                parent -w $array[1];
                delete $array[0];
                $array[0] = $array[1];
            } else if ($type == "curveLocator") {
                $array[0] = `curve -d 1 -p 0 1 0 -p 0 -1 0 -p 0 0 0 -p 1 0 0 -p -1 0 0 -p 0 0 0 -p 0 0 -1 -p 0 0 1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7`;
            } else if ($type == "curveSquare") {
                $array[0] = `curve -d 1 -p -1 0 -1 -p 1 0 -1 -p 1 0 1 -p -1 0 1 -p -1 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4`;
            }
            $ctrls[$i] = $array[0];
        } else {
            clear $components;
            if ($type == "curveSphere") {
                $array = `circle -c 0 0 0 -nr 1 0 0 -sw 360 -r $size -d 3 -ut 0 -tol 0.01 -s 8 -ch 1`;
                $components[size($components)] = $array[0];
                $array = stringArrayCatenate(`circle -c 0 0 0 -nr 0 1 0 -sw 360 -r $size -d 3 -ut 0 -tol 0.01 -s 8 -ch 1`, $array);
                $components[size($components)] = $array[0];
                $array = stringArrayCatenate(`circle -c 0 0 0 -nr 0 0 1 -sw 360 -r $size -d 3 -ut 0 -tol 0.01 -s 8 -ch 1`, $array);
                $components[size($components)] = $array[0];
            } else if ($type == "surfaceNeck") {
                $transforms = {1.553538, 0.9328746231, -1.838666117, 11.98653889, 0, 15.53525711, 1, 4.257336107, 1, 0, 3.330669074e-016, 2.04294058, 0, 0, 90, 1, 7.797269013, 1, -1.812865, 3.330669074e-016, -4.440892099e-017, 90, 0, 90, 1, 8.786839377, 1, 0, 3.330669074e-016, -2.04294058, 0, 0, 90, 1, 7.797269013, 1, 1.812865, -5.551115123e-016, -4.440892099e-017, 90, 0, 90, 1, 8.786839377, 1, 0, 1.865749246, 1.057395701, 0, 0, 90, 1, 5.566507295, 1, -1.29421, 1.865749246, -0.2885142007, 90, 0, 90, 1, 5.783148657, 1, 0, 1.865749246, -1.634391654, 0, 0, 90, 1, 5.566507295, 1, 1.294211, 1.865749246, -0.2885142007, 90, 0, 90, 1, 5.783148657, 1, 1.553538, 0.9328746231, 1.55016814, -27.03374212, 7.951386704e-016, 15.53525711, 1, 4.675333932, 1, -1.553537688, 0.9328746231, 1.55016814, -152.9662579, -3.975693352e-016, 164.4647429, 1, 4.675333932, -1, -1.553537688, 0.9328746231, -1.838666117, 168.0134611, 1.987846676e-016, 164.4647429, 1, 4.257336107, -1}; 
                for ($j = 0; $j < size($transforms); $j+=9) {
                    $array = `cylinder -ch on -o on -po 0 -ax 0 1 0 -r .0465 -s 4 -nsp 1 -hr 10`;
                    move -r $transforms[$j] $transforms[$j+1] $transforms[$j+2] $array[0];
                    rotate -r $transforms[$j+3] $transforms[$j+4] $transforms[$j+5] $array[0];
                    scale -r $transforms[$j+6] $transforms[$j+7] $transforms[$j+8] $array[0];
                    $components[size($components)] = $array[0];
                }
            } else if ($type == "surfaceDoublePin") {
                $transforms = {-1.776356839e-015, 1.776356839e-015, -1.786130198, 0, 1.776356839e-015, 1.786199138};
                for ($j = 0; $j < size($transforms); $j+=3) {
                    $array = `torus -ch on -o on -po 0 -ax 1 0 0 -r .224 -nsp 4 -hr 0.05`;
                    move -r $transforms[$j] $transforms[$j+1] $transforms[$j+2] $array[0];
                    $components[size($components)] = $array[0];
                }
                $array = `cylinder -ch on -o on -po 0 -ax 0 0 1 -r .022 -s 4 -nsp 8 -hr 142.5`;
                scale -r -p 0cm 0cm 0cm 0.152778 0.152778 1 ($array[0] + ".cv[0][0:3]") ($array[0] + ".cv[10][0:3]");
                $components = stringArrayCatenate({$array[0]}, $components);
            } else if ($type == "surfaceSinglePin") {
                $array = `cylinder -p 0 ($size*0.0945) 0 -ch on -o on -po 0 -ax 0 1 0 -r ($size*.007) -s 8 -nsp 2 -hr 27`;
                scale -r -p 0 ($size*0.189) 0cm .3 .3 .3 ($array[0] + ".cv[4][0:7]");
                $components[0] = $array[0];
                $array = `torus -ch on -o on -po 0 -ax 1 0 0 -r ($size*.07) -nsp 4 -hr 0.05`;
                move -r 0 ($size*0.257631) 0 $array[0];
                $components[1] = $array[0];
            } else if ($type == "surfaceFoot") {
                $array = `torus -ch on -o on -po 0 -ax 0 1 0 -r 1.016404 -nsp 4 -hr 0.01`;
                move -r 0 0 0.423357 $array[0];
                move -r -os -wd 0 0 0.212952 ($array[0] + ".cv[0:3][3]");
                move -r -os -wd 0 0 0.151644 ($array[0] + ".cv[0:3][2]") ($array[0] + ".cv[0:3][4]");
                scale -r -p 0cm 0cm 1.371165cm 1.035431 1 1 ($array[0] + ".cv[0:3][2]") ($array[0] + ".cv[0:3][4]");
                scale -r -p 0cm 0cm 0.423056cm 1.036656 1 1 ($array[0] + ".cv[0:3][1]") ($array[0] + ".cv[0:3][5]");
                move -r -os -wd 0 0.237053 -0.150387 ($array[0] + ".cv[0:3][0]") ($array[0] + ".cv[0:3][6]");
                scale -r -p 0cm 0cm -0.523797cm 0.809651 1 1 ($array[0] + ".cv[0:3][0]") ($array[0] + ".cv[0:3][6]");
                move -r -os -wd 0 0.0398975 -0.213677 ($array[0] + ".cv[0:3][7]");
                $ctrls[$i] = $array[0];
            } else if ($type == "curveBend") {
                string $array[], $circle, $arrow, $ctrl;
                $array = `circle -c 0 0 0 -nr 0 1 0 -sw 360 -r .63 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1`;
                $components = stringArrayCatenate({$array[0]}, $components);
                $array[0] = `curve -d 2 -p 0.667749 0.678911 0 -p 0.667749 0.678911 0 -p 0.485761 0.860899 0 -p 0.485761 0.860899 0 -p 1.225505 1.026089 0 -p 1.225505 1.026089 0 -p 1.060315 0.286345 0 -p 1.060315 0.286345 0 -p 0.878328 0.468333 0 -p 0.878328 0.468333 0 -p 0.625661 0.210569 0 -p 0.63439 -0.219298 0 -p 0.878328 -0.468333 0 -p 0.878328 -0.468333 0 -p 1.060315 -0.286345 0 -p 1.060315 -0.286345 0 -p 1.225505 -1.026089 0 -p 1.225505 -1.026089 0 -p 0.485761 -0.860899 0 -p 0.485761 -0.860899 0 -p 0.667749 -0.678911 0 -p 0.667749 -0.678911 0 -p 0.339854 -0.310006 0 -p 0.342763 0.315825 0 -p 0.667749 0.678911 0 -p 0.667749 0.678911 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 24`;
                $components = stringArrayCatenate({$array[0]}, $components);
            }
            
            if (size($components)) {
                select -r $components;
                $ctrls[$i] = `nas_parentShape 0`;
            }
            move 0 0 0 ($ctrls[$i] + ".scalePivot") ($ctrls[$i] + ".rotatePivot") ;
            makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $ctrls[$i];
            delete -ch $ctrls[$i];
        }
        
    //color controls
        select -r $ctrls[$i];
        if ($type == "surfaceCircle" || $type == "surfaceNeck" || $type == "surfaceClav") {
            nas_shadeControls "blue";
            nas_colorControls "blue" 1;
        } else if ($type == "surfaceDeformerSphere" || $type == "surfaceSphere") {
            nas_shadeControls "yellow";
            nas_colorControls "yellow" 1;
        } else if ($type == "surfaceFoot") {
            nas_shadeControls "red";
            nas_colorControls "red" 1;
        } else if ($type == "surfaceSinglePin") {
            nas_shadeControls "green";
            nas_colorControls "green" 1;
        } else if ($type == "curveBend" || $type == "curveSquare" || $type == "curveCircle") {
            nas_colorControls "light blue" 1;
        } else if ($type == "curveLocator") {
            nas_colorControls "yellow" 1;
        }
        
    //replaces "bind" in name to FK and either replaces the last portion or adds "_Ctrl" to name    
        $array = stringToStringArray($sels[$i], "|");
        $array = stringToStringArray($array[size($array)-1], "_");
        if (size($array) > 1) {
            for ($j = 0; $j < size($array); $j++) if ($array[$j] == "Bind") $array[$j] = "FK";
            stringArrayRemoveAtIndex((size($array)-1), $array);
        }
        $name = ((stringArrayToString($array, "_")) + "_Ctrl");
        $ctrls[$i] = `rename $ctrls[$i] $name`;
        $shapes = `listRelatives -fullPath -s $ctrls[$i]`;
        if (size($shapes) == 1) {
            rename $shapes[0] ($name + "Shape");
        } else {
            for ($j = 0; $j < size($shapes); $j++) {
                rename $shapes[$j] ($name + "Shape" + ($j+1));
            }
        }            

    //makes controls non-renderable
        $shapes = `listRelatives -s -fullPath $ctrls[$i]`;
        $attrs = {"castsShadows", "receiveShadows", "motionBlur", "primaryVisibility", "smoothShading", "visibleInReflections", "visibleInRefractions", 
            "miTransparencyCast", "miTransparencyReceive", "miReflectionReceive", "miRefractionReceive", "miFinalGatherCast", "miFinalGatherReceive"}; 
        for ($shape in $shapes) for ($attr in $attrs) if (`objExists ($shape + "." + $attr)`) setAttr ($shape + "." + $attr) 0;
        
    //match location of ctrls to joints
        select -r $sels[$i] $ctrls[$i]; nas_matchTransforms 1 1 1 1 1 1 0 0 0;
    }
    
    for ($i = 0; $i < size($ctrls); $i++) {
        setAttr ($ctrls[$i] + ".rotateOrder") `getAttr ($sels[$i] + ".rotateOrder")`;
        addAttr -ln "nickCtrlType" -dt "string" $ctrls[$i];
        setAttr -e -k 1 ($ctrls[$i] + ".nickCtrlType");
        if (`objExists ($ctrls[$i] + ".miDeriveFromMaya")`) setAttr ($ctrls[$i] + ".miDeriveFromMaya") 0;
        if (`objExists ($ctrls[$i] + ".miCaustic")`) setAttr ($ctrls[$i] + ".miCaustic") 0;
        if (`objExists ($ctrls[$i] + ".miGlobillum")`) setAttr ($ctrls[$i] + ".miGlobillum") 0;
    }
    //for ($ctrl in $ctrls) setAttr -l 1 -cb 0 -k 0 ($ctrl + ".v");
    
    if (`objExists $tempLoc`) delete $tempLoc;
    select -r $ctrls;
    return $ctrls;
}

//-------------------------------------------------------------nas_setCtrlsToNonRenderable---------------------------------------------------------------------
global proc nas_setCtrlsToNonRenderable() {
    string $ctrls[] = `ls -long -type transform "*_Ctrl"`;
    $ctrls[size($ctrls)] = "COG";
    $ctrls[size($ctrls)] = "Transform";
    for ($i = 0; $i < size($ctrls); $i++) {
        if (`objExists ($ctrls[$i] + ".miDeriveFromMaya")`) setAttr ($ctrls[$i] + ".miDeriveFromMaya") 0;
        if (`objExists ($ctrls[$i] + ".miCaustic")`) setAttr ($ctrls[$i] + ".miCaustic") 0;
        if (`objExists ($ctrls[$i] + ".miGlobillum")`) setAttr ($ctrls[$i] + ".miGlobillum") 0;
        $shapes = `listRelatives -s -fullPath $ctrls[$i]`;
        $attrs = {"castsShadows", "receiveShadows", "motionBlur", "primaryVisibility", "smoothShading", "visibleInReflections", "visibleInRefractions", 
            "miTransparencyCast", "miTransparencyReceive", "miReflectionReceive", "miRefractionReceive", "miFinalGatherCast", "miFinalGatherReceive"}; 
        for ($shape in $shapes) for ($attr in $attrs) if (`objExists ($shape + "." + $attr)`) setAttr ($shape + "." + $attr) 0;
    }
    select -r $ctrls;
    print "All controls set to non-renderable in maya software and mental ray. *thumbs up*";
}
        
//-------------------------------------------------------------nas_parentShape---------------------------------------------------------------------
//A modification of Frank Grecco's script that allows the user to parent shapes to another object.
//Select children first and the parent last.
global proc string nas_parentShape(int $replace){
    string $sels[], $shapes[], $parent, $array[], $attrs[];
    
    $sels = `ls -sl -long`;
    $parent = $sels[(size($sels) - 1)];
    $attrs = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"};
    
    if ($replace) delete `listRelatives -s -fullPath $parent`;
    stringArrayRemoveAtIndex((size($sels)-1), $sels);
    for ($i = 0; $i < size($sels); $i++) {
        parent $sels[$i] $parent;
        $array = stringToStringArray($sels[$i], "|");
        $sels[$i] = ($parent + "|" + $array[size($array)-1]);
        for ($attr in $attrs) setAttr -l 0 -cb 1 -k 1 ($sels[$i] + "." + $attr);
        makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $sels[$i];
    }
    $shapes = `listRelatives -s -fullPath $sels`;
    for ($i = 0; $i < size($shapes); $i++) parent -r -s $shapes[$i] $parent;
    delete $sels;
    select -r $parent;
    return $parent;
}

//-------------------------------------------------------------nas_massParentShape---------------------------------------------------------------------
global proc string[] nas_massParentShape(int $replace) {
    string $sels[], $newCtrls[];
    $sels = `ls -sl -long`;
    $sels = `nas_sortMultiple 2 $sels`;
    for ($i = 0; $i < size($sels); $i+=2) {
        select -r $sels[$i] $sels[$i+1];
        $newCtrls[size($newCtrls)] = `nas_parentShape $replace`;
    }
    select -r $newCtrls;
    return $newCtrls;
}

//-------------------------------------------------------------nas_colorToIndex---------------------------------------------------------------------
global proc int nas_colorToIndex (string $color) {
    int $colorIndex;
    string $colors[] = {
    "default blue", "5", 
    "black", "1", 
    "dark red", "4", 
    "blue", "6", 
    "dark green", "7", 
    "pink", "9", 
    "brown", "10", 
    "dark brown", "11", 
    "red", "13", 
    "green", "14", 
    "dark blue", "15", 
    "white", "16", 
    "yellow", "17", 
    "cyan", "18", 
    "light yellow", "22", 
    "light green", "23", 
    "purple", "30", 
    "gray", "3",
        "magenta", "9"};
    
    for($i = 0; $i < size($colors); $i++) if ($color == $colors[$i]) $colorIndex = $colors[$i+1];
    return $colorIndex;
}

//-------------------------------------------------------------nas_colorControls---------------------------------------------------------------------
global proc nas_colorControls (string $color, int $colorShape) {
    string $sels[], $shapes[], $defaultLayer;
    int $colorIndex;
    
    $colorIndex = `nas_colorToIndex $color`;
    $sels = `ls -sl -long`;
    $shapes = `listRelatives -fullPath -shapes $sels`;
    
    if ($colorShape) {
        for ($shape in $shapes) {
            $defaultLayer = `connectionInfo -sfd ($shape + ".drawOverride")`;
            if ($defaultLayer != "") catchQuiet (`disconnectAttr $defaultLayer ($shape + ".drawOverride")`);
            setAttr -lock off ($shape + ".overrideEnabled");
            setAttr ($shape + ".overrideEnabled") 1;
            setAttr ($shape + ".overrideColor") $colorIndex;
        }
    } else {
        for ($shape in $shapes) setAttr -lock off ($shape + ".overrideEnabled") 0;
        for ($sel in $sels) {
            setAttr ($sel + ".overrideEnabled") 1;
            setAttr ($sel + ".overrideColor") $colorIndex;
        }
    }
}

global proc nas_colorControlsUI() {
    global int $nasGeneralist;
    string $window, $optionMenu, $form, $button, $text, $shadeButton, $checkBox;
    $window = `nas_window nas_colorControls 1 0 0`;
    $form = `formLayout nasColorControlsFormLayout`;
        $checkBox = `checkBox -label "Color Shape" -value 1`;
        $text = `text -h 24 -label "Color:" nasColorControlsUIText`;
        $optionMenu = `optionMenu nasColorControlsUIOptionMenu`;
            menuItem -label "blue";
            menuItem -label "cyan";
            menuItem -label "red";
            menuItem -label "magenta";
            menuItem -label "yellow";
            menuItem -label "default blue";
            menuItem -label "green";
            menuItem -label "brown";
            menuItem -label "black";
            menuItem -label "pink";
            menuItem -label "white";
            menuItem -label "purple";
            menuItem -label "light green";
            menuItem -label "light yellow";
            menuItem -label "dark blue";
            menuItem -label "dark red";
            menuItem -label "dark green";
            menuItem -label "dark brown";
        $button = `button -label "Color Wireframe" -c ("nas_colorControls `optionMenu -q -v " + $optionMenu + "` `checkBox -q -value " + $checkBox + "`;")`;
        $shadeButton = `button -label "Shade Faces" -c ("nas_shadeControls `optionMenu -q -v " + $optionMenu + "`;")`;
        setParent..;
    formLayout -e 
        -af $checkBox "top" 5
        -af $checkBox "left" 5
        -af $checkBox "right" 5
        
        -ac $text "top" 5 $checkBox
        -af $text "left" 5
    
        -ac $optionMenu "top" 5 $checkBox
        -af $optionMenu "right" 5
        -ac $optionMenu "left" 0 $text
        
        -ac $button "top" 5 $optionMenu
        -af $button "right" 5
        -af $button "left" 5
        
        -ac $shadeButton "top" 5 $button
        -af $shadeButton "right" 5
        -af $shadeButton "bottom" 5
        -af $shadeButton "left" 5
        
        $form;
        
    if ($nasGeneralist) checkBox -e -value 0 $checkBox;
    window -e -wh 133 144 $window;
    showWindow $window;
}

//-------------------------------------------------------------nas_shadeControls---------------------------------------------------------------------
global proc nas_shadeControls(string $color) {
    string $ctrls[], $shader, $array[], $conns[], $SGs[];
    float $RGBs[];
    $ctrls = `ls -sl -long`;
    for ($ctrl in $ctrls) {
        $shader = "";
        switch ($color) {
            case "blue":
                $shader = "Control_Blue_Shader";
                $RGBs = {0.0, 0.0, 1.0};
                break;
            case "yellow":
                $shader = "Control_Yellow_Shader";
                $RGBs = {1.0, 1.0, 0.0};
                break;
            case "green":
                $shader = "Control_Green_Shader";
                $RGBs = {0.0, 1.0, 0.0};
                break;
            case "red":
                $shader = "Control_Red_Shader";
                $RGBs = {1.0, 0.0, 0.0};
                break;
            case "purple":
                $shader = "Control_Purple_Shader";
                $RGBs = {0.5, 0.0, 1.0};
                break;
            case "gray":
                $shader = "Control_Gray_Shader";
                $RGBs = {1.0, 0.0, 0.0};
                break;
                        case "cyan":
                $shader = "Control_Cyan_Shader";
                $RGBs = {0.0, 1.0, 1.0};
                break;
                        case "magenta":
                $shader = "Control_Magenta_Shader";
                $RGBs = {1.0, 0.0, 1.0};
                break;
                        case "pink":
                $shader = "Control_Pink_Shader";
                $RGBs = {1.0, 0.0, 1.0};
                break;
        }
        if ($shader == "") error ($color + " is not available in the control shader library");
        if (!`objExists $shader`) {
            $shader = `shadingNode -n $shader -asShader lambert`;
            setAttr ($shader + ".color") $RGBs[0] $RGBs[1] $RGBs[2];
            setAttr ($shader + ".incandescence") $RGBs[0] $RGBs[1] $RGBs[2];
            setAttr ($shader + ".transparency") 0.5 0.5 0.5;
        }
        
        $conns = `connectionInfo -dfs ($shader + ".outColor")`;
        for ($conn in $conns) {
            $array = stringToStringArray($conn, ".");
            if (`nodeType $array[0]` == "shadingEngine") $SGs[size($SGs)] = $array[0];
        }
        if (size($SGs) == 0) {
            $array = stringToStringArray($shader, "_");
            $array[size($array)-1] = "SG";
            $SGs[0] = `sets -renderable true -noSurfaceShader true -empty -name (stringArrayToString($array, "_"))`;
            connectAttr -f ($shader + ".outColor") ($SGs[0] + ".surfaceShader");
        }
        sets -e -forceElement $SGs[0] $ctrl;
        
        select -r $ctrl;
        hyperShade -assign $shader;
    }
    select -r $ctrls;
}

//-------------------------------------------------------------nas_matchTransforms---------------------------------------------------------------------
//matches transforms of two objects by creating a copy and transferring values
global proc float[] nas_matchTransforms(int $matchtx, int $matchty, int $matchtz, int $matchrx, int $matchry, int $matchrz, int $matchsx, int $matchsy, int $matchsz) {
    string $sels[], $attributes[], $attrs[], $copy;
    int $inputs[];
    float $values[];

    $sels = `ls -sl -long`;    

    $inputs = {$matchtx, $matchty, $matchtz, $matchrx, $matchry, $matchrz, $matchsx, $matchsy, $matchsz};
    $attributes = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"};
    for ($i = 0; $i < size($inputs); $i++) if ($inputs[$i]) $attrs[size($attrs)] = $attributes[$i];    

    for ($i = 1; $i < size($sels); $i++) {
        select -r $sels[$i];
        $copy = `nas_createNullCopy ($sels[$i] + "_copy")`;
        delete `pointConstraint -offset 0 0 0 -weight 1 $sels[0] $copy`;
        delete `orientConstraint -offset 0 0 0 -weight 1 $sels[0] $copy`;
        delete `scaleConstraint -offset 0 0 0 -weight 1 $sels[0] $copy`;
        select -r $copy $sels[$i];
        $values = `nas_copyAttrs $attrs`;
        delete $copy;
    }
    select -r $sels;
    return $values;
}

//-------------------------------------------------------------nas_createNullCopy---------------------------------------------------------------------
global proc string nas_createNullCopy (string $name) {
    string $sels[], $object, $attrs[], $array[], $parent, $group;
    int $rotateOrder;
    float $values[];
    
    $sels = `ls -sl -long`;
    $object = $sels[0];
    $attrs = `listAttr -k $object`;
    for ($attr in $attrs) $values[size($values)] = `getAttr ($object + "." + $attr)`;
    select -r $object;
    setAttr ($object + ".translate") 0 0 0;
    setAttr ($object + ".rotate") 0 0 0;
    setAttr ($object + ".scale") 1 1 1;
    
    $array = `listRelatives -fullPath -p $object`; $parent = $array[0];
    $rotateOrder = `getAttr ($object + ".rotateOrder")`;
    $group = `group -n $name -em`;
    setAttr ($group + ".rotateOrder") $rotateOrder;
    delete `pointConstraint $object $group`;
    delete `orientConstraint $object $group`;
    delete `scaleConstraint $object $group`;
    if ($parent != "") parent $group $parent;
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $group;
    for ($i = 0; $i < size($attrs); $i++) setAttr ($object + "." + $attrs[$i]) $values[$i];
    for ($i = 0; $i < size($attrs); $i++) if (`objExists ($group + "." + $attrs[$i])`) setAttr ($group + "." + $attrs[$i]) $values[$i];
    return $group;
}

//-------------------------------------------------------------nas_copyAttrs---------------------------------------------------------------------
//copies attrs from first selection and applies them to the rest
global proc float[] nas_copyAttrs(string $attributes[]) {
    string $sels[], $sourceAttrs[], $targetAttrs[], $attrs[], $array[];
    float $values[];
    
    $sels = `ls -sl -long`;
    if (!size($attributes)) $attributes = `nas_getCBSelection`;
    if (!size($attributes)) $attributes = `listAttr -k $sels[0]`;
    for ($attribute in $attributes) if (`getAttr -k ($sels[0] + "." + $attribute)`) {
        $sourceAttrs[size($sourceAttrs)] = $attribute;
        $values[size($values)] = `getAttr ($sels[0] + "." + $attribute)`;
    }
    
    for ($i = 1; $i < size($sels); $i++) {
        $targetAttrs = `listAttr -k $sels[$i]`;
        $array = `listAttr -k -sn $sels[$i]`;
        $targetAttrs = stringArrayCatenate($targetAttrs, $array);
        $attrs = `nas_stringArrayIntersection $sourceAttrs $targetAttrs`;
        for ($attr in $attrs) setAttr ($sels[$i] + "." + $attr) `getAttr ($sels[0] + "." + $attr)`;
    }
    return $values;
}

//-------------------------------------------------------------nas_stringArrayIntersection---------------------------------------------------------------------
//returns a string array of common members of two arrays
global proc string[] nas_stringArrayIntersection(string $firstArray[], string $secondArray[]) {
     string $intersector, $resultArray[];
    $intersector = `stringArrayIntersector`;
     stringArrayIntersector -edit -intersect $firstArray $intersector;
     stringArrayIntersector -edit -intersect $secondArray $intersector;
    $resultArray = `stringArrayIntersector -query $intersector`;
     deleteUI $intersector;
    return $resultArray;
}

//-------------------------------------------------------------nas_getCBSelection---------------------------------------------------------------------
//returns a list of attrs that are selected in the channel box
/*
global proc string[] nas_getCBSelection() {
    string $attrs[], $flags[], $channelBoxes[], $finalAttrs[];
    global string $gChannelBoxName, $nasChannelBox;
    $flags = {"-selectedMainAttributes", "-selectedShapeAttributes", "-selectedHistoryAttributes", "-selectedOutputAttributes"};
    $channelBoxes = {$gChannelBoxName, $nasChannelBox};
    for ($channelBox in $channelBoxes) {
        if (`channelBox -q -exists $channelBox`) {
            for ($flag in $flags) {
                $attrs = stringArrayCatenate($attrs, (eval("channelBox -q " + $flag + " " + $channelBox)));
            }
        }
    }
    for ($attr in $attrs) {
        if ($attr == "translate" || $attr == "t") $finalAttrs = stringArrayCatenate($finalAttrs, {"tx", "ty", "tz"});
        else if ($attr == "rotate" || $attr == "r") $finalAttrs = stringArrayCatenate($finalAttrs, {"rx", "ry", "rz"});
        else if ($attr == "scale" || $attr == "s") $finalAttrs = stringArrayCatenate($finalAttrs, {"sx", "sy", "sz"});
        else $finalAttrs = stringArrayCatenate($finalAttrs, {$attr});
    }        
    $finalAttrs = stringArrayRemoveDuplicates($finalAttrs);
     return $finalAttrs;
}
*/

global proc string[] nas_getCBSelection() {
    string $channelBox, $selectedAttrs[], $attrs[], $flags[], $channelBoxes[], $finalAttrs[];
    global string $gChannelBoxName, $nasChannelBox;
    $channelBox = $nasChannelBox;
    if (`channelBox -q -exists $channelBox` == 0) {
        return $finalAttrs;
    }
    $selectedAttrs  = `channelBox -q -selectedMainAttributes $channelBox`;
    $attrs = stringArrayCatenate($attrs, $selectedAttrs);
    $selectedAttrs  = `channelBox -q -selectedShapeAttributes $channelBox`;
    $attrs = stringArrayCatenate($attrs, $selectedAttrs);
    $selectedAttrs  = `channelBox -q -selectedHistoryAttributes $channelBox`;
    $attrs = stringArrayCatenate($attrs, $selectedAttrs);
    $selectedAttrs  = `channelBox -q -selectedOutputAttributes $channelBox`;
    $attrs = stringArrayCatenate($attrs, $selectedAttrs);
    $finalAttrs = $attrs;
    $finalAttrs = stringArrayRemoveDuplicates($finalAttrs);
    print("\nChannelBox Attrs:");
    for ($finalAttr in $finalAttrs) {
        print("\n");
        print($finalAttr);
    }
    return $finalAttrs;
}

//-------------------------------------------------------------nas_framePadding---------------------------------------------------------------------
//returns a name including the number with frame padding
//i.e. $name should be something like dude###man. If the number is 1 the proc should return dude001man
//# signs should only occur once in given name
global proc string nas_framePadding(string $name, int $number) {
    string $zeroes, $padding, $parts[];
    int $numDigits;

    $padding = `match "#+" $name`;
    $numDigits = size($padding);
    $parts = stringToStringArray($name, "#");
    if (!$numDigits) error "Name must contain # sign.\n";
    if (size($parts) > 2) error "# signs must appear only once in name.\n";
    for ($i = 1; $i < $numDigits; $i++) if ($number < `pow 10 $i`) $zeroes += 0;
    return ($parts[0] + ($zeroes + $number) + $parts[1]);
}


//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//========================================================================================================================
//-------------------------------------------------------------nas_distance---------------------------------------------------------------------
//returns the distance between all specified way points
global proc float nas_distance(string $wayPoints[]) {
    string $obj1, $obj2;
    float $dist, $a, $b, $c, $xform1[], $xform2[];    

    for ($i = 0; $i < (size($wayPoints)-1); $i++) {
        $obj1 = $wayPoints[$i];
        $obj2 = $wayPoints[$i+1];
        if (`nodeType $obj1` == "mesh" || `nodeType $obj1` == "lattice") $xform1 = `xform -ws -q -translation $obj1`;
        else $xform1 = `xform -ws -q -rp $obj1`;
        if (`nodeType $obj2` == "mesh" || `nodeType $obj2` == "lattice") $xform2 = `xform -ws -q -translation $obj2`;
        else $xform2 = `xform -ws -q -rp $obj2`;
        
        $a = `pow ($xform2[0] - $xform1[0]) 2`;
        $b = `pow ($xform2[1] - $xform1[1]) 2`;
        $c = `pow ($xform2[2] - $xform1[2]) 2`;
        
        $dist += `sqrt ($a + $b + $c)`;
    }
    return $dist;
}

//-------------------------------------------------------------nas_matchWorld---------------------------------------------------------------------
//rotates the object to match world axes while keeping its orientation
global proc nas_matchWorld() {
    string $object, $loc, $compareLoc, $array[], $axes[], $aimAxis, $upAxis;
    float $dist, $xform, $vals[], $aimVals[], $upVals[];
    
    $objects = `ls -sl`;
    $axes = {"x", "y", "z", "-x", "-y", "-z"};
    
    for ($object in $objects) {
        $array = `spaceLocator -p 0 0 0`;
        $compareLoc = $array[0];
        delete `pointConstraint $object $compareLoc`;
        move -r -wd 0 1 0 $compareLoc;
        
        $dist = 1000000.0;
        for ($axis in $axes) {
            $vals = `nas_axisToVector $axis`;
            $array = `spaceLocator -p 0 0 0`;
            $loc = $array[0];
        
            delete `parentConstraint $object $loc`;
            move -r -os -wd $vals[0] $vals[1] $vals[2] $loc;
        
            if (`nas_distance {$loc, $compareLoc}` < $dist) {
                $upAxis = $axis;
                $dist = `nas_distance {$loc, $compareLoc}`;
            }
            delete $loc;
        }
        
        move -r -wd 1 -1 0 $compareLoc;
        
        $dist = 1000000.0;
        for ($axis in $axes) {
            $vals = `nas_axisToVector $axis`;
            $array = `spaceLocator -p 0 0 0`;
            $loc = $array[0];
        
            delete `parentConstraint $object $loc`;
            move -r -os -wd $vals[0] $vals[1] $vals[2] $loc;
        
            if (`nas_distance {$loc, $compareLoc}` < $dist) {
                $aimAxis = $axis;
                $dist = `nas_distance {$loc, $compareLoc}`;
            }
            delete $loc;
        }
        
        $aimVals = `nas_axisToVector $aimAxis`;
        $upVals = `nas_axisToVector $upAxis`;
        
        delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector $aimVals[0] $aimVals[1] $aimVals[2] -upVector $upVals[0] $upVals[1] $upVals[2] -worldUpType "scene" $compareLoc $object`;
        delete $compareLoc;
    }
    select $objects;
}

//-------------------------------------------------------------nas_matchPivots---------------------------------------------------------------------
//matches pivots of all selections to the first selection
global proc nas_matchPivots() {
    string $sels[], $obj1;
    float $pivots[];
    
    $sels = `ls -sl`;
    $obj1 = $sels[0];
    $rotatePivots = `xform -q -ws -rp $obj1`;
    $scalePivots = `xform -q -ws -sp $obj1`;
    for ($i = 1; $i < size($sels); $i++) {
        xform -ws -rp $rotatePivots[0] $rotatePivots[1] $rotatePivots[2] $sels[$i];
        xform -ws -sp $scalePivots[0] $scalePivots[1] $scalePivots[2] $sels[$i];
    }
}

//-------------------------------------------------------------nas_showAttrs---------------------------------------------------------------------
//locks and hides default attrs
global proc nas_showAttrs (int $tx, int $ty, int $tz, int $rx, int $ry, int $rz, int $sx, int $sy, int $sz, int $v) { 
    string $sels[], $attrs[];
    int $toggles[] = {$tx, $ty, $tz, $rx, $ry, $rz, $sx, $sy, $sz, $v};
    $attrs = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"};
    $sels = `ls -sl`;
    for ($sel in $sels) {
        for ($i = 0; $i < size($toggles); $i++) {
            if ($toggles[$i]) setAttr -lock false -keyable true ($sel + "." + $attrs[$i]);
            else setAttr -lock true -keyable false ($sel + "." + $attrs[$i]);
        }
    }
}

//-------------------------------------------------------------nas_rigIK---------------------------------------------------------------------
global proc string[] nas_rigIK(string $name, string $dir, int $world) {    
    string $array[], $joints[], $startJnt, $endJnt, $midJoints[], $midLoc, $poleLoc, $poleLocs[],
        $loc, $grp, $constraint, $handle, $ikClav, $poleVector, $ikCtrl, $compareLoc, 
    $distanceNode, $stretchMD, $scaleMD, $mdn, $mdns[], $clamp, $blend, $aimAxis, $ikClavGroup, 
    $ctrlGroup, $deformerGroup, $jointsGroup, $ikNull, $maxClamp;
    float $dist, $dists[], $totalDist, $distance, $diffs[], $test, $vals[],
        $aimVals[], $otherVals[], $lowestDist, $value;
    vector $poleVec, $dirVec, $rotateVec, $prefVec, $poleVecs[];

    //......................................get joints......................................
    $array = `ls -sl -type joint`;
    if (size($array) !=1) error "Please select the first joint in IK system";
    clear $joints;
    $childs = stringArrayCatenate(`listRelatives -ad -type joint $array[0]`, {$array[0]});
    for ($i = size($childs)-1; $i >= 0; $i--) $joints[size($joints)] = $childs[$i];
    $startJnt = $joints[0];
    $endJnt = $joints[size($joints)-1];
    $midJoints = stringArrayRemove({$startJnt, $endJnt}, $joints);
    $totalDist = `nas_distance $joints`;
    $dirVec = `nas_axisToVector $dir`;

    //......................................figure out aim axis......................................
    $vals = `getAttr ($midJoints[0] + ".translate")`;
    $vals = {abs($vals[0]), abs($vals[1]), abs($vals[2])};
    if ($vals[0] > $vals[1] && $vals[0] > $vals[2]) $aimAxis = "x";
    else if ($vals[1] > $vals[0] && $vals[1] > $vals[2]) $aimAxis = "y";
    else if ($vals[2] > $vals[0] && $vals[2] > $vals[1]) $aimAxis = "z";
    if (`getAttr ($midJoints[0] + ".t" + $aimAxis)` < 0) $aimAxis = ("-" + $aimAxis);
    $aimVals = `nas_axisToVector $aimAxis`;

    //......................................figure out where pole vector goes......................................
    $array = `spaceLocator -p 0 0 0`;
    $poleLoc = $array[0];
    //......................................point and aim constrain the pole vector......................................
    //position pole locator in between start and end joints at mid joint
    $lowestDist = 1000000000.0;
        delete `pointConstraint $startJnt $endJnt $poleLoc`;
        /*
    $array = `pointConstraint $startJnt $endJnt $poleLoc`;
    $constraint = $array[0];
    for ($i = 0; $i < 1000; $i++) {
        setAttr ($constraint + "." + $startJnt + "W0") ($i/1000.0);
        setAttr ($constraint + "." + $endJnt + "W1") (1-($i/1000.0));
        if (`nas_distance {$poleLoc, $midJoints[0]}` < $lowestDist) {
            $lowestDist = `nas_distance {$poleLoc, $midJoints[0]}`;
            $value = $i;
        }
    }
    setAttr ($constraint + "." + $startJnt + "W0") ($value/1000.0);
    setAttr ($constraint + "." + $endJnt + "W1") (1-($value/1000.0));
    delete $constraint;
        */
    
        //move the pole loc into final position
        //pole loc will move in world space according to dir when joint chain is straight
        //or move in object space after being aimed at mid joints when joint chain is bent
        $array = `spaceLocator -p 0 0 0`;
    $midLoc = $array[0];
    delete `parentConstraint $midJoints $midLoc`;
    
    $otherVals = {$aimVals[1], $aimVals[2], $aimVals[0]};
        $dist = `nas_distance {$startJnt, $endJnt}`;
    if (($totalDist+.001) > $dist && $dist > ($totalDist-.001)) {
                delete `parentConstraint $midJoints $poleLoc`;
                //move compare locator into place
                $array = `spaceLocator -p 0 0 0`;
                $compareLoc = $array[0];
                delete `pointConstraint $poleLoc $compareLoc`;
                move -r -ws -wd ($dirVec.x) ($dirVec.y) ($dirVec.z) $compareLoc;
                //create locators from pole loc in object space
                for ($i = 1; $i < 3; $i++) {
                    $vals = {$aimVals[$i],
                             $aimVals[($i + 1) % 3],
                             $aimVals[($i + 2) % 3]};
                    $array = `duplicate $poleLoc`;
                    $loc = $array[0];
                    move -r -os $vals[0] $vals[1] $vals[2] $loc;
                    $poleLocs[size($poleLocs)] = $loc;
                    $poleVecs[size($poleVecs)] = <<$vals[0], $vals[1], $vals[2]>>;
                    
                    $vals = {(-1 * $vals[0]), (-1 * $vals[1]), (-1 * $vals[2])};
                    $array = `duplicate $poleLoc`;
                    $loc = $array[0];
                    move -r -os $vals[0] $vals[1] $vals[2] $loc;
                    $poleLocs[size($poleLocs)] = $loc;
                    $poleVecs[size($poleVecs)] = <<$vals[0], $vals[1], $vals[2]>>;
                }
                $lowestDist = 1000000000.0;
                for ($i = 0; $i < size($poleLocs); $i++) {
                    $distance = `nas_distance {$poleLocs[$i], $compareLoc}`;
                    if ($distance < $lowestDist) {
                        $lowestDist = $distance;
                        $vals = $poleVecs[$i];
                    }
                }
                delete $poleLocs $compareLoc;
                move -r -os ($vals[0] * $totalDist / 1.5) 
                            ($vals[1] * $totalDist / 1.5) 
                            ($vals[2] * $totalDist / 1.5)
                            $poleLoc;
    } else {
                delete `aimConstraint -offset 0 0 0 -weight 1 
                                      -aimVector $otherVals[0] $otherVals[1] $otherVals[2] 
                                      -upVector $aimVals[0] $aimVals[1] $aimVals[2] 
                                      -worldUpType "object" 
                                      -worldUpObject $endJnt 
                                      $midLoc $poleLoc`;
                move -r -os -wd ($otherVals[0] * $totalDist / 1.5) 
                                ($otherVals[1] * $totalDist / 1.5) 
                                ($otherVals[2] * $totalDist / 1.5)
                                $poleLoc;
    }
    makeIdentity -apply true -t 1 -r 1 -s 1 $poleLoc;
    
    //find the preferred axis and set it on mid joints
    $array = `spaceLocator -p 0 0 0`;
    $loc = $array[0];
    $array = `nas_group 0 "Group"`;
    $grp = $array[0];
    delete `parentConstraint $midLoc $grp`;
    delete `pointConstraint $poleLoc $grp`;
    delete `aimConstraint -offset 0 0 0 -weight 1 
                          -aimVector $aimVals[0] $aimVals[1] $aimVals[2] 
                          -upVector $otherVals[0] $otherVals[1] $otherVals[2] 
                          -worldUpType "objectrotation" 
                          -worldUpVector $otherVals[0] $otherVals[1] $otherVals[2] 
                          -worldUpObject $midLoc 
                          $endJnt $loc`;
    $vals = `getAttr ($loc + ".rotate")`;
        for ($midJoint in $midJoints) {
            setAttr ($midJoint + ".preferredAngle") ($vals[0]) ($vals[1]) ($vals[2]);
        }
    delete $grp $midLoc;
    
    //......................................create ikHandle and controls for handle and pole vector......................................
    $array = `ikHandle -n ($name + "_IK_Handle") -ap -s sticky -sj $startJnt -ee $endJnt -sol ikRPsolver`;
    $handle = $array[0];
    select -r $startJnt;
    $array = `nas_controls "surfaceDoublePin"`;
    setAttr -type "string" ($array[0] + ".nickCtrlType") "char";
    nas_colorControls "red" 1;
    nas_shadeControls "red";
    $ikClav = `rename $array[0] ($name + "_IK_Clavicle_Ctrl")`;
    //setAttr ($ikClav + ".rotate") 0 0 0;
    setAttr ($ikClav + ".scale") 2 2 2;
    makeIdentity -apply true -t 1 -r 0 -s 1 $ikClav;
    
    select -r $handle $poleLoc;
    $array = `nas_controls "surfaceSphere"`;
    setAttr -type "string" ($array[0] + ".nickCtrlType") "char";
    setAttr -type "string" ($array[1] + ".nickCtrlType") "char";
    nas_colorControls "red" 1;
    nas_shadeControls "red";
    $ikCtrl = `rename $array[0] ($name + "_IK_01_Ctrl")`;
    $poleVector = `rename $array[1] ($name + "_IK_PoleVector_Ctrl")`;
    delete `aimConstraint -offset 0 0 0 -weight 1 
                          -aimVector ($aimVals[0]*-1) ($aimVals[1]*-1) ($aimVals[2]*-1) 
                          -upVector $otherVals[0] $otherVals[1] $otherVals[2] 
                          -worldUpType "objectrotation" 
                          -worldUpVector $otherVals[0] $otherVals[1] $otherVals[2] 
                          -worldUpObject $midJoints[size($midJoints)-1] 
                          $midJoints[size($midJoints)-1] $ikCtrl`;
        if ($world) {
            select -r $ikCtrl;
            nas_matchWorld;
        }
    scale -r .5 .5 .5 $poleVector;
    makeIdentity -apply true -t 0 -r 0 -s 1 $poleVector $ikCtrl;
    delete $poleLoc;
    
    //......................................create ctrl groups......................................
    select -r $ikClav $ikCtrl $poleVector;
    $array = `nas_group 0 "Group"`;
    $ikClavGroup = $array[0];
    $ikCtrlGroup = $array[1];
    $poleVectorGroup = $array[2];
    select -r $poleVector;
    nas_group 0 "Pos_Group";
    
    //......................................constrain pole vector to ik ctrl......................................
    addAttr -ln "Follow" -at "enum" -en "IK Control:COG:Transform:World:Master" $poleVector;
    setAttr -e -k true ($poleVector + ".Follow");
    $array = `parentConstraint -mo $ikCtrl $poleVectorGroup`;
    setDrivenKeyframe -at ($ikCtrl + "W0") -currentDriver ($poleVector + ".Follow") -itt linear -ott linear -driverValue 0 -value 1 $array[0];
    setDrivenKeyframe -at ($ikCtrl + "W0") -currentDriver ($poleVector + ".Follow") -itt linear -ott linear -driverValue 1 -value 0 $array[0];
    
    //......................................constrain to handle and pole vector ctrls......................................
    parentConstraint -mo $ikClav $startJnt;
    $ikNull = `group -em -n ($name + "_IK_01_Ctrl_Null")`;
    delete `parentConstraint $ikCtrl $ikNull`;
    parent $ikNull $ikCtrl;
    makeIdentity -apply true -t 1 -r 1 -s 1 $ikNull;
    parentConstraint -mo $ikNull $handle;
    poleVectorConstraint -weight 1 $poleVector $handle;
    
    //......................................create start and end distance locs and constrain......................................
    $array = `spaceLocator -p 0 0 0 -n ($name + "_IK_Dist_01_Loc")`;
    $dist1Loc = $array[0];
    $array = `spaceLocator -p 0 0 0 -n ($name + "_IK_Dist_02_Loc")`;
    $dist2Loc = $array[0];
    
    $distNode = `createNode -n ($name + "_IK_Stretch_Dist") distanceBetween`;
    connectAttr ($dist1Loc + ".worldMatrix") ($distNode + ".inMatrix1");
    connectAttr ($dist2Loc + ".worldMatrix") ($distNode + ".inMatrix2");
    pointConstraint $ikClav $dist1Loc;
    pointConstraint $ikNull $dist2Loc;
    
    //......................................add ik attrs and connect basic attrs......................................
    addAttr -ln "Stretchy" -at double -min 0 -max 1 -dv 1 $ikCtrl;
    setAttr -e -k true ($ikCtrl + ".Stretchy");
    addAttr -ln "Length" -at double -min 0 -dv 1 $ikCtrl;
    setAttr -e -k true ($ikCtrl + ".Length");
    addAttr -ln "Twist" -at double $ikCtrl;
    setAttr -e -k true ($ikCtrl + ".Twist");
    //$array = stringToStringArray($name, "_");
    //for ($item in $array) if ($item == "Arm") $midName = "Elbow";
    //for ($item in $array) if ($item == "Leg") $midName = "Knee";
    $midName = "MidLocation";
    addAttr -ln $midName -at double -min 0 -max 1 -dv .5 $ikCtrl;
    setAttr -e -k true ($ikCtrl + "." + $midName);
    addAttr -ln "PoleVectorVis" -at enum -en "Off:On:" -dv 1 $ikCtrl;
    setAttr -e -cb 1 -k 0 ($ikCtrl + ".PoleVectorVis");
    addAttr -ln "Follow" -at enum -en "COG:Transform:World:Master:" -dv 1 $ikCtrl;
    setAttr -e -k true ($ikCtrl + ".Follow");
    connectAttr ($ikCtrl + ".Twist") ($handle + ".twist");
    connectAttr ($ikCtrl + ".PoleVectorVis") ($poleVector + ".v");
    
    //......................................create stretchy ik......................................
    $stretchMD = `createNode -n ($name + "_IK_Stretch_MD") multiplyDivide`;
    setAttr ($stretchMD + ".operation") 2;
    connectAttr ($distNode + ".distance") ($stretchMD + ".input1X");
    
    $scaleMD = `createNode -n ($name + "_IK_Scale_MD") multiplyDivide`;
    setAttr ($scaleMD + ".input1X") `nas_distance $joints`;
    setAttr ($scaleMD + ".input1Y") `getAttr ($joints[1] + ".t" + endString($aimAxis, 1))`;
    setAttr ($scaleMD + ".input1Z") `getAttr ($joints[2] + ".t" + endString($aimAxis, 1))`;
    connectAttr ($scaleMD + ".outputX") ($stretchMD + ".input2X");
    
    $blend = `createNode -n ($name + "_IK_Stretch_Blend") blendColors`;
    $maxClamp = `createNode -n ($name + "_IK_Stretch_Max_Clamp") clamp`;
    $clamp = `createNode -n ($name + "_IK_Stretch_Clamp") clamp`;
    
    connectAttr ($ikCtrl + ".Stretchy") ($blend + ".blender");
    connectAttr ($stretchMD + ".outputX") ($blend + ".color1R");
    connectAttr ($ikCtrl + ".Length") ($blend + ".color2R");
    
    connectAttr ($ikCtrl + ".Length") ($maxClamp + ".minR");
    setAttr ($maxClamp + ".maxR") 1000000000;
    connectAttr ($blend + ".outputR") ($maxClamp + ".inputR");
    
    connectAttr ($ikCtrl + ".Length") ($clamp + ".minR");
    connectAttr ($maxClamp + ".outputR") ($clamp + ".maxR");
    connectAttr ($stretchMD + ".outputX") ($clamp + ".inputR");
    
    if (size($midJoints) > 2) {
        for ($i = 0; $i < size($joints)-1; $i++) connectAttr ($clamp + ".outputR") ($joints[$i] + ".s" + `endString $aimAxis 1`);
    } else {
        $upperMD = `createNode -n ($name + "_IK_Stretch_Upper_MD") multiplyDivide`;
        connectAttr ($clamp + ".outputR") ($upperMD + ".input1X");
        
        setDrivenKeyframe -currentDriver ($ikCtrl + "." + $midName) -itt linear -ott linear -driverValue 1.0 -value (`nas_distance $joints`/`nas_distance {$joints[0], $joints[1]}`) ($upperMD + ".input2X");
        setDrivenKeyframe -currentDriver ($ikCtrl + "." + $midName) -itt linear -ott linear -driverValue 0.5 -value 1 ($upperMD + ".input2X");
        setDrivenKeyframe -currentDriver ($ikCtrl + "." + $midName) -itt linear -ott linear -driverValue 0.0 -value 0 ($upperMD + ".input2X");
        
        $upperTransMD = `createNode -n ($name + "_IK_Stretch_Upper_Translate_MD") multiplyDivide`;
        connectAttr ($scaleMD + ".outputY") ($upperTransMD + ".input1X");
        connectAttr ($upperMD + ".outputX") ($upperTransMD + ".input2X");
        connectAttr ($upperTransMD + ".outputX") ($joints[1] + ".t" + `endString $aimAxis 1`);
    
        $lowerMD = `createNode -n ($name + "_IK_Stretch_Lower_MD") multiplyDivide`;
        connectAttr ($clamp + ".outputR") ($lowerMD + ".input1X");
        
        setDrivenKeyframe -currentDriver ($ikCtrl + "." + $midName) -itt linear -ott linear -driverValue 0.0 -value (`nas_distance $joints`/`nas_distance {$joints[1], $joints[2]}`) ($lowerMD + ".input2X");
        setDrivenKeyframe -currentDriver ($ikCtrl + "." + $midName) -itt linear -ott linear -driverValue 0.5 -value 1 ($lowerMD + ".input2X");
        setDrivenKeyframe -currentDriver ($ikCtrl + "." + $midName) -itt linear -ott linear -driverValue 1.0 -value 0 ($lowerMD + ".input2X");
        
        $lowerTransMD = `createNode -n ($name + "_IK_Stretch_Lower_Translate_MD") multiplyDivide`;
        connectAttr ($scaleMD + ".outputZ") ($lowerTransMD + ".input1X");
        connectAttr ($lowerMD + ".outputX") ($lowerTransMD + ".input2X");
        connectAttr ($lowerTransMD + ".outputX") ($joints[2] + ".t" + `endString $aimAxis 1`);
        
        if (size($midJoints) == 2) connectAttr ($clamp + ".outputR") ($midJoints[0] + ".s" + `endString $aimAxis 1`);
    }
    
    select -r $ikClav $poleVector;
    nas_showAttrs 1 1 1 0 0 0 0 0 0 0;
    select -r $ikCtrl;
    nas_showAttrs 1 1 1 1 1 1 0 0 0 0;
    
    $ctrlGroup = `group -em -n ($name + "_IK_Ctrl_Group")`;
    parent $ikClavGroup $poleVectorGroup $ikCtrlGroup $ctrlGroup;
    $deformerGroup = `group -em -n ($name + "_IK_Deformer_Group")`;
    parent $handle $dist1Loc $dist2Loc $deformerGroup;
    setAttr ($deformerGroup + ".v") 0;
    
    $jointsGroup = `group -em -n ($name + "_IK_Jnt_Group")`;
    parent $startJnt $jointsGroup;

    return {$ikCtrl, $poleVector, $ikClav, $dist1Loc, $ctrlGroup, $deformerGroup, $jointsGroup, $ikNull, $scaleMD};
}

global proc nas_rigIKUI() {
    global string $nas_rigIKField, $nas_rigIKRadios[], $nas_rigIKCheckBox;
    string $window, $form, $text, $field, $autoText1, $autoText2, $autoText, $radioText, $radios[], $radioForm, $cmd, $button, $checkBox, $array[];

    $window = `nas_window "nas_rigIK" 1 0 0`;
    $form = `formLayout`;
    $text = `text -w 50 -label "Body Part:"`;
    $field = `textField`;
    $button = `button -label "Create IK System" -c "nas_rigIKExecute"`;
    $array = `nas_radioCheckBoxGrp "Pole Dir:" 50 {"X", "Y", "Z"} {"", "", "1"} "Negative" 60 {}`;
    $radioForm = $array[0];
    $checkBox = $array[size($array)-1];
    checkBoxGrp -e -v1 1 $checkBox;
    $radios = stringArrayRemove({$array[0], $array[size($array)-1]}, $array);

    formLayout -e 
        -af $text "top" 8
        -af $text "left" 5
        
        -af $field "top" 5
        -af $field "right" 5
        -ac $field "left" 0 $text 

        -af $radioForm "left" 5
        -ac $radioForm "top" 5 $field 
        -af $radioForm "right" 5
        
        -ac $button "top" 5 $radioForm 
        -af $button "left" 5
        -af $button "right" 5
        -af $button "bottom" 5
    $form;
    window -e -wh 250 120 $window;
    showWindow $window;
    
    $nas_rigIKField = $field;
    $nas_rigIKRadios = {$radios[0], $radios[1], $radios[2]};
    $nas_rigIKCheckBox = $checkBox;
}

global proc nas_rigIKExecute() {
    global string $nas_rigIKField, $nas_rigIKRadios[], $nas_rigIKCheckBox;
    string $name, $axis;
    int $auto;
    
    $name = `textField -q -tx $nas_rigIKField`;
    if (`radioButton -q -select $nas_rigIKRadios[0]` == 1) $axis = "x";
    else if (`radioButton -q -select $nas_rigIKRadios[1]` == 1) $axis = "y";
    else if (`radioButton -q -select $nas_rigIKRadios[2]` == 1) $axis = "z";
    
    if (`checkBoxGrp -q -v1 $nas_rigIKCheckBox`) $axis = ("-" + $axis);
    
    nas_rigIK $name $axis 0;
}

//-------------------------------------------------------------nas_rigBind---------------------------------------------------------------------
global proc string[] nas_rigBind(string $name, int $num) {
    string $sels[], $locs[], $array[], $curve, $bndJoints[], $skinCluster, $array[], $infos[], $motionPaths[], 
    $twistLoc, $twistGroup, $twistMD, $bindGroup, $deformerGroup, $groups[], $joints[], $bndJointGroups[], $locsGroup, $MPNulls[], 
    $splineJoints[], $handle, $curveInfo, $stretchMD,  
    $realBndJoints[], $realBndJoints[], $realBndJointGroups[], 
    $startTwistLoc, $startTwistLocGroup, $endTwistLoc, $endTwistLocGroup, $startUpLoc, $endUpLoc, $motionPath, $curveShape, $bindLocs[], 
    $twistFalloffSR, $twistFalloffMD, $twistFalloffPMA;
    float $percent, $vals[];

    //......................................create curve......................................
    $sels = `ls -sl`;
    $array = `nas_locator 1`;
    select -r $array;
    $locs = `nas_segments ($num-2)`;
    $curve = `nas_createCurve`;
    $curve = `rename $curve ($name + "_Curve")`;
    $array = `listRelatives -s $curve`;
    $curveShape = $array[0];
    delete $locs;

    //......................................create spline bind joints......................................    
    select -cl;
    $bndJoints[0] = `joint -n ($name + "Bind_Start_Jnt") -p 0 0 0 -radius 2`;
    $bndJointGroups[0] = `group -n ($name + "_Bind_Start_Jnt_Group") $bndJoints[0]`;
    select -cl;
    $bndJoints[1] = `joint -n ($name + "_Bind_End_Jnt") -p 0 0 0 -radius 2`;
    $bndJointGroups[1] = `group -n ($name + "_Bind_End_Jnt_Group") $bndJoints[1]`;
        
    delete `pointConstraint $sels[0] $bndJointGroups[0]`;
    delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $sels[1] $sels[1] $bndJointGroups[0]`;
    delete `pointConstraint $sels[1] $bndJointGroups[1]`;
    delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $sels[0] $sels[0] $bndJointGroups[1]`;

    //......................................skin curve to bind spline joints......................................
    select -r $bndJoints $curve;
    $array = `newSkinCluster "-toSelectedBones -ignoreHierarchy -dr 10 -rui false"`;
    $skinCluster = $array[0];
    skinPercent -tv $bndJoints[0] 1.0 $skinCluster ($curve + ".cv[0]");
    skinPercent -tv $bndJoints[0] .9 $skinCluster ($curve + ".cv[1]");
    skinPercent -tv $bndJoints[0] .50 $skinCluster ($curve + ".cv[2]");
    skinPercent -tv $bndJoints[0] .1 $skinCluster ($curve + ".cv[3]");
    skinPercent -tv $bndJoints[0] 0.0 $skinCluster ($curve + ".cv[4]");

    //......................................create up locators......................................
    $array = `spaceLocator -n ($name + "_Start_Up_Loc") -p 0 0 0`;
    $startUpLoc = $array[0];
    $array = `nas_group 0 "Group"`;
    $startUpLocGroup = $array[0];
    delete `parentConstraint $sels[0] $startUpLocGroup`;
    $array = `spaceLocator -n ($name + "_End_Up_Loc") -p 0 0 0`;
    $endUpLoc = $array[0];
    $array = `nas_group 0 "Group"`;
    $endUpLocGroup = $array[0];
    delete `parentConstraint $sels[1] $endUpLocGroup`;
    delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $sels[0] $sels[0] $endUpLocGroup`;
    
    //......................................create bind joints......................................
    for ($i = 0; $i < $num; $i++) {
        select -cl;
        $realBndJoints[$i] = `joint -n ($name + "_Bind_" + (nas_framePadding("##", ($i+1))) + "_Jnt") -radius 3`;
        $realBndJointGroups[$i] = `group -n ($name + "_Bind_" + (nas_framePadding("##", ($i+1))) + "_Jnt_Group") $realBndJoints[$i]`;
        
        $motionPath = `createNode -n ($name + "_Bind_" + (nas_framePadding("##", ($i+1))) + "_MotionPath") motionPath`;
        setAttr ($motionPath + ".fractionMode") 1;
        setAttr ($motionPath + ".uValue") (($i*1.0)/($num-1));
        $array = `spaceLocator -p 0 0 0 -n ($name + "_Bind_" + (nas_framePadding("##", ($i+1))) + "_Loc")`;
        $bindLocs[$i] = $array[0];
        connectAttr ($curveShape + ".worldSpace[0]") ($motionPath + ".geometryPath");
        connectAttr ($motionPath + ".xCoordinate") ($bindLocs[$i] + ".tx");
        connectAttr ($motionPath + ".yCoordinate") ($bindLocs[$i] + ".ty");
        connectAttr ($motionPath + ".zCoordinate") ($bindLocs[$i] + ".tz");
        pointConstraint $bindLocs[$i] $realBndJointGroups[$i];
    }
    for ($i = 0; $i < $num; $i++) {
        if ($i == $num-1) aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $startUpLoc $realBndJointGroups[$i-1] $realBndJointGroups[$i];
        else aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $startUpLoc $realBndJointGroups[$i+1] $realBndJointGroups[$i];
    }

    //......................................create twist locators......................................
    $array = `spaceLocator -n ($name + "_End_Twist_Loc") -p 0 0 0`;
    $endTwistLoc = $array[0];
    $endTwistLocGroup = `group -n ($name + "_End_Twist_Loc_Group") $endTwistLoc`;
    
    pointConstraint $bndJoints[1] $endTwistLocGroup;
    aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $startUpLoc $bndJoints[0] $endTwistLocGroup;
    pointConstraint $bndJoints[1] $endTwistLoc;
    aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $endUpLoc $bndJoints[0] $endTwistLoc;

    $twistFalloffSR = `createNode -n ($name + "_TwistFalloff_SR") setRange`;
    setAttr ($twistFalloffSR + ".oldMaxX") 1;
    
    for ($i = 0; $i < $num; $i++) {
        $twistFalloffMD = `createNode -n ($name + "_" + nas_framePadding("##", ($i+1)) + "_TwistFalloff_MD") multiplyDivide`;
        setAttr ($twistFalloffMD + ".operation") 3;
        //setAttr ($twistFalloffMD + ".input1X") (1-(1.0/6.0*($i+1)));
        setAttr ($twistFalloffMD + ".input1X") (1.0-(($i*1.0)/($num-1.0)));
        connectAttr ($twistFalloffSR + ".outValueX") ($twistFalloffMD + ".input2X");
        $twistFalloffPMA = `createNode -n ($name + "_" + nas_framePadding("##", ($i+1)) + "_TwistFalloff_PMA") plusMinusAverage`;
        setAttr ($twistFalloffPMA + ".operation") 2;
        setAttr ($twistFalloffPMA + ".input3D[0].input3Dx") 1;
        connectAttr ($twistFalloffMD + ".outputX") ($twistFalloffPMA + ".input3D[1].input3Dx");
        $twistMD = `createNode -n ($name + "_" + nas_framePadding("##", ($i+1)) + "_Twist_MD") multiplyDivide`;
        connectAttr ($endTwistLoc + ".rx") ($twistMD + ".input1X");
        connectAttr ($twistFalloffPMA + ".output3Dx") ($twistMD + ".input2X");
        connectAttr ($twistMD + ".outputX") ($realBndJoints[$i] + ".rx");
    }

    //......................................clean up......................................        
    $bindGroup = `group -em -n ($name + "_Bind_Jnt_Group")`;
    parent $bndJointGroups $realBndJointGroups $bindGroup;
    
    $deformerGroup = `group -em -n ($name + "_Bind_Deformer_Group")`;
    $bindLocsGroup = `group -em -n ($name + "_Bind_Loc_Group")`;
    parent $bindLocs $bindLocsGroup;
    parent $curve $startUpLocGroup $endUpLocGroup /*$startTwistLocGroup*/ $endTwistLocGroup $bindLocsGroup $deformerGroup;
    
    setAttr ($bndJointGroups[0] + ".v") 0;
    setAttr ($bndJointGroups[1] + ".v") 0;
    setAttr ($curve + ".v") 0;
    setAttr ($endTwistLocGroup + ".v") 0;
    
    return {$bndJoints[0], $bndJoints[1], $bndJointGroups[0], $bndJointGroups[1], $bindGroup, $deformerGroup, $startUpLoc, $endUpLoc, $startUpLocGroup, $endUpLocGroup, $endTwistLoc, $twistFalloffSR};
}

//-------------------------------------------------------------nas_createWireCurve---------------------------------------------------------------------
global proc string nas_createWireCurve() {
    string $locs[], $firsts[], $seconds[], $finalLocs[], $locs1[], $locs2[], $allLocs[], $curve, $array[], $sels[];
    $sels = `ls -sl`;
    if (size($sels) == 2) $locs = `nas_segments 1`;
    else if (size($sels) == 3) $locs = `ls -sl`;
    else error "please make 3 selections.";
    
    //first set
    select -r $locs[0] $locs[1];
    $firsts = `nas_segments 3`;
    select -r $firsts[0] $firsts[1];
    $seconds = `nas_segments 3`;
    $locs1 = {$seconds[0], $seconds[1], $seconds[3], $firsts[2], $firsts[4]};
    $allLocs = stringArrayCatenate($firsts, $seconds);
    
    //second set
    select -r $locs[1] $locs[2];
    $firsts = `nas_segments 3`;
    select -r $firsts[3] $firsts[4];
    $seconds = `nas_segments 3`;
    $locs2 = {$firsts[2], $seconds[1], $seconds[3], $seconds[4]};
    $finalLocs = stringArrayCatenate($locs1, $locs2);
    $allLocs = stringArrayCatenate($allLocs, $firsts);
    $allLocs = stringArrayCatenate($allLocs, $seconds);
    $allLocs = stringArrayRemove($finalLocs, $allLocs);
    $allLocs = stringArrayRemoveDuplicates($allLocs);

    delete $allLocs;
    select -r $finalLocs; $curve = `nas_createCurve`;
    $array = stringArrayRemove ($sels, $finalLocs);
    delete $array;
    return $curve;
}

//-------------------------------------------------------------nas_locator---------------------------------------------------------------------
//creates a locator at the center of the selected object or selected vertices
global proc string[] nas_locator(int $type) {
    string $sels[], $locator, $panels[], $array[], $object, $locators[], $clusters[], $geos[], $names[];
    float $xforms[], $bb[], $wp[];

    $sels = `ls -sl -flatten`;
    $array = stringToStringArray($sels[0], ".");
    $object = $array[0];
    
    if ($type == 1) {
        $array = `listRelatives -s -fullPath $object`;
        if (size($array[0]) && `objectType $array[0]` == "locator") {
            for ($sel in $sels) {
                $xforms = `xform -q -ws -rp $sel`;
                $wp[0] += $xforms[0];
                $wp[1] += $xforms[1];
                $wp[2] += $xforms[2];
            }
            $array = `spaceLocator`;
            $locators[0] = $array[0];
            move -ws ($wp[0]/size($sels)) ($wp[1]/size($sels)) ($wp[2]/size($sels)) $locators[0];
        } else {
            for ($i = 0; $i < size($sels); $i++) {
                $xforms = `xform -q -ws -rp $sels[$i]`;
                $array = `spaceLocator`; $locators[$i] = $array[0];
                move -ws $xforms[0] $xforms[1] $xforms[2] $locators[$i];
                delete `orientConstraint $sels[$i] $locators[$i]`;
            }
        }
    } else if ($type == 0) {
        $bb = `nas_boundingBox $sels`;
        for ($i = 0; $i < 3; $i++) $wp[$i] = ($bb[$i] + $bb[$i+3])/2.0;
        $array = `spaceLocator`; $locators[size($locators)] = $array[0];
        move -ws $wp[0] $wp[1] $wp[2] $array[0];
    } else if ($type == -1) {
        for ($sel in $sels) {
            $xforms = `xform -ws -q -translation $sel`;
            $array = `spaceLocator`; $locators[size($locators)] = $array[0];
            move -ws $xforms[0] $xforms[1] $xforms[2] $array[0];
        }
    } else if ($type == -2) {
        for ($sel in $sels) {
            select -r $sel;
            $array = `newCluster " -envelope 1"`;
            $clusters[size($clusters)] = $array[0];
        }
    }
    if ($locator != "" && size($locators)) $locators = stringArrayCatenate({$locator}, $locators);
    $array = stringArrayCatenate($locators, $clusters);
    $panels = `nas_getVisibleModelPanels`;
    for ($panel in $panels) for ($i in $array) isolateSelect -ado $i $panel;
    //scale -r .1 .1 .1 $locators;
    
    select -r $sels;
    if ($type == 0 || $type == -1) hilite $object;
    else if ($type == -2) select -r $clusters;
    return $locators;
}

//-------------------------------------------------------------nas_createCurve---------------------------------------------------------------------
//creates a curve from selected locators
global proc string nas_createCurve() {
    string $locs[], $curveCommand, $rotatePivot, $curve;
    float $floatArray[];

    $locs = `ls -sl`;
    if (size($locs) < 4) error "Please select at least 4 locators to make a 3 degree curve.";
    $curveCommand = "curve -d 3 ";
    for ($loc in $locs) {
        $floatArray = `xform -q -ws -rp $loc`;
        $curveCommand += ("-p " + $floatArray[0] + " " + $floatArray[1] + " " + $floatArray[2] + " ");
    }
    $curveCommand += "-k 0 -k 0 ";
    for ($i = 0; $i <= (size($locs)-3); $i++) $curveCommand += ("-k " + $i + " ");
    $curveCommand += ("-k " + (size($locs)-3) + " -k " + (size($locs)-3) + ";");
    $curve = `eval $curveCommand`;
    return $curve;
}

//-------------------------------------------------------------nas_createLayout---------------------------------------------------------------------
/*
int $numSpine = 6;
int $numUvula = 4;
int $numTongue = 7;
int $numEar = 4;
int $numNeck = 3;
int $numFingers = 5;
int $numFingerJoints = 4;
int $numToes = 5;
int $numToesJoints = 4;
int $numArms = 1;
int $numLegs = 1;
int $layoutSpine = 1;
int $layoutUvula = 1;
int $layoutTongue = 1;
int $layoutEar = 1;
int $layoutNeck = 1;
int $layoutFingers = 1;
int $layoutToes = 1;
int $layoutRest = 1;
int $layoutArms = 1;
int $layoutLegs = 1;

*/
//creates layout for auto rig
//nas_createLayout 6 2 4 7 4 3 5 4 5 4 2 2 1 1 1 1 1 1 1 1 1 1 1;
global proc nas_createLayout(int $numSpine, int $numClavicle, int $numUvula, int $numTongue, int $numEar, int $numNeck, int $numFingers, int $numFingerJoints, int $numToes, int $numToesJoints, int $numArms, int $numLegs, int $layoutSpine, int $layoutClavicle, int $layoutUvula, int $layoutTongue, int $layoutEar, int $layoutNeck, int $layoutFingers, int $layoutToes, int $layoutRest, int $layoutArms, int $layoutLegs) {    
    string $startLoc, $endLoc, $locs[], $array[], $handJnt, $ballJnt;
    float $wp[];
    
    $array = `spaceLocator -p 0 0 0`;
    $startLoc = $array[0];
    $array = `spaceLocator -p 0 0 0`;
    $endLoc = $array[0];
    
    //create spine joints
    if ($layoutSpine) {
        delete `nas_getTopJoints "Spine_*_Bind_01_Jnt"`;
        move -ws 0 24 -1 $startLoc;
        move -ws 0 33 -1 $endLoc;
        select -r $startLoc $endLoc;
        $locs = `nas_segments ($numSpine-2)`;
        nas_joints "Spine_01_Bind_##_Jnt" y z z 0;
        delete (stringArrayRemove({$startLoc, $endLoc}, $locs));
    
        //create hip joint
        delete `nas_getTopJoints "Hip_*_Bind_01_Jnt"`;
        move -ws 0 24 -1 $startLoc;
        move -ws 0 33 -1 $endLoc;
        select -r $startLoc $endLoc;
        $array = `nas_joints "Hip_01_Bind_##_Jnt" y z z 0`;
        setAttr ($array[0] + ".radius") 5;
        delete $array[1];
    }
    
    if ($layoutUvula) {
        delete `nas_getTopJoints "Uvula_*_Bind_01_Jnt"`;
        //create uvula joints
        move -ws 0 39.4 0 $startLoc;
        move -ws 0 38.9 0 $endLoc;
        select -r $startLoc $endLoc;
        $locs = `nas_segments ($numUvula-2)`;
        nas_joints "Uvula_01_Bind_##_Jnt" x y z 0;
        delete (stringArrayRemove({$startLoc, $endLoc}, $locs));
    }
    
    if ($layoutTongue) {
        delete `nas_getTopJoints "Tongue_*_Bind_01_Jnt"`;
        //create tongue joints
        move -ws 0 38.4 -0.2 $startLoc;
        move -ws 0 38.4 1.80 $endLoc;
        select -r $startLoc $endLoc;
        $locs = `nas_segments ($numTongue-2)`;
        nas_joints "Tongue_01_Bind_##_Jnt" x y z 0;
        delete (stringArrayRemove({$startLoc, $endLoc}, $locs));
    }
    
    if ($layoutEar) {
        delete `nas_getTopJoints "*_Ear_*_Bind_01_Jnt"`;
        //create ear joints
        move -ws 2.3 41.4 -.90 $startLoc;
        move -ws 3.0 41.7 -1.8 $endLoc;
        select -r $startLoc $endLoc;
        $locs = `nas_segments ($numEar-2)`;
        nas_joints "LT_Ear_01_Bind_##_Jnt" x y y 0;
        delete (stringArrayRemove({$startLoc, $endLoc}, $locs));
    }
    
    if ($layoutNeck) {
        delete `nas_getTopJoints "Neck_*_Bind_01_Jnt"`;
        //create neck joints
        move -ws 0 35.5 -.90 $startLoc;
        move -ws 0 38.1 -.90 $endLoc;
        select -r $startLoc $endLoc;
        $locs = `nas_segments ($numNeck-2)`;
        nas_joints "Neck_01_Bind_##_Jnt" y z z 0;
        delete (stringArrayRemove({$startLoc, $endLoc}, $locs));
    }
    
    if ($layoutArms) {
        delete `nas_getTopJoints "*_Clavicle_*_Bind_01_Jnt"`;
        delete `nas_getTopJoints "*_Arm_*_Bind_01_Jnt"`;
        delete `nas_getTopJoints "*_Hand_*_Bind_01_Jnt"`;
        for ($i = 0; $i < $numArms; $i++) {
            if ($layoutClavicle) {
                //create left clavicle joints
                move -ws 1.60 33.0 (-1.2 + (-5*$i)) $startLoc;
                move -ws 3.75 33.5 (-1.2 + (-5*$i)) $endLoc;
                select -r $startLoc $endLoc;
                $locs = `nas_segments ($numClavicle-2)`;
                nas_joints ("LT_Clavicle_" + (nas_framePadding("##", ($i+1))) + "_Bind_##_Jnt") x y y 0;
                delete (stringArrayRemove({$startLoc, $endLoc}, $locs));
            }
            //create left arm joints
            move -ws 3.75 33.5 (-1.2 + (-5*$i)) $startLoc;
            move -ws 16.9 33.5 (-1.2 + (-5*$i)) $endLoc;
            select -r $startLoc $endLoc;
            $locs = `nas_segments 2`;
            move -ws 4.50 33.5 (-1.2 + (-5*$i)) $locs[1];
            move -ws 10.7 33.5 (-1.2 + (-5*$i)) $locs[2];
            nas_joints ("LT_Arm_" + (nas_framePadding("##", ($i+1))) + "_Bind_##_Jnt") x y y 0;
            delete (stringArrayRemove({$startLoc, $endLoc}, $locs));
        
            if ($layoutFingers) {
                //create left hand joint
                move -ws 16.9 33.5 (-1.2 + (-5*$i)) $startLoc;
                move -ws 20.0 33.5 (-1.2 + (-5*$i)) $endLoc;
                select -r $startLoc $endLoc;
                $array = `nas_joints ("LT_Hand_" + (nas_framePadding("##", ($i+1))) + "_Bind_##_Jnt") x y y 0`;
                $handJnt = $array[0];
                setAttr ($handJnt + ".radius") 5;
                delete $array[1];
                
                //create fingers
                for ($j = 0; $j < $numFingers; $j++) {
                    move -ws 19.4 33.5 (((-1.2 + (-5*$i)) + ($numFingers-1)*.35) - (.7*$j)) $startLoc;
                    move -ws 22.2 33.5 (((-1.2 + (-5*$i)) + ($numFingers-1)*.35) - (.7*$j)) $endLoc;
                    select -r $startLoc $endLoc;
                    $locs = `nas_segments ($numFingerJoints-2)`;
                    $array = `nas_joints ("LT_Hand_" + (nas_framePadding("##", ($i+1))) + "_Finger_" + (nas_framePadding("##", ($j+1))) + "_Bind_##_Jnt") x y y 0`;
                    delete (stringArrayRemove({$startLoc, $endLoc}, $locs));
                    if ($j == $numFingers-1) {
                        select -cl;
                        $name = ("LT_Hand_" + (nas_framePadding("##", ($i+1))) + "_Cup_01_Bind_01_Jnt");
                        joint -n $name -p 0 0 0;
                        delete `pointConstraint $handJnt $array[0] $name`;
                        parent $array[0] $name;
                        parent $name $handJnt;
                    } else {
                        parent $array[0] $handJnt;
                    }
                }
            }
        }
    }
        
    if ($layoutLegs) {
        delete `nas_getTopJoints "*_Leg_*_Bind_01_Jnt"`;
        delete `nas_getTopJoints "*_Foot_*_Bind_01_Jnt"`;
        delete `nas_getTopJoints "*_Ball_*_Bind_01_Jnt"`;
        delete `ls "*_Foot_*_*_Loc"`;
        
        for ($i = 0; $i < $numLegs; $i++) {
            //create leg joints
            move -ws 1.1 22.2 (-1.0 - (8*$i)) $startLoc;
            move -ws 2.7 2.75 (-1.0 - (8*$i)) $endLoc;
            select -r $startLoc $endLoc;
            $locs = `nas_segments 2`;
            move -ws 2.7 20.8 (-1.0 - (8*$i)) $locs[1];
            move -ws 2.7 11.0 (-.70 - (8*$i)) $locs[2];
            $array = `nas_joints ("LT_Leg_" + (nas_framePadding("##", ($i+1))) + "_Bind_##_Jnt") x y -x 0`;
            parent -w $array[1];
            delete $array[0];
            select -cl;
            $array[0] = `joint -n ("LT_Leg_" + (nas_framePadding("##", ($i+1))) + "_Bind_01_Jnt") -p 0 0 0`;
            move -ws 1.1 22.2 (-1.0 - (8*$i)) $array[0];
            parent $array[1] $array[0];
            delete (stringArrayRemove({$startLoc, $endLoc}, $locs));
            
            //create foot joints
            $array = `spaceLocator -p 0 0 0`;
            move -ws 2.7 2.75 (-1.0 - (8*$i)) $array[0];
            move -ws 2.7 .4 (.32 - (8*$i)) $startLoc;
            move -ws 2.7 .4 (4.8 - (8*$i)) $endLoc;
            select -r $startLoc $endLoc;
            $locs = `nas_segments 1`;
            select -r $array[0] $locs;
            nas_joints ("LT_Foot_" + (nas_framePadding("##", ($i+1))) + "_Bind_##_Jnt") x y -x 0;
            delete $array[0];
            
            //create foot locs
            $array = `spaceLocator -n ("LT_Foot_" + (nas_framePadding("##", ($i+1))) + "_Heel_Loc") -p 0 0 0`;
            delete `pointConstraint ("LT_Foot_" + (nas_framePadding("##", ($i+1))) + "_Bind_01_Jnt") $array[0]`;
            setAttr ($array[0] + ".ty") 0;
            $array = `spaceLocator -n ("LT_Foot_" + (nas_framePadding("##", ($i+1))) + "_Toe_Loc") -p 0 0 0`;
            delete `pointConstraint ("LT_Foot_" + (nas_framePadding("##", ($i+1))) + "_Bind_04_Jnt") $array[0]`;
            setAttr ($array[0] + ".ty") 0;
            
            if ($layoutToes) {
                //create left foot joint
                select -r $locs[1] $locs[2];
                $array = `nas_joints ("LT_Ball_" + (nas_framePadding("##", ($i+1))) + "_Bind_##_Jnt") x y y 0`;
                $ballJnt = $array[0];
                setAttr ($ballJnt + ".radius") 5;
                delete $array[1];
                
                $wp = `xform -q -ws -rp $locs[1]`;
                delete (stringArrayRemove({$startLoc, $endLoc}, $locs));
                
                //create toes
                for ($j = 0; $j < $numToes; $j++) {
                    move -ws ((2.7 + ($numToes-1)*.35) - (.7*$j)) .4 $wp[2] $startLoc;
                    move -ws ((2.7 + ($numToes-1)*.35) - (.7*$j)) .4 ($wp[2]+2.8) $endLoc;
                    //move -ws 22.2 33.5 (((-1.2 + (-5*$i)) + ($numToes-1)*.35) - (.7*$j)) $endLoc;
                    select -r $startLoc $endLoc;
                    $locs = `nas_segments ($numToesJoints-2)`;
                    $array = `nas_joints ("LT_Ball_" + (nas_framePadding("##", ($i+1))) + "_Toe_" + (nas_framePadding("##", ($j+1))) + "_Bind_##_Jnt") x y y 0`;
                    delete (stringArrayRemove({$startLoc, $endLoc}, $locs));
                    parent $array[0] $ballJnt;
                }
            }
        }
    }
    
    if ($layoutRest) {
        delete `nas_getTopJoints "Head_*_Bind_01_Jnt"`;
        delete `nas_getTopJoints "Upper_Jaw_*_Bind_01_Jnt"`;
        delete `nas_getTopJoints "Lower_Jaw_*_Bind_01_Jnt"`;
        
        //create head joint
        select -cl;
        $array[0] = `joint -n "Head_01_Bind_01_Jnt"`;
        select -cl;
        $array[1] = `joint -n "Head_01_Bind_02_Jnt"`;
        move -ws 0 38.1 -.90 $array[0];
        move -ws 0 41.4 -.90 $array[1];
        setAttr ($array[0] + ".radius") 3;
        setAttr ($array[1] + ".radius") 3;
        parent $array[1] $array[0];
        
        //create upper jaw joint
        move -ws 0 39 -1.25 $startLoc;
        move -ws 0 39 0.000 $endLoc;
        select -r $startLoc $endLoc;
        $array = `nas_joints "Upper_Jaw_01_Bind_##_Jnt" x y y 0`;
        setAttr ($array[0] + ".radius") 4;
        delete $array[1];
        
        //create lower jaw joint
        move -ws 0 38.7 -.55 $startLoc;
        move -ws 0 38.7 0.00 $endLoc;
        select -r $startLoc $endLoc;
        $array = `nas_joints "Lower_Jaw_01_Bind_##_Jnt" x y y 0`;
        setAttr ($array[0] + ".radius") 2;
        delete $array[1];
    }
    
    delete $startLoc $endLoc;
    select -cl;
    print "auto-rig layout created!";
}

global proc nas_selectAutoRigBindJoints() {
    string $binds[], $joints[];
    $joints = `ls -type joint "*_*_Bind_*_Jnt"`;
    for ($joint in $joints) {
        if (`getAttr ($joint + ".v")`) $binds[size($binds)] = $joint;
    }
    select -r $binds;
}

global proc nas_autoRigUI() {
    global string $nasAutoRigSpineField, $nasAutoRigClavicleField, $nasAutoRigUvulaField, $nasAutoRigTongueField, 
    $nasAutoRigEarField, $nasAutoRigNeckField, 
    $nasAutoRigFingerField, $nasAutoRigFingerJointField, $nasAutoRigToesField, $nasAutoRigToesJointField, 
    $nasAutoRigArmRadios[], $nasAutoRigLegRadios[], 
    $nasAutoRigSpineCheckBox, $nasAutoRigClavicleCheckBox, $nasAutoRigUvulaCheckBox, $nasAutoRigTongueCheckBox, $nasAutoRigEarCheckBox, $nasAutoRigNeckCheckBox, 
    $nasAutoRigFingerCheckBox, $nasAutoRigFingerJointCheckBox, $nasAutoRigToesCheckBox, $nasAutoRigToesJointCheckBox, 
    $nasAutoRigSpineAutoField, $nasAutoRigNeckAutoField, $nasAutoRigEarAutoField, 
    $nasAutoRigArmsCheckBox, $nasAutoRigLegsCheckBox, 
    $nasAutoRigArmsField, $nasAutoRigLegsField;
    
    string $window, $form, $layoutForm,
    $spineCheckBox, $clavicleCheckBox, $uvulaCheckBox, $tongueCheckBox, $earCheckBox, $neckCheckBox, $fingerCheckBox, $fingerJointCheckBox,
    $spineField, $clavicleField, $uvulaField, $tongueField, $earField, $neckField, $fingerField, $fingerJointField, 
    $spineButton, $clavicleButton, $uvulaButton, $tongueButton, $earButton, $neckButton, $fingerButton, $fingerJointButton,
    $mirrorButton, $executeButton, 
    $instructText, $poleText, 
    $armRadioForm, $armCheckBox, 
    $legRadioForm, $legCheckBox, 
    $separator, 
    $spineAutoField, $neckAutoField, $earAutoField, 
    $armsCheckBox, $legsCheckBox, $armsButton, $armsField, $legsField, $legsButton, $toesCheckBox, $toesField, $toesButton, 
    $partsText, $jointsText, $autoText;
    int $fieldWidth, $height, $buttonWidth, $checkBoxWidth;
    
    $fieldWidth = 21;
    $height = 20;
    $buttonWidth = 70;
    $checkBoxWidth = 11;
    $window = `nas_window "nas_autoRigUI" 1 0 1`;
    $form = `formLayout`;
        $partsForm = `formLayout`;
            $partsText = `text -label "Number of each body part:"`;
            $armsCheckBox = `checkBox -label "" -w $checkBoxWidth -h $height -v 1`;
            $armsField = `intField -w $fieldWidth -h $height -v 1`;
            $armsButton = `button -label "Arms" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 0 1 0 0 0 0 1 0 0 1 0"`;
            $fingerCheckBox = `checkBox -label "" -w $checkBoxWidth -h $height -v 1`;
            $fingerField = `intField -w $fieldWidth -h $height -v 5`;
            $fingerButton = `text -label "Fingers" -h $height -w $buttonWidth`; 
            //`button -label "Fingers" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 0 0 0 0 0 0 1 0 0 0 0" -enable 0`;
            $legsCheckBox = `checkBox -label "" -w $checkBoxWidth -h $height -v 1`;
            $legsField = `intField -w $fieldWidth -h $height -v 1`;
            $legsButton = `button -label "Legs" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 0 0 0 0 0 0 0 1 0 0 1"`;
            $toesCheckBox = `checkBox -label "" -w $checkBoxWidth -h $height -v 1`;
            $toesField = `intField -w $fieldWidth -h $height -v 3`;
            $toesButton = `text -label "Toes" -h $height -w $buttonWidth`;
            //`button -label "Toes" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 0 0 0 0 0 0 0 1 0 0 0"`;
            setParent..;
            
        $jointsForm = `formLayout`;
            $jointsText = `text -label "Number of joints per body part:"`;
            $spineCheckBox = `text -label "" -h $height -w $checkBoxWidth`;
            //`checkBox -label "" -w $checkBoxWidth -h $height -v 1 -enable 0`;
            $spineField = `intField -w $fieldWidth -h $height -v 6`;
            $spineButton = `button -label "Spine" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 1 0 0 0 0 0 0 0 0 0 0"`;
            $clavicleCheckBox = `checkBox -label "" -w $checkBoxWidth -h $height -v 1`;
            $clavicleField = `intField -w $fieldWidth -h $height -v 3`;
            $clavicleButton = `text -label "Clavicle" -h $height -w $buttonWidth`;
            //`button -label "Clavicle" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 0 1 0 0 0 0 0 0 0 0 0"`;
            $uvulaCheckBox = `checkBox -label "" -w $checkBoxWidth -h $height -v 1`;
            $uvulaField = `intField -w $fieldWidth -h $height -v 4`;
            $uvulaButton = `button -label "Uvula" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 0 0 1 0 0 0 0 0 0 0 0"`;
            $tongueCheckBox = `checkBox -label "" -w $checkBoxWidth -h $height -v 1`;
            $tongueField = `intField -w $fieldWidth -h $height -v 7`;
            $tongueButton = `button -label "Tongue" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 0 0 0 1 0 0 0 0 0 0 0"`;
            $earCheckBox = `checkBox -label "" -w $checkBoxWidth -h $height -v 1`;
            $earField = `intField -w $fieldWidth -h $height -v 4`;
            $earButton = `button -label "Ear" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 0 0 0 0 1 0 0 0 0 0 0"`;
            $neckCheckBox = `text -label "" -w $checkBoxWidth -h $height`;
            //`checkBox -label "" -w $checkBoxWidth -h $height -v 1`;
            $neckField = `intField -w $fieldWidth -h $height -v 3`;
            $neckButton = `button -label "Neck" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 0 0 0 0 0 1 0 0 0 0 0"`;
            $fingerJointCheckBox = `checkBox -label "" -w $checkBoxWidth -h $height -v 1`;
            $fingerJointField = `intField -w $fieldWidth -h $height -v 4`;
            $fingerJointButton = `text -label "Finger" -h $height -w $buttonWidth`;
            //`button -label "Finger" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 0 0 0 0 0 0 1 0 0 0 0"`;
            $toesJointCheckBox = `checkBox -label "" -w $checkBoxWidth -h $height -v 1`;
            $toesJointField = `intField -w $fieldWidth -h $height -v 4`;
            $toesJointButton = `text -label "Toe" -h $height -w $buttonWidth`;
            //`button -label "Toes" -h $height -w $buttonWidth -c "nas_autoRigUIExecute 0 0 0 0 0 0 0 1 0 0 0"`;
            setParent..;
            
        $autoForm = `formLayout`;
            $autoText = `text -label "Create auto fk ctrl every ## joints:"`;
            $spineAutoField = `intField -w $fieldWidth -h $height -v 1`;
            $spineAutoText = `text -label "Spine" -w $buttonWidth -h $height`;
            $earAutoField = `intField -w $fieldWidth -h $height -v 1`;
            $earAutoText = `text -label "Ear" -w $buttonWidth -h $height`;
            $neckAutoField = `intField -w $fieldWidth -h $height -v 1`;
            $neckAutoText = `text -label "Neck" -w $buttonWidth -h $height`;
            setParent..;

        $buttonForm = `formLayout`;
            $mirrorButton = `button -label "Mirror Joints" -c "nas_mirrorJoints 1"`;
            $executeButton = `button -label "Create Layout" -c "nas_autoRigUIExecute 1 1 1 1 1 1 1 1 1 1 1"`;
            $duplicateButton = `button -label "Duplicate Chain" -c "nas_duplicateLayoutJoints"`;
            setParent..;

        $separator = `separator -style "double"`;
        $poleText = `text -label "Pole Vector Direction:"`;
        $array = `nas_radioCheckBoxGrp "Arms:" 40 {"X", "Y", "Z"} {"", "", "1"} "Negative" 70 {}`;
        $armRadioForm = $array[0];
        $armCheckBox = $array[size($array)-1];
        checkBoxGrp -e -v1 1 $armCheckBox;
        $nasAutoRigArmRadios = $array;
        
        $array = `nas_radioCheckBoxGrp "Legs:" 40 {"X", "Y", "Z"} {"", "", "1"} "Negative" 70 {}`;
        $legRadioForm = $array[0];
        $legCheckBox = $array[size($array)-1];
        $nasAutoRigLegRadios = $array;
        
        $rigButton = `button -label "Auto Rig" -c "nas_assembleUIExecute" -height 25`;
        $selectBindButton = `button -label "Select Bind Joints" -c "nas_selectAutoRigBindJoints"`;
        setParent..;

    formLayout -e 
        -af $executeButton "top" 0
        -af $executeButton "left" 0
        -af $executeButton "right" 0
        -ap $executeButton "bottom" 0 33
        
        -ap $duplicateButton "top" 0 33
        -af $duplicateButton "left" 0
        -af $duplicateButton "right" 0
        -ap $duplicateButton "bottom" 0 66    

        -ap $mirrorButton "top" 0 66
        -af $mirrorButton "left" 0
        -af $mirrorButton "right" 0
        -af $mirrorButton "bottom" 0

        $buttonForm;

    formLayout -e 
        -af $partsText "top" 0
        -af $partsText "left" 5
    
        -ac $armsCheckBox "top" 5 $partsText
        -af $armsCheckBox "left" 5
        
        -ac $armsField "top" 5 $partsText
        -ac $armsField "left" 5 $armsCheckBox
        
        -ac $armsButton "top" 5 $partsText
        -ac $armsButton "left" 5 $armsField
        
        -ac $fingerCheckBox "top" 5 $armsField
        -af $fingerCheckBox "left" 5
        
        -ac $fingerField "top" 5 $armsField
        -ac $fingerField "left" 5 $fingerCheckBox
        
        -ac $fingerButton "top" 5 $armsField
        -ac $fingerButton "left" 5 $fingerField
        
        -ac $legsCheckBox "top" 5 $fingerField
        -af $legsCheckBox "left" 5
        
        -ac $legsField "top" 5 $fingerField
        -ac $legsField "left" 5 $legsCheckBox
        
        -ac $legsButton "top" 5 $fingerField
        -ac $legsButton "left" 5 $legsField
        
        -ac $toesCheckBox "top" 5 $legsField
        -af $toesCheckBox "left" 5
        
        -ac $toesField "top" 5 $legsField
        -ac $toesField "left" 5 $toesCheckBox
        
        -ac $toesButton "top" 5 $legsField
        -ac $toesButton "left" 5 $toesField

        $partsForm;
        
    formLayout -e 
        -af $jointsText "top" 0
        -af $jointsText "left" 5
        
        -ac $earCheckBox "top" 5 $jointsText
        -af $earCheckBox "left" 5
        
        -ac $earField "top" 5 $jointsText
        -ac $earField "left" 5 $earCheckBox
        
        -ac $earButton "top" 5 $jointsText
        -ac $earButton "left" 5 $earField
        
        -ac $uvulaCheckBox "top" 5 $earField
        -af $uvulaCheckBox "left" 5
        
        -ac $uvulaField "top" 5 $earField
        -ac $uvulaField "left" 5 $uvulaCheckBox
        
        -ac $uvulaButton "top" 5 $earField
        -ac $uvulaButton "left" 5 $uvulaField
        
        -ac $tongueCheckBox "top" 5 $uvulaField
        -af $tongueCheckBox "left" 5
        
        -ac $tongueField "top" 5 $uvulaField
        -ac $tongueField "left" 5 $tongueCheckBox
        
        -ac $tongueButton "top" 5 $uvulaField
        -ac $tongueButton "left" 5 $tongueField
        
        -ac $neckCheckBox "top" 5 $tongueField
        -af $neckCheckBox "left" 5
        
        -ac $neckField "top" 5 $tongueField
        -ac $neckField "left" 5 $neckCheckBox
        
        -ac $neckButton "top" 5 $tongueField
        -ac $neckButton "left" 5 $neckField
    
        -ac $spineCheckBox "top" 5 $neckField
        -af $spineCheckBox "left" 5 
    
        -ac $spineField "top" 5 $neckField
        -ac $spineField "left" 5 $spineCheckBox
        
        -ac $spineButton "top" 5 $neckField
        -ac $spineButton "left" 5 $spineField
        
        -ac $clavicleCheckBox "top" 5 $spineField
        -af $clavicleCheckBox "left" 5
        
        -ac $clavicleField "top" 5 $spineField
        -ac $clavicleField "left" 5 $clavicleCheckBox
        
        -ac $clavicleButton "top" 5 $spineField
        -ac $clavicleButton "left" 5 $clavicleField
        
        -ac $fingerJointCheckBox "top" 5 $clavicleField
        -af $fingerJointCheckBox "left" 5
        
        -ac $fingerJointField "top" 5 $clavicleField
        -ac $fingerJointField "left" 5 $fingerJointCheckBox
        
        -ac $fingerJointButton "top" 5 $clavicleField
        -ac $fingerJointButton "left" 5 $fingerJointField
        
        -ac $toesJointCheckBox "top" 5 $fingerJointField
        -af $toesJointCheckBox "left" 5
        
        -ac $toesJointField "top" 5 $fingerJointField
        -ac $toesJointField "left" 5 $toesJointCheckBox
        
        -ac $toesJointButton "top" 5 $fingerJointField
        -ac $toesJointButton "left" 5 $toesJointField
        
        $jointsForm;
    
    formLayout -e 
        -af $autoText "top" 0
        -af $autoText "left" 5
        
        -ac $spineAutoField "top" 5 $autoText
        -af $spineAutoField "left" 5
        
        -ac $spineAutoText "top" 5 $autoText
        -ac $spineAutoText "left" 5 $spineAutoField
        
        -ac $earAutoField "top" 5 $spineAutoField
        -af $earAutoField "left" 5
        
        -ac $earAutoText "top" 5 $spineAutoField
        -ac $earAutoText "left" 5 $earAutoField
        
        -ac $neckAutoField "top" 5 $earAutoField
        -af $neckAutoField "left" 5 
        
        -ac $neckAutoText "top" 5 $earAutoField
        -ac $neckAutoText "left" 5 $neckAutoField
        
        $autoForm;
        
    formLayout -e
        -af $partsForm "top" 5
        -af $partsForm "left" 0
        -ap $partsForm "right" 0 46

        -ac $jointsForm "top" 5 $partsForm
        -af $jointsForm "left" 0
        -ap $jointsForm "right" 0 46

        -af $autoForm "top" 5
        -ac $autoForm "left" 5 $jointsForm
        -af $autoForm "right" 5

        -ac $buttonForm "top" 5 $autoForm
        -ac $buttonForm "left" 5 $jointsForm 
        -af $buttonForm "right" 5
        -ac $buttonForm "bottom" 5 $separator 

        -ac $separator "top" 5 $jointsForm 
        -af $separator "left" 5 
        -af $separator "right" 5 

        -ac $poleText "top" 10 $separator 
        -af $poleText "left" 5 

        -ac $armRadioForm "top" 5 $poleText 
        -af $armRadioForm "left" 5 
        -af $armRadioForm "right" 5 

        -ac $legRadioForm "top" 5 $armRadioForm 
        -af $legRadioForm "left" 5 
        -af $legRadioForm "right" 5 
        
        -ac $rigButton "top" 5 $legRadioForm
        -af $rigButton "left" 5
        -ap $rigButton "right" 0 50
        -af $rigButton "bottom" 5
        
        -ac $selectBindButton "top" 5 $legRadioForm
        -ap $selectBindButton "left" 0 50
        -af $selectBindButton "right" 5
        -af $selectBindButton "bottom" 5    

        $form;
    
    $nasAutoRigSpineField = $spineField;
    $nasAutoRigClavicleField = $clavicleField;
    $nasAutoRigUvulaField = $uvulaField;
    $nasAutoRigTongueField = $tongueField;
    $nasAutoRigEarField = $earField;
    $nasAutoRigNeckField = $neckField;
    $nasAutoRigFingerField = $fingerField;
    $nasAutoRigFingerJointField = $fingerJointField;
    $nasAutoRigToesField = $toesField;
    $nasAutoRigToesJointField = $toesJointField;
    
    $nasAutoRigSpineCheckBox = $spineCheckBox;
    $nasAutoRigClavicleCheckBox = $clavicleCheckBox;
    $nasAutoRigUvulaCheckBox = $uvulaCheckBox;
    $nasAutoRigTongueCheckBox = $tongueCheckBox;
    $nasAutoRigEarCheckBox = $earCheckBox;
    $nasAutoRigNeckCheckBox = $neckCheckBox;
    $nasAutoRigFingerCheckBox = $fingerCheckBox;
    $nasAutoRigFingerJointCheckBox = $fingerJointCheckBox;
    $nasAutoRigToesCheckBox = $toesCheckBox;
    $nasAutoRigToesJointCheckBox = $toesJointCheckBox;
    
    $nasAutoRigSpineAutoField = $spineAutoField;
    $nasAutoRigNeckAutoField = $neckAutoField;
    $nasAutoRigEarAutoField = $earAutoField;
    
    $nasAutoRigArmsCheckBox = $armsCheckBox;
    $nasAutoRigLegsCheckBox = $legsCheckBox;
    $nasAutoRigArmsField = $armsField;
    $nasAutoRigLegsField = $legsField;
    
    //295 575
    window -e -wh 330 490 $window;
    showWindow $window;    
}

/*
int $layoutSpine = 1;
int $layoutClavicle = 1;
int $layoutUvula = 1;
int $layoutTongue = 1;
int $layoutEar = 1;
int $layoutNeck = 1;
int $layoutFingers = 1;
int $layoutRest = 1;
int $layoutArms = 1;
int $layoutLegs = 1;
*/
global proc nas_autoRigUIExecute(int $layoutSpine, int $layoutClavicle, int $layoutUvula, int $layoutTongue, int $layoutEar, int $layoutNeck, int $layoutFingers, int $layoutToes, int $layoutRest, int $layoutArms, int $layoutLegs) {
    global string $nasAutoRigSpineField, $nasAutoRigClavicleField, $nasAutoRigUvulaField, $nasAutoRigTongueField, 
    $nasAutoRigEarField, $nasAutoRigNeckField, $nasAutoRigFingerField, $nasAutoRigFingerJointField, $nasAutoRigToesField, $nasAutoRigToesJointField, $nasAutoRigArmsField, $nasAutoRigLegsField, 
    $nasAutoRigSpineCheckBox, $nasAutoRigClavicleCheckBox, $nasAutoRigUvulaCheckBox, $nasAutoRigTongueCheckBox, 
    $nasAutoRigEarCheckBox, $nasAutoRigNeckCheckBox, $nasAutoRigFingerCheckBox, $nasAutoRigFingerJointCheckBox, $nasAutoRigToesCheckBox, $nasAutoRigToesJointCheckBox, $nasAutoRigArmsCheckBox, $nasAutoRigLegsCheckBox;
    
    int $spine, $uvula, $tongue, $ear, $neck, $finger, $fingerJoint, $spineToggle, $clavicleToggle, $uvulaToggle, $tongueToggle, 
    $earToggle, $neckToggle, $fingerToggle, $fingerJointToggle, $armsToggle, $legsToggle;
    
    $spine = `intField -q -v $nasAutoRigSpineField`;
    $clavicle = `intField -q -v $nasAutoRigClavicleField`;
    $uvula = `intField -q -v $nasAutoRigUvulaField`;
    $tongue = `intField -q -v $nasAutoRigTongueField`;
    $ear = `intField -q -v $nasAutoRigEarField`;
    $neck = `intField -q -v $nasAutoRigNeckField`;
    $finger = `intField -q -v $nasAutoRigFingerField`;
    $fingerJoint = `intField -q -v $nasAutoRigFingerJointField`;
    $toes = `intField -q -v $nasAutoRigToesField`;
    $toesJoint = `intField -q -v $nasAutoRigToesJointField`;
    $arms = `intField -q -v $nasAutoRigArmsField`;
    $legs = `intField -q -v $nasAutoRigLegsField`;
    
    $spineToggle = 1;
    //$spineToggle = `checkBox -q -v $nasAutoRigSpineCheckBox`;
    $clavicleToggle = `checkBox -q -v $nasAutoRigClavicleCheckBox`;
    $uvulaToggle = `checkBox -q -v $nasAutoRigUvulaCheckBox`;
    $tongueToggle = `checkBox -q -v $nasAutoRigTongueCheckBox`;
    $earToggle = `checkBox -q -v $nasAutoRigEarCheckBox`;
    $neckToggle = 1;
    //$neckToggle = `checkBox -q -v $nasAutoRigNeckCheckBox`;
    $fingerToggle = `checkBox -q -v $nasAutoRigFingerCheckBox`;
    $fingerJointToggle = `checkBox -q -v $nasAutoRigFingerJointCheckBox`;
    $toesToggle = `checkBox -q -v $nasAutoRigToesCheckBox`;
    $toesJointToggle = `checkBox -q -v $nasAutoRigToesJointCheckBox`;
    $armsToggle = `checkBox -q -v $nasAutoRigArmsCheckBox`;
    $legsToggle = `checkBox -q -v $nasAutoRigLegsCheckBox`;
    
    if ($spineToggle == 0) $layoutSpine = 0;
    if ($clavicleToggle == 0) $layoutClavicle = 0;
    if ($uvulaToggle == 0) $layoutUvula = 0;
    if ($tongueToggle == 0) $layoutTongue = 0;
    if ($earToggle == 0) $layoutEar = 0;
    if ($neckToggle == 0) $layoutNeck = 0;
    if ($fingerJointToggle == 0) $layoutFingers = 0;
    if ($toesJointToggle == 0) $layoutToes = 0;
    if ($fingerToggle == 0) $layoutFingers = 0;
    if ($toesToggle == 0) $layoutToes = 0;
    if ($armsToggle == 0) $layoutArms = 0;
    if ($legsToggle == 0) $layoutLegs = 0;

    nas_createLayout $spine $clavicle $uvula $tongue $ear $neck $finger $fingerJoint $toes $toesJoint $arms $legs $layoutSpine $layoutClavicle $layoutUvula $layoutTongue $layoutEar $layoutNeck $layoutFingers $layoutToes $layoutRest $layoutArms $layoutLegs;
    if (($layoutSpine + $layoutClavicle + $layoutUvula + $layoutTongue + $layoutEar + $layoutNeck + $layoutFingers + $layoutToes + $layoutArms + $layoutLegs) == 10) {
        select -cl;
        nas_mirrorJoints 1;
    } else if ($layoutArms || $layoutLegs) {
        select -cl;
        nas_mirrorJoints 1;
    }
}

global proc nas_assembleUIExecute() {
    global string $nasAutoRigArmRadios[], $nasAutoRigLegRadios[], $nasAutoRigSpineAutoField, $nasAutoRigNeckAutoField, $nasAutoRigEarAutoField;;
    
    string $armAxis, $legAxis, $path, $parts[], $name, $oldName;
    vector $axisVector;
    int $x, $y, $z, $go, $spineAuto, $neckAuto, $earAuto;
    
    $oldName = `file -q -sn`;
    if (size($oldName)) {
        $parts = stringToStringArray($oldName, "/");
        $parts = stringArrayRemove({$parts[size($parts)-1]}, $parts);
                if ($parts[0] == "nasburbank") {
                    $parts[0] = "//nasburbank";
                }
        $path = stringArrayToString($parts, "/");
        $name = ($path + "/rig_placement.ma");
        file -rename $name;
        file -s;
        file -rename $oldName;
        $go = 1;
    } else {
        if (`confirmDialog -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -message "You have not saved your layout file. Continue?"` == "OK") $go = 1;
    }
    
    $x = `radioButton -q -select $nasAutoRigArmRadios[1]`;
    $y = `radioButton -q -select $nasAutoRigArmRadios[2]`;
    $z = `radioButton -q -select $nasAutoRigArmRadios[3]`;
    $axisVector = <<$x, $y, $z>>;
    $armAxis = `nas_vectorToAxis $axisVector`;

    $x = `radioButton -q -select $nasAutoRigLegRadios[1]`;
    $y = `radioButton -q -select $nasAutoRigLegRadios[2]`;
    $z = `radioButton -q -select $nasAutoRigLegRadios[3]`;
    $axisVector = <<$x, $y, $z>>;
    $legAxis = `nas_vectorToAxis $axisVector`;
    
    if (`checkBoxGrp -q -v1 $nasAutoRigArmRadios[4]`) $armAxis = ("-" + $armAxis);
    if (`checkBoxGrp -q -v1 $nasAutoRigLegRadios[4]`) $legAxis = ("-" + $legAxis);
    
    $spineAuto = `intField -q -v $nasAutoRigSpineAutoField`;
    $neckAuto = `intField -q -v $nasAutoRigNeckAutoField`;
    $earAuto = `intField -q -v $nasAutoRigEarAutoField`;
    
    if ($go) nas_assembleSystems $armAxis $legAxis $spineAuto $neckAuto $earAuto;
}

//-------------------------------------------------------------nas_duplicateLayoutJoints---------------------------------------------------------------------
//duplicates joints created at layout stage
global proc nas_duplicateLayoutJoints() {
    string $topJoints[], $duplicateJoints[], $newNameParts[], $array[], $newName, $joints[];
    int $num, $nums[];
    
    $topJoints = `ls -sl`;
    
    for ($topJoint in $topJoints) {
        $array = stringToStringArray($topJoint, "_");
        for ($i = 0; $i < size($array); $i++) {
            if ($array[$i] == "Bind") if ($array[$i+1] != "01") error ("Please select the top level joint for " + $topJoint);
        }
    }
    
    for ($topJoint in $topJoints) {
        clear $nums;
        $duplicateJoints = `duplicate -rc $topJoint`;
        $array = stringToStringArray($topJoint, "_");
        for ($i = 0; $i < size($array); $i++) {
            if ($array[$i] == "Bind") {
                $newNameParts[$i-1] = "";
                break;
            } else {
                $newNameParts[$i] = $array[$i];
            }
        }
        
        $newName = stringArrayToString($newNameParts, "_");
        $joints = `ls ($newName + "*_Bind_01_Jnt")`;
        for ($i = 0; $i < size($joints); $i++) {
            $array = stringToStringArray($joints[$i], "_");
            for ($j = 0; $j < size($array); $j++) {
                if ($array[$j] == "Bind") $nums[size($nums)] = $array[$j-1];
            }
        }
        $nums = `sort $nums`;
        $newName = `nas_framePadding ($newName + "##_Bind") ($nums[size($nums)-1] + 1)`;
        for ($i = 0; $i < size($duplicateJoints); $i++) {
            $duplicateJoints[$i] = `rename $duplicateJoints[$i] ($newName + "_" + nas_framePadding("##", ($i+1)) + "_Jnt")`;
        }
        move -r -os 0 0 -1 $duplicateJoints[0];
    }
}

//-------------------------------------------------------------nas_getTopJoints---------------------------------------------------------------------
global proc string[] nas_getTopJoints(string $searchString) {
    string $allJoints[], $topJoints[];
    
    $allJoints = `ls -type joint $searchString`;
    for ($allJoint in $allJoints) {
        //$array = `listRelatives -p $allJoint`;
        //if (size($array) == 0) $topJoints[size($topJoints)] = $allJoint;
        
        $array = stringToStringArray($allJoint, "_");
        for ($i = 0; $i < size($array); $i++) {
            if ($array[$i] == "Bind" && $array[$i+1] == "01") {
                $topJoints[size($topJoints)] = $allJoint;
                break;
            }
        }
    }
    return $topJoints;
}

//-------------------------------------------------------------nas_rigFKFromBind---------------------------------------------------------------------
global proc string[] nas_rigFKFromBind(string $topJoint, int $auto, int $showLast) {
    string $array[], $name, $parts[];
    
    select -r $topJoint;
    $array = stringToStringArray($topJoint, "_");
    for ($item in $array) {
        if ($item == "Bind") break;
        else $parts[size($parts)] = $item;
    }
    $name = stringArrayToString($parts, "_");
    
    $array = `nas_rigFK $name $auto 0 "" $showLast`;
    return $array;
}

//-------------------------------------------------------------nas_getNameFromBind---------------------------------------------------------------------
global proc string nas_getNameFromBind(string $topJoint) {
    string $array[], $name, $parts[];
    
    select -r $topJoint;
    $array = stringToStringArray($topJoint, "_");
    for ($item in $array) {
        if ($item == "Bind") break;
        else $parts[size($parts)] = $item;
    }
    $name = stringArrayToString($parts, "_");
    return $name;
}

//-------------------------------------------------------------nas_mirrorJoints---------------------------------------------------------------------
global proc nas_mirrorJoints(int $flip) {
    string $sels[], $allJoints[], $topJoints[], $array[], $joints[], $locs[], $scaleGroup, $mirrorJoints[], $aimLoc, $upLoc, $mirrorName, $parents[];
    clear $topJoints;

    $sels = `ls -sl`;
    if (size($sels) == 0) {
        $allJoints = `ls -type joint "LT_*_Jnt"`;
        $array = `ls -type locator "LT_*_LocShape"`;
        $allJoints = stringArrayCatenate(`listRelatives -p $array`, $allJoints);
        for ($allJoint in $allJoints) {
            $array = `listRelatives -p $allJoint`;
            if (size($array) == 0) $topJoints[size($topJoints)] = $allJoint;
        }
    } else {
        $topJoints = `ls -sl`;
    }
    for ($i = 0; $i < size($topJoints); $i++) {
        $array = stringToStringArray ($topJoints[$i], "_");
        $array[0] = "RT";
        $mirrorName = stringArrayToString($array, "_");
        if (`objExists $mirrorName`) delete $mirrorName;

        clear $joints;
        clear $mirrorJoints;

        $joints[0] = $topJoints[$i];
        $array = `listRelatives -ad -type joint $joints[0]`;
        $joints = stringArrayCatenate($joints, $array);
        //for ($j = size($array)-1; $j >= 0; $j--) $joints[size($joints)] = $array[$j];

        for ($j = 0; $j < size($joints); $j++) {
            $array = `listRelatives -p $joints[$j]`;
            $parents[$j] = $array[0];
        }

        select -r $joints;
        $locs = `nas_locator 1`;
        $scaleGroup = `group -em`;
        parent $locs $scaleGroup;
        setAttr ($scaleGroup + ".sx") -1;
        for ($j = 0; $j < size($joints); $j++) {
            parent -w $locs[$j];
            $array = stringToStringArray ($joints[$j], "_");
            $array = stringArrayRemove({$array[0]}, $array);
            select -cl;
            if (`nodeType $joints[$j]` == "joint") {
                $mirrorJoints[$j] = `joint -n ("RT_" + stringArrayToString($array, "_")) -p 0 0 0`;
                setAttr ($mirrorJoints[$j] + ".radius") `getAttr ($joints[$j] + ".radius")`;
            } else {
                $array = `spaceLocator -n ("RT_" + stringArrayToString($array, "_")) -p 0 0 0`;
                $mirrorJoints[$j] = $array[0];
            }
            if ($flip) {
                $array = `duplicate $locs[$j]`;
                $aimLoc = $array[0];
                move -r -os 0 0 -1 $aimLoc;
                $array = `duplicate $locs[$j]`;
                $upLoc = $array[0];
                move -r -os 0 -1 0 $upLoc;
                delete `pointConstraint $locs[$j] $mirrorJoints[$j]`;
                delete `aimConstraint -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "object" -worldUpObject $upLoc $aimLoc $mirrorJoints[$j]`;
                delete $aimLoc $upLoc;
            } else {
                delete `parentConstraint $locs[$j] $mirrorJoints[$j]`;
            }
        }
        delete $locs $scaleGroup;
        for ($j = 0; $j < size($parents); $j++) {
            $array = stringToStringArray($parents[$j], "_");
            $array[0] = "RT";
            $parents[$j] = stringArrayToString($array, "_");
        }
        for ($j = 0; $j < size($mirrorJoints); $j++) {
            if (`objExists $parents[$j]`) catchQuiet(`parent $mirrorJoints[$j] $parents[$j]`);
            makeIdentity -apply true -t 1 -r 1 -s 1 $mirrorJoints[$j];
        }
        makeIdentity -apply true -t 1 -r 1 -s 1 $mirrorJoints[0];
    }
}

//-------------------------------------------------------------nas_flipJoints---------------------------------------------------------------------
global proc nas_flipJoints(string $aimAxis, string $upAxis) {
    string $sels[], $allJoints[], $topJoints[], $array[], $joints[], $locs[], $scaleGroup, $mirrorJoints[], $aimLoc, $upLoc, $mirrorName;
    float $aimAxisVals[], $upAxisVals[];

    $aimAxisVals = `nas_axisToVector $aimAxis`;
    $upAxisVals = `nas_axisToVector $upAxis`;

    $topJoints = `ls -sl`;
    for ($i = 0; $i < size($topJoints); $i++) {
        clear $joints;
        $joints[0] = $topJoints[$i];
        $array = `listRelatives -ad -type joint $joints[0]`;
        for ($j = size($array)-1; $j >= 0; $j--) $joints[size($joints)] = $array[$j];
        select -r $joints;
        $locs = `nas_locator 1`;
        for ($j = 1; $j < size($joints); $j++) parent -w $joints[$j];

        for ($j = 0; $j < size($joints); $j++) {
            $array = `duplicate $locs[$j]`;
            $aimLoc = $array[0];
            move -r -os (-1*$aimAxisVals[0]) (-1*$aimAxisVals[1]) (-1*$aimAxisVals[2]) $aimLoc;
            $array = `duplicate $locs[$j]`;
            $upLoc = $array[0];
            move -r -os (-1*$upAxisVals[0]) (-1*$upAxisVals[1]) (-1*$upAxisVals[2]) $upLoc;
            delete `pointConstraint $locs[$j] $joints[$j]`;
            delete `aimConstraint -weight 1 -aimVector $aimAxisVals[0] $aimAxisVals[1] $aimAxisVals[2] -upVector $upAxisVals[0] $upAxisVals[1] $upAxisVals[2] -worldUpType "object" -worldUpObject $upLoc $aimLoc $joints[$j]`;
            delete $aimLoc $upLoc;
        }
        for ($j = 1; $j < size($mirrorJoints); $j++) {
            parent $mirrorJoints[$j] $mirrorJoints[$j-1];
            makeIdentity -apply true -t 1 -r 1 -s 1 $mirrorJoints[$j];
        }
        makeIdentity -apply true -t 1 -r 1 -s 1 $mirrorJoints[0];
    }
    select -r $topJoints;
}

//-------------------------------------------------------------nas_rigHand---------------------------------------------------------------------
global proc string[] nas_rigHand(string $name, string $axis) {
    string $sels[], $array[], $handJnt, $fingerJnts[], $fingerJntGroups[], $fingerCtrlGroups[], $ctrls[], 
    $handJntGroup, $ctrlGroup, $handCtrl, $handCtrlGroup, $joints[], $cupJnt, $cupFingerJnts[], 
    $fingerMasterLocs[], $cupMasterLoc, $cupFingerMasterLocs[], $side, $shapes[], $cvs[];
    int $isCup;
    float $pivots[];

    clear $fingerJnts;
    
    $array = `ls -sl`;
    $handJnt = $array[0];
    $joints = `listRelatives -c -type joint $handJnt`;

    $array = stringToStringArray($name, "_");
    $side = $array[0];
    
    for ($joint in $joints) {
        $isCup = 0;
        $array = stringToStringArray($joint, "_");
        for ($item in $array) {
            if ($item == "Cup") {
                $isCup = 1;
                break;
            }
        }
        if ($isCup) {
            $cupJnt = $joint;
            $array = `listRelatives -c -type joint $cupJnt`;
            $cupFingerJnts = `listRelatives -c -type joint $cupJnt`;
        } else {
            $fingerJnts[size($fingerJnts)] = $joint;
        }
    }
    
    for ($i = 0; $i < size($fingerJnts); $i++) {
        select -r $fingerJnts[$i];
        $array = `nas_rigFK ($name + "_Finger_" + nas_framePadding("##", ($i+1))) 0 1 $axis 0`;
        $fingerJntGroups[$i] = $array[0];
        $fingerCtrlGroups[$i] = $array[1];
        $fingerMasterLocs[$i] = $array[2];
        $array = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
        select -r $array;
        $ctrls = `nas_controls "surfaceSinglePin"`;
        scale -r 2.75 2.75 2.75;
        for ($j = 0; $j < size($ctrls); $j++) {
            $ctrls[$j] = `rename $ctrls[$j] ("singlePin" + ($i+1))`;
            setAttr -type "string" ($ctrls[$j] + ".nickCtrlType") "char";
        }
        select -r $ctrls $array;
        nas_massParentShape 1;
    }
    
    select -r $handJnt;
    $array = `nas_group 0 "Group"`;
    $handJntGroup = $array[0];
    
    select -r $handJnt;
    $array = `nas_controls "surfaceCone"`;
    setAttr -type "string" ($array[0] + ".nickCtrlType") "char";
    $handCtrl = $array[0];
    nas_colorControls "green" 1;
    nas_shadeControls "green";
    $array = `nas_group 0 Group`;
    $handCtrlGroup = $array[0];
    
    $pivots = `xform -q -ws -rp $handJnt`;
    if ($side == "RT") {
        rotate -r -p $pivots[0] $pivots[1] $pivots[2] -os 0 0 90 ($handCtrl + ".cv[0:3][0:7]");
        move -r -os -wd -8.5 0 0 ($handCtrl + ".cv[0:3][0:7]");
    } else {
        rotate -r -p $pivots[0] $pivots[1] $pivots[2] -os 0 0 -90 ($handCtrl + ".cv[0:3][0:7]");
        move -r -os -wd 8.5 0 0 ($handCtrl + ".cv[0:3][0:7]");
    }
    
    parentConstraint -mo $handCtrl $handJnt;
    scaleConstraint -mo $handCtrl $handJnt;

    select -r $handJnt $fingerMasterLocs;
    nas_massConstrain 0 "parent" 1;
    nas_massConstrain 0 "scale" 1;

    parent $fingerJntGroups $handJntGroup;
    parent $fingerMasterLocs $fingerCtrlGroups $handCtrlGroup;

    if (size($cupJnt)) {
        if (size($cupFingerJnts)) {
            for ($joint in $cupFingerJnts) parent -w $joint;
        }

        select -r $cupJnt;
        $array = `nas_rigFK ($name + "_Cup_01") 0 1 $axis 0`;
        $cupJntGroup = $array[0];
        $cupCtrlGroup = $array[1];
        $cupMasterLoc = $array[2];
        $array = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
        select -r $array;
        $ctrls = `nas_controls "surfaceSinglePin"`;
        scale -r 5 5 5;
        for ($j = 0; $j < size($ctrls); $j++) {
            $ctrls[$j] = `rename $ctrls[$j] ("singlePin" + ($i+1))`;
            setAttr -type "string" ($ctrls[$j] + ".nickCtrlType") "char";
        }
        select -r $ctrls $array;
        nas_massParentShape 1;
                
        parentConstraint -mo $handJnt $cupMasterLoc;
        scaleConstraint -mo $handJnt $cupMasterLoc;
        parent $cupJntGroup $handJntGroup;
        parent $cupMasterLoc $cupCtrlGroup $handCtrlGroup;
    }
    if (size($cupFingerJnts)) {
        for ($i = 0; $i < size($cupFingerJnts); $i++) {
            select -r $cupFingerJnts[$i];
            $array = `nas_rigFK ($name + "_Finger_" + nas_framePadding("##", ($i+size($fingerJnts)+1))) 0 1 $axis 0`;
            $cupFingerJntGroups[$i] = $array[0];
            $cupFingerCtrlGroups[$i] = $array[1];
            $cupFingerMasterLocs[$i] = $array[2];
            $array = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
            select -r $array;
            $ctrls = `nas_controls "surfaceSinglePin"`;
            scale -r 2.75 2.75 2.75;
            for ($j = 0; $j < size($ctrls); $j++) {
                $ctrls[$j] = `rename $ctrls[$j] ("singlePin" + ($i+1))`;
                setAttr -type "string" ($ctrls[$j] + ".nickCtrlType") "char";
            }
            select -r $ctrls $array;
            nas_massParentShape 1;

            parentConstraint -mo $cupJnt $cupFingerMasterLocs[$i];
            scaleConstraint -mo $cupJnt $cupFingerMasterLocs[$i];
            parent $cupFingerJntGroups $handJntGroup;
            parent $cupFingerMasterLocs $cupFingerCtrlGroups $handCtrlGroup;
        }
    }
    
    if ($side == "RT") {
        $ctrls = `ls ($name + "_Finger_*_FK_*_Ctrl")`;
        $ctrls = stringArrayCatenate(`ls ($name + "_Cup_01_FK_*_Ctrl")`, $ctrls);
        for ($ctrl in $ctrls) {
            $pivots = `xform -ws -q -rp $ctrl`;
            $shapes = `listRelatives -c -s -fullPath $ctrl`;
            for ($j = 0; $j < size($shapes); $j++) {
                $array = `ls ($shapes[$j] + ".cv[*:*][*:*]")`;
                $cvs[$j] = $array[0];
            }
            if (size($shapes)) scale -r -p $pivots[0] $pivots[1] $pivots[2] -1 -1 -1 $cvs;
        }
    }
    
    setAttr -lock 1 -keyable 0 ($handCtrl + ".v");
    delete -ch $handCtrl;
    
    return {$handJntGroup, $handCtrlGroup, $handCtrl}; 
}

//-------------------------------------------------------------nas_rigToes---------------------------------------------------------------------
global proc string[] nas_rigToes(string $name, string $axis) {
    string $sels[], $array[], $handJnt, $fingerJnts[], $fingerJntGroups[], $fingerCtrlGroups[], $ctrls[], 
    $handJntGroup, $ctrlGroup, $handCtrl, $handCtrlGroup, $joints[], $cupJnt, $cupFingerJnts[], 
    $fingerMasterLocs[], $cupMasterLoc, $cupFingerMasterLocs[], $side, $shapes[], $cvs[], $joint;
    int $isCup;
    float $pivots[];

    $fingerJnts = `listRelatives -c -type joint`;
    
    $array = stringToStringArray($name, "_");
    $side = $array[0];

    for ($i = 0; $i < size($fingerJnts); $i++) {
        select -r $fingerJnts[$i];
        $array = `nas_rigFK ($name + "_Toe_" + nas_framePadding("##", ($i+1))) 0 1 $axis 0`;
        $fingerJntGroups[$i] = $array[0];
        $fingerCtrlGroups[$i] = $array[1];
        $fingerMasterLocs[$i] = $array[2];
        $array = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
        select -r $array;
        $ctrls = `nas_controls "surfaceSinglePin"`;
        scale -r 2.75 2.75 2.75;
        for ($j = 0; $j < size($ctrls); $j++) {
            $ctrls[$j] = `rename $ctrls[$j] ("singlePin" + ($i+1))`;
            setAttr -type "string" ($ctrls[$j] + ".nickCtrlType") "char";
        }
        select -r $ctrls $array;
        nas_massParentShape 1;
    }
    
    if ($side == "RT") {
        $ctrls = `ls ($name + "_Toe_*_FK_*_Ctrl")`;
        for ($ctrl in $ctrls) {
            $pivots = `xform -ws -q -rp $ctrl`;
            $shapes = `listRelatives -c -s -fullPath $ctrl`;
            for ($j = 0; $j < size($shapes); $j++) {
                $array = `ls ($shapes[$j] + ".cv[*:*][*:*]")`;
                $cvs[$j] = $array[0];
            }
            if (size($shapes)) scale -r -p $pivots[0] $pivots[1] $pivots[2] -1 -1 -1 $cvs;
        }
    }
    
    $handCtrlGroup = `group -em -n ($name + "_Toe_FK_Ctrl_Group")`;
    $handJntGroup = `group -em -n ($name + "_Toe_FK_Jnt_Group")`;

    parent $fingerJntGroups $handJntGroup;
    parent $fingerMasterLocs $fingerCtrlGroups $handCtrlGroup;
    
    return (stringArrayCatenate({$handJntGroup, $handCtrlGroup}, $fingerMasterLocs));
}


//-------------------------------------------------------------nas_rigLimb---------------------------------------------------------------------
global proc string[] nas_rigLimb(string $name, string $poleDir, int $world) {
    string $array[], $rkJoints[], $bndJoints[], $fkJoints[], $ikJoints[], $upperJoints[], $lowerJoints[], $constraints[], $scaleconstraints[], $reverse, $fkJointGroup, 
    $fkCtrlGroup, $fkCtrls[], $joints[], $bndGroups[], $loc, $midCtrl, $midCtrlGroup, $midGroup, $wristUpLoc, $shoulderUpLoc, $wristTwistLoc, $shoulderTwistLoc, $wristTwistGroup, 
    $shoulderTwistGroup, $ikCtrl, $ikCtrlGroup, $ikDeformGroup, $ikNull, $mdn, $bndJointGroup, $ikJointGroup, $ikClav, $ikClavGroup, $dist1Loc, $upperStart, $upperEnd, 
    $upperJointGroup, $upperDeformerGroup, $lowerStart, $lowerEnd, $lowerJointGroup, $lowerDeformerGroup, $upperStartGroup, $upperEndGroup, $lowerStartGroup, 
    $lowerEndGroup, $constraint, $locs[], $pma, $names[], $startEndJoints[], $bndDeformerGroup, $ctrlGroup, $jointGroup, $deformerGroup, $ikScaleMD, $upperScaleMD, $lowerScaleMD, $midTwistGroup, 
    $dist, $mid1Loc, $mid1LocGroup, $mid2Loc, $mid2LocGroup, $shoulderJnt, $shoulderJntGroup, 
    $upperStartUpLoc, $upperEndUpLoc, $lowerStartUpLoc, $lowerEndUpLoc,
    $upperStartUpLocGroup, $upperEndUpLocGroup, $lowerStartUpLocGroup, $lowerEndUpLocGroup, $lowerEndTwistCtrl, $lowerEndTwistCtrlGroup,
    $fkMasterLoc, $masterLoc, $blender, $midAutoTwistLoc, $midAutoTwistLocGroup, $midScaleMD, 
    $lowerStartTwistLoc, $midLoc, $poleVectorCtrl, $masterPivot, $masterNull, 
    $upperTwistFalloffSR, $lowerTwistFalloffSR;

    float $lowestDist, $value;    

    clear $rkJoints;
    
    //......................................get rk joints......................................
    $array = `ls -sl`;
    $array = stringArrayCatenate(`listRelatives -ad -type joint $array[0]`, $array);
    for ($i = size($array)-1; $i >= 0; $i--) $rkJoints[size($rkJoints)] = $array[$i];
    
    //......................................duplicate and rename rk joints for fk and ik......................................
    $fkJoints = `duplicate -rc $rkJoints[0]`;
    $ikJoints = `duplicate -rc $rkJoints[0]`;
    for ($i = 0; $i < size($rkJoints); $i++) {
        $rkJoints[$i] = `rename $rkJoints[$i] ($name + "_RK_" + nas_framePadding("##", ($i+1)) + "_Jnt")`;
        $fkJoints[$i] = `rename $fkJoints[$i] ($name + "_FK_" + nas_framePadding("##", ($i+1)) + "_Jnt")`;
        $ikJoints[$i] = `rename $ikJoints[$i] ($name + "_IK_" + nas_framePadding("##", ($i+1)) + "_Jnt")`;
    }
    
    //......................................constrain rk joints to fk and ik......................................
    select -r $fkJoints $rkJoints;
    nas_massConstrain 1 "parent" 1;
    select -r $fkJoints $rkJoints;
    nas_massConstrain 1 "scale" 1;

    select -r $ikJoints $rkJoints;
    $constraints = `nas_massConstrain 1 "parent" 1`;
    select -r $ikJoints $rkJoints;
    $scaleconstraints = `nas_massConstrain 1 "scale" 1`;
    
    //......................................create ikfk switch and connect......................................
    if (!`objExists "Transform"`) {
        circle -n "Transform" -c 0 0 0 -nr 0 1 0 -sw 360 -r 10 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
        nas_colorControls "yellow" 1;
        addAttr -ln "nickCtrlType" -dt "string" "Transform";
        setAttr -type "string" "Transform.nickCtrlType" "char";
        setAttr -k 0 -l 1 "Transform.v";
    }
    if (!`objExists ("Transform." + $name + "_IKFK")`) {
        addAttr -ln ($name + "_IKFK") -min 0 -max 1 -at double "Transform";
        setAttr -e -keyable true ("Transform." + $name + "_IKFK");
    }
    
    $reverse = `createNode -n ($name + "_IKFK_Reverse") reverse`;
    connectAttr ("Transform." + $name + "_IKFK") ($reverse + ".inputX");
    for ($i = 0; $i < size($constraints); $i++) {
        connectAttr ("Transform." + $name + "_IKFK") ($constraints[$i] + "." + $fkJoints[$i] + "W0");
        connectAttr ($reverse + ".outputX") ($constraints[$i] + "." + $ikJoints[$i] + "W1");
        connectAttr ("Transform." + $name + "_IKFK") ($scaleconstraints[$i] + "." + $fkJoints[$i] + "W0");
        connectAttr ($reverse + ".outputX") ($scaleconstraints[$i] + "." + $ikJoints[$i] + "W1");
    }
    
    //......................................run fk rig script......................................
    select -r $fkJoints[0];
    $array = `nas_rigFK $name 1 0 "" 1`;
    $fkJointGroup = $array[0];
    $fkCtrlGroup = $array[1];
    $fkMasterLoc = $array[2];
    $fkCtrls = stringArrayRemove({$fkJointGroup, $fkCtrlGroup, $fkMasterLoc}, $array);
    
    //......................................run ik rig script......................................
    select -r $ikJoints[1];
    $array = `nas_rigIK $name $poleDir $world`;
    $ikCtrl = $array[0];
    $poleVectorCtrl = $array[1];
    $ikClav = $array[2];
    $dist1Loc = $array[3];
    $ikCtrlGroup = $array[4];
    $ikDeformGroup = $array[5];
    $ikJointGroup = $array[6];
    $ikNull = $array[7];
    $ikScaleMD = $array[8];
    $array = `listRelatives -p $ikClav`;
    $ikClavGroup = $array[0];
    parent $ikJoints[0] $ikJointGroup;
    parent $ikJoints[1] $ikJoints[0];
    $array = `listRelatives -c $ikJoints[1]`;
    for ($item in $array) if (`nodeType $item` == "parentConstraint") delete $item;
    $array = `listRelatives -c $dist1Loc`;
    for ($item in $array) if (`nodeType $item` == "pointConstraint") delete $item;
    delete `pointConstraint $ikJoints[0] $ikClavGroup`;
    parentConstraint -mo $ikClav $ikJoints[0];
    parentConstraint -mo $ikClav $dist1Loc;
    setAttr -lock 0 -keyable 1 ($ikClav + ".rx");
    setAttr -lock 0 -keyable 1 ($ikClav + ".ry");
    setAttr -lock 0 -keyable 1 ($ikClav + ".rz");
    
    //......................................connect visibility of fk and ik ctrl groups......................................
    connectAttr ("Transform." + $name + "_IKFK") ($fkCtrlGroup + ".v");
    connectAttr ($reverse + ".outputX") ($ikCtrlGroup + ".v");
    
    //......................................create bind systems......................................
    select -r $rkJoints[1] $rkJoints[2];
    $array = `nas_rigBind ($name + "_Upper") 5`;
    $upperStart = $array[0];
    $upperEnd = $array[1];
    $upperStartGroup = $array[2];
    $upperEndGroup = $array[3];
    $upperJointGroup = $array[4];
    $upperDeformerGroup = $array[5];
    $upperStartUpLoc = $array[6];
    $upperEndUpLoc = $array[7];
    $upperStartUpLocGroup = $array[8];
    $upperEndUpLocGroup = $array[9];
    $upperTwistFalloffSR = $array[11];
    
    select -r $rkJoints[2] $rkJoints[3];
    $array = `nas_rigBind ($name + "_Lower") 5`;
    $lowerStart = $array[0];
    $lowerEnd = $array[1];
    $lowerStartGroup = $array[2];
    $lowerEndGroup = $array[3];
    $lowerJointGroup = $array[4];
    $lowerDeformerGroup = $array[5];
    $lowerStartUpLoc = $array[6];
    $lowerEndUpLoc = $array[7];
    $lowerStartUpLocGroup = $array[8];
    $lowerEndUpLocGroup = $array[9];
    $lowerStartTwistLoc = $array[10];
    $lowerTwistFalloffSR = $array[11];
    
    //......................................create shoulder joint......................................
    select -cl;
    $shoulderJnt = `joint -n ($name + "_Bind_01_Base_Jnt") -p 0 0 0 -radius 3`;
    $shoulderJntGroup = `group -n ($name + "_Bind_01_Base_Jnt_Group") $shoulderJnt`;
    parentConstraint $rkJoints[0] $shoulderJntGroup;
    
    //......................................create mid ctrl......................................
    select -cl;
    $array = `nas_controls "surfaceSphere"`;
    setAttr -type "string" ($array[0] + ".nickCtrlType") "char";
    nas_colorControls "green" 1;
    nas_shadeControls "green";
    $midCtrl = `rename $array[0] ($name + "_Mid_01_Ctrl")`;
    $array = `nas_group 0 "Group"`;
    $midCtrlGroup = $array[0];
    $array = `nas_group 0 "Group"`;
    $midGroup = `rename $array[0] ($name + "_Mid_Ctrl_Group")`;

    $array = `spaceLocator -p 0 0 0`;
    $midLoc = `rename $array[0] ($name + "_Mid_00_Loc")`;
    $array = `spaceLocator -p 0 0 0`;
    $mid1Loc = `rename $array[0] ($name + "_Mid_01_Loc")`;
    $array = `spaceLocator -p 0 0 0`;
    $mid2Loc = `rename $array[0] ($name + "_Mid_02_Loc")`;

    $array = `pointConstraint $rkJoints[1] $rkJoints[2] $mid1Loc`;
    $constraint = $array[0];
    for ($i = 0; $i <= 1000; $i++) {
        setAttr ($constraint + "." + $rkJoints[1] + "W0") ($i/1000.0);
        setAttr ($constraint + "." + $rkJoints[2] + "W1") (1-($i/1000.0));
        if (`nas_distance {$mid1Loc, $rkJoints[2]}` > .1) {
            break;
        }
    }

    $array = `pointConstraint $rkJoints[2] $rkJoints[3] $mid2Loc`;
    $constraint = $array[0];
    for ($i = 0; $i <= 1000; $i++) {
        setAttr ($constraint + "." + $rkJoints[2] + "W0") (1-($i/1000.0));
        setAttr ($constraint + "." + $rkJoints[3] + "W1") ($i/1000.0);
        if (`nas_distance {$mid2Loc, $rkJoints[2]}` > .1) {
            break;
        }
    }

    pointConstraint $mid1Loc $mid2Loc $midLoc;
    aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $rkJoints[2] $mid2Loc $midLoc;

    pointConstraint $rkJoints[2] $midCtrlGroup;
    orientConstraint $midLoc $midCtrlGroup;
    setAttr -lock 1 -keyable 0 ($midCtrl + ".v");
    setAttr -lock 1 -keyable 0 ($midCtrl + ".sx");
    setAttr -lock 1 -keyable 0 ($midCtrl + ".sy");
    setAttr -lock 1 -keyable 0 ($midCtrl + ".sz");
    
    //......................................creates mid locators and constrains start and end bnd joints......................................
    parentConstraint -mo $rkJoints[1] $upperStartGroup;
    parentConstraint -mo $midCtrl $upperEndGroup;
    parentConstraint -mo $midCtrl $lowerStartGroup;
    
    parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z $rkJoints[size($rkJoints)-1] $lowerEndGroup;
    $array = `parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z $fkCtrls[size($fkCtrls)-1] $ikNull $lowerEndGroup`;
    connectAttr ("Transform." + $name + "_IKFK") ($array[0] + "." + $fkCtrls[size($fkCtrls)-1] + "W0");
    connectAttr ($reverse + ".outputX") ($array[0] + "." + $ikNull + "W1");
    
    parentConstraint -mo $rkJoints[0] $upperStartUpLoc;
    parentConstraint -mo $midCtrl $upperEndUpLocGroup;
    parentConstraint -mo $midCtrl $lowerStartUpLocGroup;
    
    //......................................setup lower end up loc with an attr that changes up direction......................................
    select -r $lowerEndUpLoc;
    $array = `nas_controls "curveArrow"`;
    setAttr -type "string" ($array[0] + ".nickCtrlType") "char";
    nas_colorControls "gray" 1;
    $lowerEndTwistCtrl = `rename $array[0] ($name + "_Twist_01_Ctrl")`;
    $array = `nas_group 0 "Group"`;
    $lowerEndTwistCtrlGroup = $array[0];
    
    parentConstraint $lowerEndUpLoc $lowerEndTwistCtrlGroup;
    $array = `connectionInfo -dfs ($lowerEndUpLoc + ".worldMatrix[0]")`;
    for ($item in $array) connectAttr -f ($lowerEndTwistCtrl + ".worldMatrix[0]") $item;
    select -r $lowerEndTwistCtrl;
    nas_showAttrs 0 0 0 0 0 1 0 0 0 0;
    
    setAttr ($lowerEndUpLoc + ".rotateOrder") 1;
    $array = `parentConstraint $fkCtrls[size($fkCtrls)-1] $ikNull $lowerEndUpLoc`;
    connectAttr ("Transform." + $name + "_IKFK") ($array[0] + "." + $fkCtrls[size($fkCtrls)-1] + "W0");
    connectAttr ($reverse + ".outputX") ($array[0] + "." + $ikNull + "W1");

    $array = `listRelatives -p $fkCtrls[size($fkCtrls)-1]`;
    string $lastFKCtrlGroup = $array[0];
    $array = `listRelatives -p $ikCtrl`;
    string $lastIKCtrlGroup = $array[0];
    $array = `parentConstraint $lastFKCtrlGroup $lastIKCtrlGroup $lowerEndUpLocGroup`;
    connectAttr ("Transform." + $name + "_IKFK") ($array[0] + "." + $lastFKCtrlGroup + "W0");
    connectAttr ($reverse + ".outputX") ($array[0] + "." + $lastIKCtrlGroup + "W1");

    //......................................create twist and mid auto twist......................................
    addAttr -ln "LowerTwist" -at double -dv 1 -min 0 -max 1 $lowerEndTwistCtrl;
    setAttr -keyable 1 ($lowerEndTwistCtrl + ".LowerTwist");
    addAttr -ln "LowerTwistFalloff" -at double -dv 1 -min 0 $lowerEndTwistCtrl;
    setAttr -keyable 1 ($lowerEndTwistCtrl + ".LowerTwistFalloff");
    addAttr -ln "UpperTwist" -at double -dv 1 -min 0 -max 1 $lowerEndTwistCtrl;
    setAttr -keyable 1 ($lowerEndTwistCtrl + ".UpperTwist");
    addAttr -ln "UpperTwistFalloff" -at double -dv 1 -min 0 $lowerEndTwistCtrl;
    setAttr -keyable 1 ($lowerEndTwistCtrl + ".UpperTwistFalloff");
    addAttr -ln "MidTwist" -at double -dv 0 $lowerEndTwistCtrl;
    setAttr -keyable 1 ($lowerEndTwistCtrl + ".MidTwist");
    addAttr -ln "MidTwistAuto" -at double -dv 0 -min 0 -max 1 $lowerEndTwistCtrl;
    setAttr -keyable 1 ($lowerEndTwistCtrl + ".MidTwistAuto");
    
    $blender = `createNode -n ($name + "_Mid_Twist_Blender") blendColors`;
    connectAttr ($fkCtrls[size($fkCtrls)-1] + ".rx") ($blender + ".color1R");
    connectAttr ($ikCtrl + ".rx") ($blender + ".color2R");
    connectAttr ("Transform." + $name + "_IKFK") ($blender + ".blender");
    
    setDrivenKeyframe -at "rx" -currentDriver ($blender + ".outputR") -itt plateau -ott plateau -driverValue 45 -value 0 $upperEndUpLoc;
    setDrivenKeyframe -at "rx" -currentDriver ($blender + ".outputR") -itt spline -ott spline -driverValue 360 -value 190 $upperEndUpLoc;
    selectKey -r -k -f 360 ($upperEndUpLoc + "_rotateX");
    setInfinity -poi linear;

    setDrivenKeyframe -at "rx" -currentDriver ($blender + ".outputR") -itt plateau -ott plateau -driverValue -45 -value 0 $upperEndUpLoc;
    setDrivenKeyframe -at "rx" -currentDriver ($blender + ".outputR") -itt spline -ott spline -driverValue -360 -value -190 $upperEndUpLoc;
    selectKey -r -k -f -360 ($upperEndUpLoc + "_rotateX");
    setInfinity -pri linear;
    
    connectAttr ($lowerEndTwistCtrl + ".LowerTwist") ($lowerTwistFalloffSR + ".valueX");
    connectAttr ($lowerEndTwistCtrl + ".LowerTwist") ($lowerTwistFalloffSR + ".minX");
    connectAttr ($lowerEndTwistCtrl + ".LowerTwistFalloff") ($lowerTwistFalloffSR + ".maxX");
    
    connectAttr ($lowerEndTwistCtrl + ".UpperTwist") ($upperTwistFalloffSR + ".valueX");
    connectAttr ($lowerEndTwistCtrl + ".UpperTwist") ($upperTwistFalloffSR + ".minX");
    connectAttr ($lowerEndTwistCtrl + ".UpperTwistFalloff") ($upperTwistFalloffSR + ".maxX");
    
    $mdn = `createNode -n ($name + "_Mid_AutoTwist_MD") multiplyDivide`;
    connectAttr ($upperEndUpLoc + "_rotateX.output") ($mdn + ".input1X");
    connectAttr ($lowerEndTwistCtrl + ".MidTwistAuto") ($mdn + ".input2X");
    
    $pma = `createNode -n ($name + "_Mid_Twist_PMA") plusMinusAverage`;
    connectAttr ($lowerEndTwistCtrl + ".MidTwist") ($pma + ".input1D[0]");
    connectAttr -f ($mdn + ".outputX") ($pma + ".input1D[1]");
    $array = stringToStringArray($name, "_");
    $side = $array[0];

    if ($side == "RT") {
        string $twistFixMD = `createNode -n ($name + "Mid_Twist_Fix_MD") "multiplyDivide"`;
        connectAttr -f ($pma + ".output1D") ($twistFixMD + ".input1X");
        setAttr ($twistFixMD + ".input2X") -1;
        connectAttr -f ($twistFixMD + ".outputX") ($upperEndUpLoc + ".rx");
    } else {
        connectAttr -f ($pma + ".output1D") ($upperEndUpLoc + ".rx");
    }
    connectAttr -f ($pma + ".output1D") ($lowerStartUpLoc + ".rx");

    //......................................adds bow attrs......................................
    addAttr -ln "Bow" -at double -dv 0 -min 0 -max 1 $midCtrl;
    setAttr -keyable 1 ($midCtrl + ".Bow");
    addAttr -ln "Upper01Bow" -nn "Upper 01 Bow" -at double -dv 0 -min 0 $midCtrl;
    setAttr -keyable 1 ($midCtrl + ".Upper01Bow");
    addAttr -ln "Upper02Bow" -nn "Upper 02 Bow" -at double -dv 1 -min 0 $midCtrl;
    setAttr -keyable 1 ($midCtrl + ".Upper02Bow");
    addAttr -ln "Lower01Bow" -nn "Lower 01 Bow" -at double -dv 1 -min 0 $midCtrl;
    setAttr -keyable 1 ($midCtrl + ".Lower01Bow");
    addAttr -ln "Lower02Bow" -nn "Lower 02 Bow" -at double -dv 0 -min 0 $midCtrl;
    setAttr -keyable 1 ($midCtrl + ".Lower02Bow");
    
    //......................................find angles of start and end joints for bowing......................................
    $array = `spaceLocator -p 0 0 0`;
    $loc = $array[0];
    delete `parentConstraint $midCtrl $loc`;
    move -r -os 1 0 0 $loc;
    delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $rkJoints[1] $rkJoints[3] $upperStart`;
    delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $rkJoints[2] $loc $upperEnd`;
    delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $rkJoints[3] $loc $lowerStart`;
    delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $rkJoints[3] $rkJoints[1] $lowerEnd`;
    delete $loc;
    
    //......................................connects bow scale attrs to scales of start and end joints......................................
    $mdn = `createNode -n ($name + "_Bow_MD") multiplyDivide`;
    connectAttr ($midCtrl + ".Bow") ($mdn + ".input1X");
    connectAttr ($midCtrl + ".Bow") ($mdn + ".input1Y");
    connectAttr ($midCtrl + ".Bow") ($mdn + ".input1Z");
    
    connectAttr ($midCtrl + ".Upper01Bow") ($mdn + ".input2X");
    connectAttr -f ($mdn + ".outputX") ($upperStart + ".scaleX");
    connectAttr -f ($mdn + ".outputX") ($upperStart + ".scaleY");
    connectAttr -f ($mdn + ".outputX") ($upperStart + ".scaleZ");
    
    connectAttr ($midCtrl + ".Upper02Bow") ($mdn + ".input2Y");
    connectAttr -f ($mdn + ".outputY") ($upperEnd + ".scaleX");
    connectAttr -f ($mdn + ".outputY") ($upperEnd + ".scaleY");
    connectAttr -f ($mdn + ".outputY") ($upperEnd + ".scaleZ");
    
    connectAttr ($midCtrl + ".Lower01Bow") ($mdn + ".input2Z");
    connectAttr -f ($mdn + ".outputZ") ($lowerStart + ".scaleX");
    connectAttr -f ($mdn + ".outputZ") ($lowerStart + ".scaleY");
    connectAttr -f ($mdn + ".outputZ") ($lowerStart + ".scaleZ");
    
    connectAttr ($midCtrl + ".Lower02Bow") ($lowerEnd + ".scaleX");
    connectAttr ($midCtrl + ".Lower02Bow") ($lowerEnd + ".scaleY");
    connectAttr ($midCtrl + ".Lower02Bow") ($lowerEnd + ".scaleZ");

    //......................................create master ctrl......................................
    select -r $rkJoints[0];
    $array = `nas_controls "surfaceCube"`;
    nas_colorControls "purple" 1;
    nas_shadeControls "purple";
    nas_showAttrs 1 1 1 1 1 1 1 1 1 0;
    setAttr -type "string" ($array[0] + ".nickCtrlType") "char";
    $masterLoc = `rename $array[0] ($name + "_Master_Ctrl")`;
    $array = `nas_group 0 "Group"`;
    $masterLocGroup = $array[0];

    addAttr -ln "PivotX" -at double -dv 0 $masterLoc;
    setAttr -keyable 1 ($masterLoc + ".PivotX");
    addAttr -ln "PivotY" -at double -dv 0 $masterLoc;
    setAttr -keyable 1 ($masterLoc + ".PivotY");
    addAttr -ln "PivotZ" -at double -dv 0 $masterLoc;
    setAttr -keyable 1 ($masterLoc + ".PivotZ");

    connectAttr -f ($masterLoc + ".PivotX") ($masterLoc + ".rotatePivotX");
    connectAttr -f ($masterLoc + ".PivotX") ($masterLoc + ".scalePivotX");
    connectAttr -f ($masterLoc + ".PivotY") ($masterLoc + ".rotatePivotY");
    connectAttr -f ($masterLoc + ".PivotY") ($masterLoc + ".scalePivotY");
    connectAttr -f ($masterLoc + ".PivotZ") ($masterLoc + ".rotatePivotZ");
    connectAttr -f ($masterLoc + ".PivotZ") ($masterLoc + ".scalePivotZ");

    $masterNull = `group -n ($name + "_Master_Null") -em`;
    delete `parentConstraint $masterLoc $masterNull`;
    parent $masterNull $masterLoc;
    
    select -r $masterLoc;
    $array = `nas_controls curveSphere`;
    $masterPivot = `rename $array[0] ($name + "_Master_Pivot_Ctrl")`;
    scale -r .02 .02 .02 $masterPivot;
    parent $masterPivot $masterLoc;
    makeIdentity -apply true -t 1 -r 1 -s 1 $masterPivot;
    parentConstraint $masterLoc $masterPivot;
    setAttr ($masterPivot + ".overrideEnabled") 1;
    setAttr ($masterPivot + ".overrideDisplayType") 2;
    
    parentConstraint -mo $masterNull $fkMasterLoc;
    scaleConstraint -mo $masterNull $fkMasterLoc;
    parentConstraint -mo $masterNull $ikCtrlGroup;
    scaleConstraint -mo $masterNull $ikCtrlGroup;
    parentConstraint -mo $masterNull $midGroup;
    scaleConstraint -mo $masterNull $midGroup;
    scaleConstraint -mo $masterNull $lowerEndTwistCtrlGroup;
    
    $array = `parentConstraint -mo $masterNull ($poleVectorCtrl + "_Group")`;
    setDrivenKeyframe -at ($masterNull + "W1") -currentDriver ($poleVectorCtrl + ".Follow") -itt linear -ott linear -driverValue 3 -value 0 $array[0];
    setDrivenKeyframe -at ($masterNull + "W1") -currentDriver ($poleVectorCtrl + ".Follow") -itt linear -ott linear -driverValue 4 -value 1 $array[0];
    
    addAttr -ln "Follow" -at enum -en "Spine:COG:Transform:World" $masterLoc;
    setAttr -keyable 1 ($masterLoc + ".Follow");
    
    //......................................clean up......................................
    $bndJointGroup = `group -em -n ($name + "_Bind_Jnt_Group")`;
    parent $upperJointGroup $lowerJointGroup $bndJointGroup;
    $bndDeformerGroup = `group -em -n ($name + "_Bind_Deformer_Group")`;
    parent $upperDeformerGroup $lowerDeformerGroup $bndDeformerGroup;
    $ctrlGroup = `group -em -n ($name + "_Ctrl_Group")`;
    parent $fkMasterLoc $fkCtrlGroup $ikCtrlGroup $midGroup $lowerEndTwistCtrlGroup $ctrlGroup;
    $jointGroup = `group -em -n ($name + "_Jnt_Group")`;
    parent $rkJoints[0] $fkJointGroup $ikJointGroup $shoulderJntGroup $bndJointGroup $jointGroup;
    $deformerGroup = `group -em -n ($name + "_Deformer_Group")`;
    parent $ikDeformGroup $bndDeformerGroup $midLoc $mid1Loc $mid2Loc $deformerGroup;
    
    setAttr ($rkJoints[0] + ".v") 0;
    setAttr ($fkJointGroup + ".v") 0;
    setAttr ($ikJointGroup + ".v") 0;
    setAttr ($deformerGroup + ".v") 0;
    
    return {$jointGroup, $ctrlGroup, $deformerGroup, $ikScaleMD, $masterLocGroup};
}

//-------------------------------------------------------------nas_rigFoot---------------------------------------------------------------------
//nas_rigFoot "LT_Foot" "LT_Leg_IK_01_Ctrl" "LT_Heel_Loc" "LT_Toe_Loc" "LT_Foot_01_Jnt" "x" "-y" "-z" 
global proc string[] nas_rigFoot(string $name, string $ikCtrl, string $heelLoc, string $toeLoc, string $topJoint, string $rollAxis, string $pivotAxis, string $rockAxis) {    
    string $heelGroup, $toeGroup, $ballGroup, $array[], $parent, $heelNull, $toeNull, $ballRollNull, $ballPivotNull, $tipNull, $clamp, $rkJoints[], $fkJoints[], $ikJoints[], 
    $fkJointGroup, $fkCtrlGroup, $fkCtrls[], $ball1Handle, $ball2Handle, $toeHandle, $rollAttrs[], $pivotAttrs[], $rockAttrs[], $nodes[], $jointGroup, $deformerGroup, 
    $ctrlGroup, $connectGroup, $fkMasterLoc, $scaleConstraints[];
    float $rolls[], $pivots[], $rocks[], $val, $vals[];
    
    clear $rkJoints;
    clear $array;
    
    
    $array = stringArrayCatenate(`listRelatives -ad -type joint $topJoint`, $array);
    $rkJoints[0] = $topJoint;
    for ($i = size($array)-1; $i >= 0; $i--) $rkJoints[size($rkJoints)] = $array[$i];
    
    $fkJoints = `duplicate -rc $rkJoints[0]`;
    $ikJoints = `duplicate -rc $rkJoints[0]`;
    
    for ($i = 0; $i < size($rkJoints); $i++) {
        $fkJoints[$i] = `rename $fkJoints[$i] ($name + "_FK_" + nas_framePadding("##", ($i+1)) + "_Jnt")`;
        $ikJoints[$i] = `rename $ikJoints[$i] ($name + "_IK_" + nas_framePadding("##", ($i+1)) + "_Jnt")`;
    }
    
    //constrain rk joints to fk and ik
    select -r $fkJoints $rkJoints;
    nas_massConstrain 1 "parent" 1;
    select -r $fkJoints $rkJoints;
    nas_massConstrain 1 "scale" 1;

    select -r $ikJoints $rkJoints;
    $constraints = `nas_massConstrain 1 "parent" 1`;
    select -r $ikJoints $rkJoints;
    $scaleconstraints = `nas_massConstrain 1 "scale" 1`;
    
    //create ikfk switch and connect
    if (!`objExists "Transform"`) {
        circle -n "Transform" -c 0 0 0 -nr 0 1 0 -sw 360 -r 5 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
        nas_colorControls "yellow" 1;
        addAttr -ln "nickCtrlType" -dt "string" "Transform";
        setAttr -type "string" "Transform.nickCtrlType" "char";
        setAttr -k 0 -l 1 "Transform.v";
    }
    if (!`objExists ("Transform." + $name + "_IKFK")`) {
        addAttr -ln ($name + "_IKFK") -min 0 -max 1 -at double "Transform";
        setAttr -e -keyable true ("Transform." + $name + "_IKFK");
    }
    
    $reverse = `createNode -n ($name + "_IKFK_Reverse") reverse`;
    connectAttr ("Transform." + $name + "_IKFK") ($reverse + ".inputX");
    for ($i = 0; $i < size($constraints); $i++) {
        connectAttr ("Transform." + $name + "_IKFK") ($constraints[$i] + "." + $fkJoints[$i] + "W0");
        connectAttr ($reverse + ".outputX") ($constraints[$i] + "." + $ikJoints[$i] + "W1");
        connectAttr ("Transform." + $name + "_IKFK") ($scaleconstraints[$i] + "." + $fkJoints[$i] + "W0");
        connectAttr ($reverse + ".outputX") ($scaleconstraints[$i] + "." + $ikJoints[$i] + "W1");
    }
    
    select -r $fkJoints[0];
    $array = `nas_rigFK $name 1 0 "" 0`;
    $fkJointGroup = $array[0];
    $fkCtrlGroup = $array[1];
    $fkMasterLoc = $array[2];
    $fkCtrls = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
    setAttr -lock 0 ($fkCtrls[0] + ".v");
    setAttr ($fkCtrls[0] + ".v") 0;
    setAttr -lock 1 ($fkCtrls[0] + ".v");
    
    $array = `ikHandle -n ($name + "_IK_01_Handle") -ap -sol ikSCsolver -s sticky -sj $ikJoints[0] -ee $ikJoints[1]`;
    $ball1Handle = $array[0];
    $array = `ikHandle -n ($name + "_IK_02_Handle") -ap -sol ikSCsolver -s sticky -sj $ikJoints[1] -ee $ikJoints[2]`;
    $ball2Handle = $array[0];
    $array = `ikHandle -n ($name + "_IK_03_Handle") -ap -sol ikSCsolver -s sticky -sj $ikJoints[2] -ee $ikJoints[3]`;
    $toeHandle = $array[0];
    
    //connect visibility of fk and ik ctrl groups
    connectAttr ("Transform." + $name + "_IKFK") ($fkCtrlGroup + ".v");
    $array = `listRelatives -p $ikCtrl`;
    connectAttr ($reverse + ".outputX") ($array[0] + ".v");
    
    $toeNull = `group -em -n ($name + "_IK_Toe_Null")`;
    delete `parentConstraint $ikCtrl $toeNull`;
    makeIdentity -apply true -t 1 -r 1 -s 1 $toeNull;
    $array = `nas_group 0 "Group"`;
    $ballRollNull = `rename $array[0] ($name + "_IK_Ball_Roll_Null")`;
    $array = `nas_group 0 "Group"`;
    $ballPivotNull = `rename $array[0] ($name + "_IK_Ball_Pivot_Null")`;
    $array = `nas_group 0 "Group"`;
    $heelNull = `rename $array[0] ($name + "_IK_Heel_Null")`;
    $array = `nas_group 0 "Group"`;
    $tipNull = `rename $array[0] ($name + "_IK_Tip_Null")`;
    //parent $ikNull $ballRollNull;
    parent $toeNull $heelNull;
    
    select -r $toeLoc $tipNull;
    nas_matchPivots;
    select -r $heelLoc $heelNull;
    nas_matchPivots;
    select -r $ikJoints[1] $ballRollNull;
    nas_matchPivots;
    select -r $ikJoints[2] $ballPivotNull $toeNull;
    nas_matchPivots;
    
    //parentConstraint -mo $ballRollNull $ikJoints[0];
    
    /*parentConstraint -mo $ballPivotNull $ball1Handle;
    parentConstraint -mo $heelNull $ball2Handle;
    parentConstraint -mo $toeNull $toeHandle;
    */
    parent $ball1Handle $ballPivotNull;
    parent $ball2Handle $heelNull;
    parent $toeHandle $toeNull;
    
    hide $ball1Handle $ball2Handle $toeHandle;
    
    addAttr -ln "FootRoll" -at double $ikCtrl;
    setAttr -e -keyable true ($ikCtrl + ".FootRoll");
    addAttr -ln "BallPivot" -nn "Pivot Ball" -at double $ikCtrl;
    setAttr -e -keyable true ($ikCtrl + ".BallPivot");
    addAttr -ln "BallRock" -nn "Rock Ball" -at double $ikCtrl;
    setAttr -e -keyable true ($ikCtrl + ".BallRock");
    addAttr -ln "TipRoll" -nn "Roll Tip" -at double $ikCtrl;
    setAttr -e -keyable true ($ikCtrl + ".TipRoll");
    addAttr -ln "TipPivot" -nn "Pivot Tip" -at double $ikCtrl;
    setAttr -e -keyable true ($ikCtrl + ".TipPivot");
    addAttr -ln "TipRock" -nn "Rock Tip" -at double $ikCtrl;
    setAttr -e -keyable true ($ikCtrl + ".TipRock");
    addAttr -ln "ToeRoll" -nn "Roll Toe" -at double $ikCtrl;
    setAttr -e -keyable true ($ikCtrl + ".ToeRoll");
    addAttr -ln "ToePivot" -nn "Pivot Toe" -at double $ikCtrl;
    setAttr -e -keyable true ($ikCtrl + ".ToePivot");
    addAttr -ln "ToeRock" -nn "Rock Toe" -at double $ikCtrl;
    setAttr -e -keyable true ($ikCtrl + ".ToeRock");
    
    $vals = `nas_axisToVector $rollAxis`;
    $val = $vals[0] + $vals[1] + $vals[2];
    
    setDrivenKeyframe -at ("r" + endString($rollAxis, 1)) -currentDriver ($ikCtrl + ".FootRoll") -itt spline -ott spline -driverValue 0 -value 0 $ballRollNull;
    setDrivenKeyframe -at ("r" + endString($rollAxis, 1)) -currentDriver ($ikCtrl + ".FootRoll") -itt spline -ott spline -driverValue 1 -value $val $ballRollNull;
    selectKey -r -k -f 0 -f 1 ($ballRollNull + "_rotate" + capitalizeString(endString($rollAxis, 1)));
    if ($val < 0) setInfinity -pri linear;
    else setInfinity -poi linear;
    
    setDrivenKeyframe -at ("r" + endString($rollAxis, 1)) -currentDriver ($ikCtrl + ".FootRoll") -itt spline -ott spline -driverValue 0 -value 0 $heelNull;
    setDrivenKeyframe -at ("r" + endString($rollAxis, 1)) -currentDriver ($ikCtrl + ".FootRoll") -itt spline -ott spline -driverValue -1 -value (-1*$val) $heelNull;
    selectKey -r -k -f 0 -f 1 ($heelNull + "_rotate" + capitalizeString(endString($rollAxis, 1)));
    if ($val > 0) setInfinity -pri linear;
    else setInfinity -poi linear;
    
    $nodes = {"TipRoll", $tipNull, "ToeRoll", $toeNull};
    for ($i = 0; $i < size($nodes); $i+=2) {
        setDrivenKeyframe -at ("r" + endString($rollAxis, 1)) -currentDriver ($ikCtrl + "." + $nodes[$i]) -itt spline -ott spline -driverValue 0 -value 0 $nodes[$i+1];
        setDrivenKeyframe -at ("r" + endString($rollAxis, 1)) -currentDriver ($ikCtrl + "." + $nodes[$i]) -itt spline -ott spline -driverValue 1 -value $val $nodes[$i+1];
        selectKey -r -k -f 0 -f 1 ($nodes[$i+1] + "_rotate" + capitalizeString(endString($rollAxis, 1)));
        setInfinity -pri linear -poi linear;
    }
    
    $vals = `nas_axisToVector $pivotAxis`;
    $val = $vals[0] + $vals[1] + $vals[2];
    $nodes = {"BallPivot", $ballPivotNull, "TipPivot", $tipNull, "ToePivot", $toeNull};
    for ($i = 0; $i < size($nodes); $i+=2) {
        setDrivenKeyframe -at ("r" + endString($pivotAxis, 1)) -currentDriver ($ikCtrl + "." + $nodes[$i]) -itt spline -ott spline -driverValue 0 -value 0 $nodes[$i+1];
        setDrivenKeyframe -at ("r" + endString($pivotAxis, 1)) -currentDriver ($ikCtrl + "." + $nodes[$i]) -itt spline -ott spline -driverValue 1 -value $val $nodes[$i+1];
        selectKey -r -k -f 0 -f 1 ($nodes[$i+1] + "_rotate" + capitalizeString(endString($pivotAxis, 1)));
        setInfinity -pri linear -poi linear;
    }
    
    $vals = `nas_axisToVector $rockAxis`;
    $val = $vals[0] + $vals[1] + $vals[2];
    $nodes = {"BallRock", $ballPivotNull, "TipRock", $tipNull, "ToeRock", $toeNull};
    for ($i = 0; $i < size($nodes); $i+=2) {
        setDrivenKeyframe -at ("r" + endString($rockAxis, 1)) -currentDriver ($ikCtrl + "." + $nodes[$i]) -itt spline -ott spline -driverValue 0 -value 0 $nodes[$i+1];
        setDrivenKeyframe -at ("r" + endString($rockAxis, 1)) -currentDriver ($ikCtrl + "." + $nodes[$i]) -itt spline -ott spline -driverValue 1 -value $val $nodes[$i+1];
        selectKey -r -k -f 0 -f 1 ($nodes[$i+1] + "_rotate" + capitalizeString(endString($rockAxis, 1)));
        setInfinity -pri linear -poi linear;
    }
    
    delete $heelLoc $toeLoc;
    
    $jointGroup = `group -em -n ($name + "_Jnt_Group")`;
    parent $rkJoints[0] $ikJoints[0] $fkJointGroup $jointGroup;
    $connectGroup = `group -em -n ($name + "_IK_Ctrl_Group")`;
    parent $tipNull $connectGroup;
    $ctrlGroup = `group -em -n ($name + "_Ctrl_Group")`;
    parent $fkMasterLoc $fkCtrlGroup $connectGroup $ctrlGroup;
    //$deformerGroup = `group -em -n ($name + "_Deformer_Group")`;
    //parent $ball1Handle $ball2Handle $toeHandle $deformerGroup;
    
    setAttr ($ikJoints[0] + ".v") 0;
    setAttr ($fkJointGroup + ".v") 0;
    //setAttr ($deformerGroup + ".v") 0;
    
    return {$jointGroup, $ctrlGroup, $deformerGroup, $connectGroup, $tipNull, $fkMasterLoc, $ikJoints[0]};
}

//-------------------------------------------------------------nas_rigHead---------------------------------------------------------------------
global proc string[] nas_rigHead(string $ID, int $earAuto) {
    string $array[], $ctrls[], $ctrlGroups[], $jntGroups[], $topJoints[], $name, $parts[], $hists[], 
    $headCtrlGroup, $headJntGroup, $headFKCtrlGroup, $headFKJntGroup, $head01JntGroup, $head01CtrlGroup, $head02JntGroup, $head02CtrlGroup, 
    $ctrlGroup, $jntGroup, $masterLoc, $head01Jnt, $head02Jnt, $upperJawJnt, $lowerJawJnt, $headMasterLoc;
    
    //......................................create main groups......................................
    $headJntGroup = `group -em -n ("Head_" + $ID + "_Jnt_Group")`;
    $headCtrlGroup = `group -em -n ("Head_" + $ID + "_Ctrl_Group")`;
    
    //......................................build head......................................
    $array = `nas_rigFKFromBind ("Head_" + $ID + "_Bind_01_Jnt") 0 1`;
    $headFKJntGroup = $array[0];
    $headFKCtrlGroup = $array[1];
    $headMasterLoc = $array[2];

    $hists = `listHistory $array[3]`;
    setAttr ($hists[size($hists)-1] + ".radius") 4;
    setAttr ($hists[size($hists)-1] + ".heightRatio") .02;
    $hists = `listHistory $array[4]`;
    setAttr ($hists[size($hists)-1] + ".radius") 4;
    setAttr ($hists[size($hists)-1] + ".heightRatio") .02; 
    
    parent $headFKJntGroup $headJntGroup;
    parent $headFKCtrlGroup $headCtrlGroup;
    
    $array = `listRelatives -c $headFKJntGroup`;
    $head01Jnt = $array[0];
    $head02Jnt = $array[1];
    
    //......................................build ears......................................
    $topJoints = `nas_getTopJoints "*_Ear_*_Bind_01_Jnt"`;
    for ($topJoint in $topJoints) {
        $name = `nas_getNameFromBind $topJoint`;
        $array = `nas_rigFK $name $earAuto 0 "" 0`;
        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        $masterLoc = $array[2];
        
        parentConstraint -mo $head02Jnt $masterLoc;
        scaleConstraint -mo $head02Jnt $masterLoc;
        
        parent $jntGroup $headJntGroup;
        parent $masterLoc $headCtrlGroup;
        parent $ctrlGroup $headCtrlGroup;
    }    
    
    //......................................build upper jaws......................................
    $topJoints = `nas_getTopJoints "Upper_Jaw_*_Bind_01_Jnt"`;
    for ($topJoint in $topJoints) {
        $array = `nas_rigFKFromBind $topJoint 0 0`;
        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        $masterLoc = $array[2];
        $ctrls = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
        $array = `listHistory $ctrls[0]`;
        setAttr ($array[1] + ".radius") .3;
        rotate -r -os 90 0 0 ($ctrls[0] + ".cv[0:3][0:7]");
        delete -ch $ctrls[0];
        
        parentConstraint -mo $head01Jnt $masterLoc;
        scaleConstraint -mo $head01Jnt $masterLoc;
        parent $jntGroup $headJntGroup;
        parent $masterLoc $headCtrlGroup;
        parent $ctrlGroup $headCtrlGroup;
        
        $array = `listRelatives -c $jntGroup`;
        $upperJawJnt = $array[0];
    }
    
    //......................................build uvulas......................................
    $topJoints = `nas_getTopJoints "Uvula_*_Bind_01_Jnt"`;
    for ($topJoint in $topJoints) {
        $array = `nas_rigFKFromBind $topJoint 0 0`;
        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        $masterLoc = $array[2];
        $ctrls = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
        for ($ctrl in $ctrls) {
            $array = `listHistory $ctrl`;
            setAttr ($array[1] + ".radius") .15;
        }
        
        parentConstraint -mo $upperJawJnt $masterLoc;
        scaleConstraint -mo $upperJawJnt $masterLoc;
        parent $jntGroup $headJntGroup;
        parent $masterLoc $headCtrlGroup;
        parent $ctrlGroup $headCtrlGroup;
    }
    
    //......................................build lower jaws......................................
    $topJoints = `nas_getTopJoints "Lower_Jaw_*_Bind_01_Jnt"`;
    for ($topJoint in $topJoints) {
        $array = `nas_rigFKFromBind $topJoint 0 0`;
        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        $masterLoc = $array[2];
        $ctrls = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
        $array = `listHistory $ctrls[0]`;
        setAttr ($array[1] + ".radius") .3;
        rotate -r -os 90 0 0 ($ctrls[0] + ".cv[0:3][0:7]");
        delete -ch $ctrls[0];
        
        parentConstraint -mo $head01Jnt $masterLoc;
        scaleConstraint -mo $head01Jnt $masterLoc;
        parent $jntGroup $headJntGroup;
        parent $masterLoc $headCtrlGroup;
        parent $ctrlGroup $headCtrlGroup;
        
        $array = `listRelatives -c $jntGroup`;
        $lowerJawJnt = $array[0];
    }
    
    //......................................build tongues......................................
    $topJoints = `nas_getTopJoints "Tongue_*_Bind_01_Jnt"`;
    for ($topJoint in $topJoints) {
        $array = `nas_rigFKFromBind $topJoint 0 0`;
        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        $masterLoc = $array[2];
        $ctrls = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
        for ($ctrl in $ctrls) {
            $array = `listHistory $ctrl`;
            setAttr ($array[1] + ".radius") .3;
        }
        
        parentConstraint -mo $lowerJawJnt $masterLoc;
        scaleConstraint -mo $lowerJawJnt $masterLoc;
        parent $jntGroup $headJntGroup;
        parent $masterLoc $headCtrlGroup;
        parent $ctrlGroup $headCtrlGroup;
    }    
    
    return {$headJntGroup, $headCtrlGroup, $headMasterLoc};
}

//-------------------------------------------------------------nas_assembleSystems---------------------------------------------------------------------
global proc nas_assembleSystems(string $armPoleDir, string $legPoleDir, int $spineAuto, int $neckAuto, int $earAuto) {
    string $array[], $array2[], $ctrl, $ctrls[], $mainGroups[], $skeleton, $controllers, $transform, $deformers, $name, 
    $jntGroup, $ctrlGroup, 
    $spineJntGroup, $spineCtrlGroup, $spineMasterLoc, 
    $hipJntGroup, $hipCtrlGroup, $hipCtrl, $hipMasterLoc, 
    $cogCtrl, $cogNull,$cogCtrlGroup, 
    $headJntGroup, $headCtrlGroup,  
    $neckJntGroup, $neckCtrlGroup, $neckCtrl, $neckMasterLoc, 
    $upperBodyJntGroup, $upperBodyCtrlGroup, $upperBodyDeformerGroup, 
    $lowerBodyJntGroup, $lowerBodyCtrlGroup, $lowerBodyDeformerGroup, 
    $ctrlGroups[], $jntGroups[], $deformerGroups[], $scaleMDs[],  
    $parentJntGroups[], $joints[], $fingerJoints[], $ikCtrlGroup, $ikCtrl, $tipNull, 
    $window, $windows[], 
    $ikCtrls[], $group, $constraint, 
    $torsoJntGroup, $torsoCtrlGroup,
    $masterLoc, $targetNode, $masterLocGroup, $masterCtrl, 
    $joint, $masterLocs[], $poleVectorCtrl, $scaleMD, $masterScaleMD, $masterJntGroup, $constraints[], $shapes[], $pivot;
    float $wp[];
    clear $scaleMDs;
    
    nas_progress 16 "start";
    //......................................hide the script editor......................................
    nas_progress 0 "hiding script editor";
    $windows = `lsUI -windows`;
    for ($window in $windows) if (`gmatch $window "scriptEditorPanel*Window"`) deleteUI $window;
    
    //......................................build default nodes......................................
    nas_progress 0 "creating main groups";
    $skeleton = "Skeleton";
    $controllers = "Controllers";
    $deformers = "Deformers";
    $transform = "Transform";
    $offset = "Offset";
    $world = "World_CharName";
    
    $mainGroups = {$skeleton, $controllers, $deformers, $offset, $world};
    for ($mainGroup in $mainGroups) {
        if (!`objExists $mainGroup`) group -em -n $mainGroup;
        catchQuiet(`parent -w $mainGroup`);
    }
    
    if (!`objExists $transform`) {
        circle -n $transform -c 0 0 0 -nr 0 1 0 -sw 360 -r 10 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0;
        nas_colorControls "purple" 1;
        addAttr -ln "nickCtrlType" -dt "string" $transform;
        setAttr -type "string" ($transform + ".nickCtrlType") "char";
        setAttr -k 0 -l 1 ($transform + ".v");
    } else {
        catchQuiet(`parent -w $transform`);
    }
    
    catchQuiet(`parent $transform $offset`);
    catchQuiet(`parent $offset $controllers`);
    catchQuiet(`parent $skeleton $controllers $deformers $world`);

    //......................................build COG......................................
    nas_progress 0 "building COG";
    select -r $world;
    $array = `nas_controls surfaceCircle`;
    $cogCtrl = `rename $array[0] "COG"`;
    $array = `listHistory $cogCtrl`;
    setAttr ($array[size($array)-1] + ".radius") 10;
    setAttr ($array[size($array)-1] + ".heightRatio") .01;
    rotate -r -os 0 0 90 $cogCtrl;
    makeIdentity -apply true -t 1 -r 1 -s 1 $cogCtrl;
    
    nas_colorControls "yellow" 1;
    nas_shadeControls "yellow";
    nas_showAttrs 1 1 1 1 1 1 0 0 0 0;
    $cogNull = `group -em -n "COG_Pivot_Null"`;
    parent $cogNull $cogCtrl;
    $cogCtrlGroup = `group -n "COG_Group" $cogCtrl`;
    delete `pointConstraint "Hip_01_Bind_01_Jnt" $cogCtrlGroup`;
    
    for ($attr in {"PivotX", "PivotY", "PivotZ"}) {
        addAttr -ln $attr -at double -dv 0 $cogCtrl;
        setAttr -keyable 1 ($cogCtrl + "." + $attr);
        connectAttr -f ($cogCtrl + "." + $attr) ($cogCtrl + ".rotate" + $attr);
        connectAttr -f ($cogCtrl + "." + $attr) ($cogCtrl + ".scale" + $attr);
    }
    
    select -r $cogCtrl;
    $array = `nas_controls curveSphere`;
    $pivot = `rename $array[0] ($name + "COG_Pivot_Ctrl")`;
    scale -r .02 .02 .02 $pivot;
    parent $pivot $cogCtrl;
    makeIdentity -apply true -t 1 -r 1 -s 1 $pivot;
    parentConstraint $cogCtrl $pivot;
    setAttr ($pivot + ".overrideEnabled") 1;
    setAttr ($pivot + ".overrideDisplayType") 2;
    $shapes = `listRelatives -s $pivot`;
    for ($shape in $shapes) {
        setAttr ($shape + ".overrideEnabled") 1;
        setAttr ($shape + ".overrideDisplayType") 2;
    }
    
    //======================================create torso group======================================
    $torsoJntGroup = `group -em -n "Torso_Jnt_Group"`;
    $torsoCtrlGroup = `group -em -n "Torso_Ctrl_Group"`;
    
    //......................................build spine......................................
    nas_progress 0 "building spine";
    if (`objExists "Spine_01_Bind_01_Jnt"`) {
        select -r "Spine_01_Bind_01_Jnt";
        $array = `nas_rigFK "Spine_01" $spineAuto 0 "" 0`;
        $spineJntGroup = $array[0];
        $ctrlGroup = $array[1];
        $masterLoc = $array[2];
        $ctrls = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
        for ($ctrl in $ctrls) {
            $array = `listHistory $ctrl`;
            setAttr ($array[1] + ".radius") 4.5;
            setAttr ($array[1] + ".heightRatio") .025;
        }
        parentConstraint -mo $cogNull $masterLoc;
        scaleConstraint -mo $cogNull $masterLoc;
        parent $spineJntGroup $torsoJntGroup;
        parent $masterLoc $torsoCtrlGroup;
        parent $ctrlGroup $torsoCtrlGroup;
    }
    
    //......................................build hip......................................
    nas_progress 0 "building hip";
    if (`objExists "Hip_01_Bind_01_Jnt"`) {
        select -r "Hip_01_Bind_01_Jnt";
        $array = `nas_rigFK "Hip" 0 0 "" 1`;
        $hipJntGroup = $array[0];
        $ctrlGroup = $array[1];
        $masterLoc = $array[2];
        $hipCtrl = $array[3];
        $array = `listHistory $hipCtrl`;
        setAttr ($array[1] + ".radius") 5.5;
        setAttr ($array[1] + ".heightRatio") .025;
        rotate -r -os 0 0 0 ($hipCtrl + ".cv[0:3][0:7]");
        delete -ch $hipCtrl;
        parentConstraint -mo $cogNull $masterLoc;
        scaleConstraint -mo $cogNull $masterLoc;
        parent $hipJntGroup $torsoJntGroup;
        parent $masterLoc $torsoCtrlGroup;
        parent $ctrlGroup $torsoCtrlGroup;
    }
    
    //======================================create head group======================================
    $headJntGroup = `group -em -n "Head_Jnt_Group"`;
    $headCtrlGroup = `group -em -n "Head_Ctrl_Group"`;
    
    //......................................build neck......................................
    nas_progress 0 "building neck";
    $topJoints = `nas_getTopJoints "Neck_*_Bind_*_Jnt"`;
    for ($topJoint in $topJoints) {
        $name = `nas_getNameFromBind $topJoint`;
        $array = `nas_rigFK $name $neckAuto 0 "" 0`;
        $neckJntGroup = $array[0];
        $ctrlGroup = $array[1];
        $masterLoc = $array[2];
        $ctrls = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
    
        select -r $masterLoc;
        $array = `nas_controls "surfaceCube"`;
        select -r $array[0] $masterLoc;
        nas_parentShape 1;
        $array = stringToStringArray($masterLoc, "_");
        $array = stringArrayRemove({$array[size($array)-1]}, $array);
        $masterLoc = `rename $masterLoc ((stringArrayToString($array, "_")) + "_Ctrl")`;
        nas_colorControls "purple" 1;
        nas_shadeControls "purple";
        setAttr ($masterLoc + ".v") 1;
        addAttr -ln "nickCtrlType" -dt "string" $masterLoc;
        setAttr -type "string" ($masterLoc + ".nickCtrlType") "char";
        nas_showAttrs 1 1 1 1 1 1 1 1 1 0;
        $array = `nas_group 0 "Group"`;
        $masterLocGroup = $array[0];
        
        select -r $ctrls[0];
        $array = `nas_controls "surfaceSinglePin"`;
        setAttr -type "string" ($array[0] + ".nickCtrlType") "char";
        nas_colorControls "blue" 1;
        nas_shadeControls "blue";
        scale -r 10 10 10 $array[0];
        rotate -r -os -90 0 0 $array[0];
        $array[0] = `rename $array[0] "singlePin"`;
        select -r $array[0] $ctrls[0];
        nas_parentShape 1;

        $array = `listRelatives -c $spineJntGroup`;
        parentConstraint -mo $array[size($array)-1] $masterLocGroup;
        scaleConstraint -mo $array[size($array)-1] $masterLocGroup;
        parent $neckJntGroup $headJntGroup;
        parent $masterLocGroup $headCtrlGroup;
        parent $ctrlGroup $headCtrlGroup;
    }
    
    //......................................build head......................................
    nas_progress 0 "building head";
    $topJoints = `nas_getTopJoints "Head_*_Bind_01_Jnt"`;
    for ($topJoint in $topJoints) {
        $array = stringToStringArray($topJoint, "_");
        $array = `nas_rigHead $array[1] $earAuto`;
        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        $masterLoc = $array[2];

        $array = `listRelatives -c $neckJntGroup`;
        parentConstraint -mo $array[size($array)-1] $masterLoc;
        scaleConstraint -mo $array[size($array)-1] $masterLoc;
        parent $jntGroup $headJntGroup;
        parent $masterLoc $headCtrlGroup;
        parent $ctrlGroup $headCtrlGroup;
    }
    
    //======================================create upper body group======================================
    $upperBodyJntGroup = `group -em -n "Upper_Body_Jnt_Group"`;
    $upperBodyCtrlGroup = `group -em -n "Upper_Body_Ctrl_Group"`;
    $upperBodyDeformerGroup = `group -em -n "Upper_Body_Deformer_Group"`;
    
    //......................................build clavicles......................................
    nas_progress 0 "building arms";
    clear $jntGroups;
    clear $ctrlGroups;
    $topJoints = `nas_getTopJoints "*_Clavicle_*_Bind_*_Jnt"`;
    for ($topJoint in $topJoints) {
        $name = `nas_getNameFromBind $topJoint`;
        select -r $topJoint;
        $array = `nas_rigFK $name 2 0 "" 0`;
        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        $masterLoc = $array[2];
        $ctrls = stringArrayRemove({$array[0], $array[1], $array[2]}, $array);
        select -r $ctrls[0];
        $array = `nas_controls "surfaceDoublePin"`;
        setAttr -type "string" ($array[0] + ".nickCtrlType") "char";
        nas_colorControls "blue" 1;
        nas_shadeControls "blue";
        scale -r 2 2 2 $array[0];
        $array[0] = `rename $array[0] "doublePin"`;
        select -r $array[0] $ctrls[0];
        nas_parentShape 1;
        $array = `listRelatives -c $jntGroup`;
        setAttr ($array[size($array)-1] + ".v") 0;
        
        $array = `listRelatives -c $spineJntGroup`;
        parentConstraint -mo $array[size($array)-1] $masterLoc;
        scaleConstraint -mo $array[size($array)-1] $masterLoc;
        parent $jntGroup $upperBodyJntGroup;
        parent $masterLoc $upperBodyCtrlGroup;
        parent $ctrlGroup $upperBodyCtrlGroup;
    }
    
    //......................................build arms......................................
    clear $jntGroups;
    clear $ctrlGroups;
    clear $deformerGroups;
    $topJoints = `nas_getTopJoints "*_Arm_*_Bind_01_Jnt"`;
    for ($topJoint in $topJoints) {
        select -r $topJoint;
        $name = `nas_getNameFromBind $topJoint`;
        $array = `nas_rigLimb $name $armPoleDir 0`;

        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        $deformerGroup = $array[2];
        $scaleMD = $array[3];
        $masterLoc = $array[4];
        
        $array = stringToStringArray($ctrlGroup, "_");
        $targetNode = ($array[0] + "_Clavicle_" + $array[2] + "_FK_Jnt_Group");
        if (`objExists $targetNode`) {
            $joints = `listRelatives -c $targetNode`;
            $array = `parentConstraint -mo $joints[size($joints)-1] $cogNull $transform $offset $masterLoc`;
            $constraints[0] = $array[0];
            $array = `scaleConstraint -mo $joints[size($joints)-1] $cogNull $transform $offset $masterLoc`;
            $constraints[1] = $array[0];
            
            $array = `listRelatives -c -type transform $masterLoc`;
            $masterCtrl = $array[0];
            
            for ($i = 0; $i < 2; $i++) {
                setDrivenKeyframe -at ($joints[size($joints)-1] + "W0") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 0 -value 1 $constraints[$i];
                setDrivenKeyframe -at ($joints[size($joints)-1] + "W0") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 1 -value 0 $constraints[$i];
                setDrivenKeyframe -at ($cogNull + "W1") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 0 -value 0 $constraints[$i];
                setDrivenKeyframe -at ($cogNull + "W1") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 1 -value 1 $constraints[$i];
                setDrivenKeyframe -at ($cogNull + "W1") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 2 -value 0 $constraints[$i];
                setDrivenKeyframe -at ($transform + "W2") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 1 -value 0 $constraints[$i];
                setDrivenKeyframe -at ($transform + "W2") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 2 -value 1 $constraints[$i];
                setDrivenKeyframe -at ($transform + "W2") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 3 -value 0 $constraints[$i];
                setDrivenKeyframe -at ($offset + "W3") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 2 -value 0 $constraints[$i];
                setDrivenKeyframe -at ($offset + "W3") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 3 -value 1 $constraints[$i];
            }
        }
            
        $masterJntGroup = `group -em -n ($name + "_Jnt_Master_Group")`;
        scaleConstraint -mo ($name + "_Master_Null") $masterJntGroup;
        
        $masterScaleMD = `createNode -n ($name + "_Jnt_Master_Scale_MD") multiplyDivide`;
        connectAttr ($skeleton + ".sx") ($masterScaleMD + ".input1X");
        connectAttr ($masterJntGroup + ".sx") ($masterScaleMD + ".input2X");
        connectAttr ($masterScaleMD + ".outputX") ($scaleMD + ".input2X");
        
        parent $jntGroup $masterJntGroup;
        parent $masterJntGroup $upperBodyJntGroup;
        parent $masterLoc $upperBodyCtrlGroup;
        parent $ctrlGroup $upperBodyCtrlGroup;
        parent $deformerGroup $upperBodyDeformerGroup;
    }    
    
    //......................................build hands......................................
    nas_progress 0 "building hands";
    clear $jntGroups;
    clear $ctrlGroups;
    $topJoints = `nas_getTopJoints "*_Hand_*_Bind_01_Jnt"`;
    $joints = `nas_getTopJoints "*_Hand_*_Finger_*_Bind_01_Jnt"`;
    $topJoints = stringArrayRemove($joints, $topJoints);
    $joints = `nas_getTopJoints "*_Hand_*_Cup_*_Bind_01_Jnt"`;
    $topJoints = stringArrayRemove($joints, $topJoints);
    for ($topJoint in $topJoints) {
        clear $fingerJoints;
        $name = `nas_getNameFromBind $topJoint`;
        $array = stringToStringArray($topJoint, "_");
        for ($joint in $joints) {
            $array2 = stringToStringArray($joint, "_");
            if ($array[0] == $array2[0] && $array[2] == $array2[2]) {
                $fingerJoints[size($fingerJoints)] = $joint;
            }
        }
        select -r $topJoint $fingerJoints;
        $array = `nas_rigHand ($array[0] + "_" + $array[1] + "_" + $array[2]) z`;
        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        $ctrl = $array[2];

        $array = stringToStringArray($ctrlGroup, "_");
        $targetNode = ($array[0] + "_Arm_" + $array[2] + "_Lower_Bind_End_Jnt_Group");
        if (`objExists $targetNode`) parentConstraint -mo $targetNode $ctrlGroup;
        scaleConstraint -mo ($array[0] + "_Arm_" + $array[2] + "_Master_Null") $ctrlGroup;

        $array = stringToStringArray($name, "_");        
        parent $jntGroup ($array[0] + "_Arm_" + $array[2] + "_Jnt_Master_Group");
        parent $ctrlGroup $upperBodyCtrlGroup;
    }
    
    //======================================create upper body group======================================
    $lowerBodyJntGroup = `group -em -n "Lower_Body_Jnt_Group"`;
    $lowerBodyCtrlGroup = `group -em -n "Lower_Body_Ctrl_Group"`;
    $lowerBodyDeformerGroup = `group -em -n "Lower_Body_Deformer_Group"`;
    
    //......................................build legs......................................
    nas_progress 0 "building legs";
    clear $jntGroups;
    clear $ctrlGroups;
    clear $deformerGroups;
    $topJoints = `nas_getTopJoints "*_Leg_*_Bind_*_Jnt"`;
    for ($topJoint in $topJoints) {
        select -r $topJoint;
        $name = `nas_getNameFromBind $topJoint`;
        $array = `nas_rigLimb $name $legPoleDir 1`;
        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        $deformerGroup = $array[2];
        $scaleMD = $array[3];
        $masterLoc = $array[4];
        
        select -r ($name + "_FK_01_Ctrl");
        $array = `nas_controls "surfaceDoublePin"`;
        setAttr -type "string" ($array[0] + ".nickCtrlType") "char";
        nas_colorControls "blue" 1;
        nas_shadeControls "blue";
        $array[0] = `rename $array[0] "doublePin"`;
        scale -r 2 2 2 $array[0];
        select -r $array[0] ($name + "_FK_01_Ctrl");
        nas_parentShape 1;
        
        $joints = `listRelatives -c $hipJntGroup`;
        $array = `parentConstraint -mo $joints[size($joints)-1] $cogNull $transform $offset $masterLoc`;
        $constraints[0] = $array[0];
        $array = `scaleConstraint -mo $joints[size($joints)-1] $cogNull $transform $offset $masterLoc`;
        $constraints[1] = $array[0];
        
        $array = `listRelatives -c -type transform $masterLoc`;
        $masterCtrl = $array[0];
        
        for ($i = 0; $i < 2; $i++) {
            setDrivenKeyframe -at ($joints[size($joints)-1] + "W0") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 0 -value 1 $constraints[$i];
            setDrivenKeyframe -at ($joints[size($joints)-1] + "W0") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 1 -value 0 $constraints[$i];
            setDrivenKeyframe -at ($cogNull + "W1") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 0 -value 0 $constraints[$i];
            setDrivenKeyframe -at ($cogNull + "W1") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 1 -value 1 $constraints[$i];
            setDrivenKeyframe -at ($cogNull + "W1") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 2 -value 0 $constraints[$i];
            setDrivenKeyframe -at ($transform + "W2") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 1 -value 0 $constraints[$i];
            setDrivenKeyframe -at ($transform + "W2") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 2 -value 1 $constraints[$i];
            setDrivenKeyframe -at ($transform + "W2") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 3 -value 0 $constraints[$i];
            setDrivenKeyframe -at ($offset + "W3") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 2 -value 0 $constraints[$i];
            setDrivenKeyframe -at ($offset + "W3") -currentDriver ($masterCtrl + ".Follow") -itt linear -ott linear -driverValue 3 -value 1 $constraints[$i];
        }
        
        scaleConstraint ($name + "_Master_Null") $jntGroup;
        $masterScaleMD = `createNode -n ($name + "_Jnt_Master_Scale_MD") multiplyDivide`;
        connectAttr ($skeleton + ".sx") ($masterScaleMD + ".input1X");
        connectAttr ($jntGroup + ".sx") ($masterScaleMD + ".input2X");
        connectAttr ($masterScaleMD + ".outputX") ($scaleMD + ".input2X");
        
        parent $jntGroup $lowerBodyJntGroup;
        parent $masterLoc $lowerBodyCtrlGroup;
        parent $ctrlGroup $lowerBodyCtrlGroup;
        parent $deformerGroup $lowerBodyDeformerGroup;
    }
    
    //......................................build feet......................................
    nas_progress 0 "building feet";
    clear $jntGroups;
    clear $ctrlGroups;
    clear $deformerGroups;
    $topJoints = `nas_getTopJoints "*_Foot_*_Bind_01_Jnt"`;
    for ($topJoint in $topJoints) {
        $name = `nas_getNameFromBind $topJoint`;
        $array = stringToStringArray($topJoint, "_");
        $ikCtrl = ($array[0] + "_Leg_" + $array[2] + "_IK_01_Ctrl");
        if ($array[0] == "RT") $array = `nas_rigFoot $name $ikCtrl ($name + "_Heel_Loc") ($name + "_Toe_Loc") ($name + "_Bind_01_Jnt") "x" "y" "z"`;
        else $array = `nas_rigFoot $name $ikCtrl ($name + "_Heel_Loc") ($name + "_Toe_Loc") ($name + "_Bind_01_Jnt") "x" "-y" "-z"`;
        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        //$deformerGroup = $array[2];
        $ikCtrlGroup = $array[3];
        $tipNull = $array[4];
        $masterLoc = $array[5];
        $joint = $array[6];
        parent $ikCtrlGroup $ikCtrl;
        $array = `listRelatives -ad $tipNull`; 
        parent ($ikCtrl + "_Null") $array[0];
        
        $array = stringToStringArray($ctrlGroup, "_");
        $targetNode = ($array[0] + "_Leg_" + $array[2] + "_RK_04_Jnt");
        if (`objExists $targetNode`) {
            parentConstraint -mo $targetNode $masterLoc;
            scaleConstraint -mo $targetNode $masterLoc;
            parentConstraint -mo $targetNode $joint;
            scaleConstraint -mo $targetNode $joint;
        }
        
        connectAttr ("Transform." + $array[0] + "_Leg_" + $array[2] + "_IKFK") ("Transform." + $array[0] + "_Foot_" + $array[2] + "_IKFK");
        setAttr -k 0 -l 1 ("Transform." + $array[0] + "_Foot_" + $array[2] + "_IKFK");
        
        parent $jntGroup $lowerBodyJntGroup;
        parent $ctrlGroup $lowerBodyCtrlGroup;
        //parent $deformerGroup $lowerBodyDeformerGroup;
        
        $array = `nas_controls "surfaceFoot"`;
        //delete `pointConstraint $ikCtrl $array[0]`;
        $wp = `xform -ws -q -rp $ikCtrl`;
        move -ws $wp[0] 0 $wp[2] $array[0];
        select -r $array[0] $ikCtrl;
        nas_parentShape 1;
    }
    
    //......................................build toes......................................
    nas_progress 0 "building toes";
    clear $jntGroups;
    clear $ctrlGroups;
    $topJoints = `nas_getTopJoints "*_Ball_*_Bind_01_Jnt"`;
    $joints = `nas_getTopJoints "*_Ball_*_Toe_*_Bind_01_Jnt"`;
    $topJoints = stringArrayRemove($joints, $topJoints);
    for ($topJoint in $topJoints) {
        clear $fingerJoints;
        $array = stringToStringArray($topJoint, "_");
        for ($joint in $joints) {
            $array2 = stringToStringArray($joint, "_");
            if ($array[0] == $array2[0] && $array[2] == $array2[2]) {
                $fingerJoints[size($fingerJoints)] = $joint;
            }
        }
        select -r $topJoint;
        $array = `nas_rigToes ($array[0] + "_" + $array[1] + "_" + $array[2]) z `;
        $jntGroup = $array[0];
        $ctrlGroup = $array[1];
        $masterLocs = stringArrayRemove({$jntGroup, $ctrlGroup}, $array);

        $array = stringToStringArray($ctrlGroup, "_");
        $targetNode = ($array[0] + "_Foot_" + $array[2] + "_Bind_03_Jnt");
        if (`objExists $targetNode`) {
            select -r $targetNode $masterLocs;
            nas_massConstrain 0 "parent" 1;
            nas_massConstrain 0 "scale" 1;
        }
        
        parent $jntGroup $lowerBodyJntGroup;
        parent $ctrlGroup $lowerBodyCtrlGroup;
        delete $topJoint;
    }
    
    //......................................parent ctrl, jnt, and deformer groups......................................
    nas_progress 0 "parenting rig into main groups";
    $jntGroups = {$headJntGroup, $torsoJntGroup, $upperBodyJntGroup, $lowerBodyJntGroup};
    $ctrlGroups = {$headCtrlGroup, $torsoCtrlGroup, $upperBodyCtrlGroup, $lowerBodyCtrlGroup};
    $deformerGroups = {$upperBodyDeformerGroup, $lowerBodyDeformerGroup};
    
    for ($group in $jntGroups) if (`objExists $group`) catchQuiet(`parent $group $skeleton`);
    for ($group in $ctrlGroups) if (`objExists $group`) catchQuiet(`parent $group $cogNull`);
    catchQuiet(`parent $cogCtrlGroup $transform`);
    for ($group in $deformerGroups) if (`objExists $group`) catchQuiet(`parent $group $deformers`);
    
    //......................................connect scale nodes......................................
    nas_progress 0 "connecting skeleton scale to scale MDs";
    scaleConstraint -mo $transform $skeleton;
    for ($scaleMD in $scaleMDs) {
        connectAttr ($skeleton + ".sx") ($scaleMD + ".input2X");
        connectAttr ($skeleton + ".sx") ($scaleMD + ".input2Y");
        connectAttr ($skeleton + ".sx") ($scaleMD + ".input2Z");
    }
    
    //......................................constrain ik follow......................................
    nas_progress 0 "setting up ik follow set driven keys";
    $ikCtrls = `ls "*_*_*_IK_01_Ctrl"`;
    for ($i = 0; $i < size($ikCtrls); $i++) {
        $array = stringToStringArray($ikCtrls[$i], "_");
        $masterCtrl = ($array[0] + "_" + $array[1] + "_" + $array[2] + "_Master_Null");
        $array = `listRelatives -p $ikCtrls[$i]`;
        $group = $array[0];
        $array = `parentConstraint -mo $cogNull $transform $offset $masterCtrl $group`;
        $constraint = $array[0];
        setDrivenKeyframe -at ($cogNull + "W0") -currentDriver ($ikCtrls[$i] + ".Follow") -itt linear -ott linear -driverValue 0 -value 1 $constraint;
        setDrivenKeyframe -at ($cogNull + "W0") -currentDriver ($ikCtrls[$i] + ".Follow") -itt linear -ott linear -driverValue 1 -value 0 $constraint;
        setDrivenKeyframe -at ($transform + "W1") -currentDriver ($ikCtrls[$i] + ".Follow") -itt linear -ott linear -driverValue 0 -value 0 $constraint;
        setDrivenKeyframe -at ($transform + "W1") -currentDriver ($ikCtrls[$i] + ".Follow") -itt linear -ott linear -driverValue 1 -value 1 $constraint;
        setDrivenKeyframe -at ($transform + "W1") -currentDriver ($ikCtrls[$i] + ".Follow") -itt linear -ott linear -driverValue 2 -value 0 $constraint;
        setDrivenKeyframe -at ($offset + "W2") -currentDriver ($ikCtrls[$i] + ".Follow") -itt linear -ott linear -driverValue 1 -value 0 $constraint;
        setDrivenKeyframe -at ($offset + "W2") -currentDriver ($ikCtrls[$i] + ".Follow") -itt linear -ott linear -driverValue 2 -value 1 $constraint;
        setDrivenKeyframe -at ($offset + "W2") -currentDriver ($ikCtrls[$i] + ".Follow") -itt linear -ott linear -driverValue 3 -value 0 $constraint;
        setDrivenKeyframe -at ($masterCtrl + "W3") -currentDriver ($ikCtrls[$i] + ".Follow") -itt linear -ott linear -driverValue 2 -value 0 $constraint;
        setDrivenKeyframe -at ($masterCtrl + "W3") -currentDriver ($ikCtrls[$i] + ".Follow") -itt linear -ott linear -driverValue 3 -value 1 $constraint;
        
        $array = stringToStringArray($ikCtrls[$i], "_");
        $array[size($array)-1] = "remove";
        $array[size($array)-2] = "remove";
        $array = stringArrayRemove({"remove"}, $array);
        $group = (stringArrayToString($array, "_") + "_PoleVector_Ctrl_Group");
        $poleVectorCtrl = (stringArrayToString($array, "_") + "_PoleVector_Ctrl");
        $array = stringArrayRemove({$array[size($array)-1]}, $array);
        
        $array = `parentConstraint -mo $cogNull $transform $offset $group`;
        $constraint = $array[0];
        setDrivenKeyframe -currentDriver ($poleVectorCtrl + ".Follow") -itt linear -ott linear -driverValue 0 -value 0 ($constraint + "." + $cogNull + "W2");
        setDrivenKeyframe -currentDriver ($poleVectorCtrl + ".Follow") -itt linear -ott linear -driverValue 1 -value 1 ($constraint + "." + $cogNull + "W2");
        setDrivenKeyframe -currentDriver ($poleVectorCtrl + ".Follow") -itt linear -ott linear -driverValue 2 -value 0 ($constraint + "." + $cogNull + "W2");
        
        setDrivenKeyframe -currentDriver ($poleVectorCtrl + ".Follow") -itt linear -ott linear -driverValue 1 -value 0 ($constraint + "." + $transform + "W3");
        setDrivenKeyframe -currentDriver ($poleVectorCtrl + ".Follow") -itt linear -ott linear -driverValue 2 -value 1 ($constraint + "." + $transform + "W3");
        setDrivenKeyframe -currentDriver ($poleVectorCtrl + ".Follow") -itt linear -ott linear -driverValue 3 -value 0 ($constraint + "." + $transform + "W3");
        
        setDrivenKeyframe -currentDriver ($poleVectorCtrl + ".Follow") -itt linear -ott linear -driverValue 2 -value 0 ($constraint + "." + $offset + "W4");
        setDrivenKeyframe -currentDriver ($poleVectorCtrl + ".Follow") -itt linear -ott linear -driverValue 3 -value 1 ($constraint + "." + $offset + "W4");
        setDrivenKeyframe -currentDriver ($poleVectorCtrl + ".Follow") -itt linear -ott linear -driverValue 4 -value 0 ($constraint + "." + $offset + "W4");
    }
    
    //......................................clean up......................................
    nas_progress 0 "hide deformers, create layers, and rename shading nodes";
    setAttr ($deformers + ".v") 0;
    nas_createLayers;
    nas_renameShadingGroupsAndInfos;
    //Set segment scale compensate for all joints in Skeleton.
    $joints = `listRelatives -ad -type joint Skeleton`;
    for ($joint in $joints) {
        setAttr ($joint + ".segmentScaleCompensate") 0;
    }
    
    nas_progress 0 "end";
    print "Systems Assembled!";
}

//-------------------------------------------------------------nas_locsOnCurve---------------------------------------------------------------------
global proc string[] nas_locsOnCurve(int $num) {
    global string $nasLocsOnCurveLocs[];
    string $array[], $curve, $locs[], $motionPath;
    float $percent;
    
    $array = `ls -sl`;
    $curve = $array[0];

    if ($num < 2) error "number of locs created must equal 2 or greater";
    if (size($array) == 0) error "please select curve to create locators on";
    
    for ($loc in $nasLocsOnCurveLocs) if (`objExists $loc`) delete $loc;
    
    $percent = 1.0 / ($num-1);
    for ($i = 0; $i < $num; $i++) {
        $array = `spaceLocator -p 0 0 0`;
        $locs[$i] = $array[0];    
        $motionPath = `pathAnimation -fractionMode true -follow false -startTimeU 0 -endTimeU 1 $locs[$i] $curve`;
        cutKey -cl -t ":" -f ":" -at "uVa    lue" $motionPath;
        setAttr ($motionPath + ".uValue") ($i*$percent);
    }
    $nasLocsOnCurveLocs = $locs;
    return $locs;
}

//-------------------------------------------------------------nas_listWindow---------------------------------------------------------------------
//creates a simple window that shows the passed in array as a list
//user provides a message to be displayed before the list and an array that will be displayed as a list
global proc nas_listWindow(string $message, string $entries[]) {
    string $finalOutput, $window, $form, $files[], $array[], $path;

    $finalOutput = ($message + ":\n");
    $finalOutput += stringArrayToString($entries, "\n");

    $window = `nas_window $message 1 0 0`;
    $form = `formLayout`;
        $text = `text -label $finalOutput`;
        setParent..;
    formLayout -e 
        -af $text "top" 5
        -af $text "left" 5
        -af $text "right" 5
        -af $text "bottom" 5 
        $form;
    window -e -rtf 1 $window;
    showWindow $window;
}

//-------------------------------------------------------------nas_listFileTextures---------------------------------------------------------------------
//lists the file texture nodes of your selection
global proc nas_listFileTextures() {
    string $finalOutput, $window, $form, $files[], $array[], $path;
    
    $files = `ls -sl -type file`;
    for ($i = 0; $i < size($files); $i++) {
        $path = `getAttr ($files[$i] + ".fileTextureName")`;
        $array = stringToStringArray($path, "/");
        $files[$i] = $array[size($array)-1];
    }
    $files = `sort $files`;

    nas_listWindow "Selected files" $files;
}

//-------------------------------------------------------------nas_fileResCheck---------------------------------------------------------------------
//creates a batch render with correct naming for down res'ing a set texture
//user must select a shader and all of it's members before running
global proc nas_fileResCheck() {
    string $file, $array[], $fileNodes[], $asset, $res, $asset, $result, $shader, $shaderNodes[];
    
    $array = `ls -sl`;    
    for ($item in $array) if (`nodeType $item` == "file") $fileNodes[size($fileNodes)] = $item;
    if (size($fileNodes) < 1) error "please select file texture nodes before running";
    for ($item in $array) if (`nodeType $item` == "mia_material_x_passes") $shaderNodes[size($shaderNodes)] = $item;
    
    $array = stringToStringArray($fileNodes[0], ":");
    $array = stringToStringArray($array[size($array)-1], "_");
    $asset = $array[1];

    $array = stringToStringArray($shaderNodes[0], ":");
    $array = stringToStringArray($array[size($array)-1], "_");
    stringArrayRemoveAtIndex(0, $array);
    stringArrayRemoveAtIndex(size($array)-1, $array);
    $shader = stringArrayToString($array, "_");
    
    $result = `promptDialog -title "Resolution" -ma "center" -message "What is the resolution of texture?" -text "2048" -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
    if ($result == "OK") {
        $res = `promptDialog -query -text`;
        setAttr "miDefaultOptions.finalGather" 0;
    
        $result = `promptDialog -title "Asset" -ma "center" -message "What is the name of asset?" -text $asset -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
        if ($result == "OK") {
            $asset = `promptDialog -query -text`;
        
            $result = `promptDialog -title "Shader" -ma "center" -message "What is the name of shader?" -text $shader -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
            if ($result == "OK") {
                $shader = `promptDialog -query -text`;

                for ($item in $fileNodes) {
                    $file = `getAttr ($item + ".fileTextureName")`;
                    $array = stringToStringArray($file, ".");
                    setAttr -type "string" ($item + ".fileTextureName") ($array[0] + ".tif");
                
                    $currFile = `getAttr ($item + ".fileTextureName")`;
                    for ($tex in `ls -typ file -type mentalrayTexture`) {
                        if (`getAttr ($tex + ".ftn")` == $currFile) {
                            setAttr ($tex + ".ftn") -type "string" $currFile;
                        }
                    }
                }

                if (size($shader)) setAttr defaultRenderGlobals.imageFilePrefix -type "string" ("Rusty_Po_Village/" + $asset + "/" + $shader + "/" + $res + $shader);
                else setAttr defaultRenderGlobals.imageFilePrefix -type "string" ("Rusty_Po_Village/" + $asset + "/" + $res + $shader);
                
                nas_hideObjsWithoutMaterial;
                setMayaSoftwareFrameExt(2, 0);
                BatchRender;
            }
        }
    }
    print "Go to photoshop and save out new resolutions and run this again.";
}

//-------------------------------------------------------------nas_reloadTextures---------------------------------------------------------------------
//reloads file texture nodes for mental ray renders
//user must select file texture nodes before running; selection can be lazy because the script filters through selection and finds file texture nodes
global proc nas_reloadTextures() {
    string $file, $array[], $fileNodes[], $asset, $res, $asset, $result, $shader, $shaderNodes[];
    
    $array = `ls -sl`;    
    for ($item in $array) if (`nodeType $item` == "file") $fileNodes[size($fileNodes)] = $item;
    if (size($fileNodes) < 1) error "please select file texture nodes before running";
    
    for ($item in $fileNodes) {
        $currFile = `getAttr ($item + ".fileTextureName")`;
        for ($tex in `ls -typ file -type mentalrayTexture`) {
            if (`getAttr ($tex + ".ftn")` == $currFile) {
                setAttr ($tex + ".ftn") -type "string" $currFile;
            }
        }
    }
    print ((size($fileNodes)) + " textures reloaded.");
}

//-------------------------------------------------------------nas_hideObjsWithoutMaterial---------------------------------------------------------------------
//hides all geo that is not connected to selected shader
global proc nas_hideObjsWithoutMaterial() {
    global string $nas_hideObjsWithoutMaterialHides[];
    string $file, $array[], $shader, $shadingGroup, $nodes[], $hides[], $keeps[];
    
    $nas_hideObjsWithoutMaterialHides = `ls -type mesh`;
    $nodes = `ls -sl`;
    for ($item in $nodes) {
        if (`nodeType $item` == "mia_material_x_passes") {
            $shader = $item;
            break;
        }
    }
    
    $array = `listConnections -d 1 $shader`;
    for ($item in $array) {
        if (`nodeType $item` == "shadingEngine") {
            $shadingGroup = $item;
            break;
        }
    }
    
    hyperShade -objects $shadingGroup;
    $keeps = `ls -sl`;
    $nas_hideObjsWithoutMaterialHides = stringArrayRemove($keeps, $nas_hideObjsWithoutMaterialHides);
    select -r $nas_hideObjsWithoutMaterialHides;
    hide;
    select -r $nodes;
}

//-------------------------------------------------------------nas_showObjsWithoutMaterial---------------------------------------------------------------------
//unhides previously geo that was hidden when using nas_hideObjsWithoutMaterial
global proc nas_showObjsWithoutMaterial() {
    global string $nas_hideObjsWithoutMaterialHides[];
    string $nodes[];
    $nodes = `ls -sl`;
    select -r $nas_hideObjsWithoutMaterialHides;
    showHidden -b;
    select -r $nodes;
}
/*
//-------------------------------------------------------------nas_finalCharacterUI---------------------------------------------------------------------
//--nas_window, nas_recconectSmooths, nas_renameSmoothProxies, nas_buttonFormLayout
global proc nas_finalCharacterUI() {
    if (size(`lsUI -type window`) <= 0) return;        //checks if the user is running maya interactively (as opposed to mayabatch).
    string $window, $labels[], $commands[], $annotations[], $cmd, $rows[], $users[], $buttons[], $form, $masterForm, $text;
    int $buttonWidth, $numButtons;
    
    $buttonWidth = 60;
    $window = `nas_window nas_finalCharacterUI 1 0 0`;
    
    $labels = {"Smooth", "Import Shaders", "Rename SGs and Infos"};
    $commands = {"nas_reconnectSmooths", "nas_importShaders", "nas_renameShadingGroupsAndInfos"};
    $annotations = {"deletes all smooth nodes and re-applies and connects to all polygons in scene",
            "finds out what assigned faces of materials, deletes materials, imports new materials, and assigns them to correct faces", 
            "renames all of the smooth proxies to sequential naming and makes sure shading group names of char shaders are correct"};
    /*
    $labels = {"Import", "Pupil", "Smooth", "MPanels", "WNotes", "Save"};
    $commands = {"nas_importKFShaders", "nas_connectEyePupil", "nas_reconnectSmooths", "nick_CleanModelPanels", "nas_worldNotes", "nas_saveScene"};
    $annotations = {
        "Imports shaders for the selected shaders",
        "Connects the eye pupil attribute to the shader",
        "Deletes smooths in the scene, smooths all meshes, and connects all smooths with the proper attribute settings",
        "Cleans excess model panels", 
        "Opens world notes on execution", 
        "Saves scene after closing all windows & setting shading mode to bounding box"};
    
    $masterForm = `formLayout`;
    $form = `nas_buttonFormLayout $labels $commands $annotations`;
    $text = `text -align "right" -label "click to run:"`;
    setParent..;
    
    formLayout -e
        -af $text "top" 0
        -af $text "bottom" 0
        -af $text "left" 0
        
        -af $form "top" 0
        -af $form "bottom" 0
        -ac $form "left" 0 $text
        -af $form "right" 0
        $masterForm;
    
    $numButtons = size($labels);
    window -e -wh (68+$numButtons*100+80) (34+1*22+20) $window;
    showWindow $window;
    print ("\n" + $window + "\n");
}
*/
//-------------------------------------------------------------nas_charNameFromFile---------------------------------------------------------------------
global proc string nas_charNameFromFile() {
    string $charName, $parts[], $array[], $types[];
    int $cutIndex, $stop;

    $charName = `file -q -shortName -sceneName`;
    $parts = stringToStringArray($charName, "_");
    stringArrayRemoveAtIndex(0, $parts);

    $types = {"Rig", "Clean", "UV", "NK.ma"};
    for ($i = 0; $i < size($parts); $i++) {
        for ($type in $types) {
            if ($parts[$i] == $type) {
                $cutIndex = $i;
                $stop = 1;
                break;
            }
        }
        if ($stop) break;
    }

    $numParts = size($parts);
    for ($i = $cutIndex; $i < $numParts; $i++) stringArrayRemoveAtIndex((size($parts)-1), $parts);

    $charName = stringArrayToString($parts, "_");
    return $charName;
}

//-------------------------------------------------------------nas_deleteUnusedShadingGroups---------------------------------------------------------------------
//deletes any shading groups that aren't connected or in a render layer
global proc nas_deleteUnusedShadingGroups() {
    string $objs[], $layers[], $shaders[];
    int $connected, $delete;
    
    for ($shadingGroup in `ls -long -sets`) {
        $connected = 0;
        $delete = 0;
        if (`objExists $shadingGroup`) {
            if (`sets -q -renderable $shadingGroup`) {
                if ($shadingGroup != "initialShadingGroup" && $shadingGroup != "initialParticleSE" && $shadingGroup != "defaultLightSet" && $shadingGroup != "defaultObjectSet") {
                    // connection to dag objects
                    $objs = `sets -q $shadingGroup`;
                    $layers = `listConnections -type renderLayer $shadingGroup`;
        
                    if (size($objs) == 0 && size($layers) == 0) {
                        $delete = 1;
                    } else {            //    check to make sure at least one shader is connected to the group
                        $shaders = {".surfaceShader",
                                ".volumeShader",
                                ".displacementShader",
                                ".miMaterialShader",
                                ".miShadowShader",
                                ".miVolumeShader",
                                ".miPhotonShader",
                                ".miPhotonVolumeShader",
                                ".miDisplacementShader",
                                ".miEnvironmentShader",
                                ".miLightMapShader",
                                ".miContourShader"
                                }; 
                        for($shader in $shaders) {
                            if(size(`listConnections ($shadingGroup + $shader)`)) {
                                $connected = 1;
                                break;
                            }
                        }
                        if(!$connected) $delete = 1;
                    }
                }
            }
        }
        if ($delete) deleteIfNotReferenced $shadingGroup;
    }
}

//-------------------------------------------------------------nas_listCharShaders---------------------------------------------------------------------
global proc string[] nas_listCharShaders() {
    string $charName, $shaders[], $allShaders[], $array[], $types[];
    
    $charName = `nas_charNameFromFile`;
    $types = {"blinn", "lambert", "mia_material_x_passes", "phongE", "mix8layer", "mia_material_x"};
    for ($type in $types) $allShaders = stringArrayCatenate(`ls -type $type`, $allShaders);
    $allShaders = stringArrayRemoveDuplicates($allShaders);
    
    //finds char name shaders
    for ($allShader in $allShaders) {
        $array = stringToStringArray($allShader, "_");
        if ($array[0] == $charName) $shaders[size($shaders)] = $allShader;
    }
    return $shaders;
}

//-------------------------------------------------------------nas_renameSmoothProxies---------------------------------------------------------------------
global proc nas_renameSmoothProxies() {
    string $shaders[], $proxyShaders[], $connectedShaders[], $array[], $num, $SGs[], $cmd, $allProxyShaders[];
    
    $SGs = nas_geosToShadingGroups(`ls -long "Geometry"`);
    $shaders = nas_geosToShaders(`ls -long "Geometry"`);

    //renames smooth proxy shaders sequentially
    for ($i = 0; $i < size($shaders); $i++) {
        $array = stringToStringArray($shaders[$i], "_");
        for ($item in $array) {
            if ($item == "smoothproxy" || $item == "smoothProxy" || $item == "SmoothProxy" || $item == "Smoothproxy") {
                $num = `nas_framePadding "##" (size($proxyShaders)+1)`;
                $shaders[$i] = `rename $shaders[$i] ("SmoothProxy_" + $num + "_Shader")`;
                $proxyShaders[size($proxyShaders)] = $shaders[$i];
                break;
            }
        }
    }

    //finds shading groups attached to shaders and renames them appropriately
    clear $SGs;
    for ($i = 0; $i < size($shaders); $i++) {
        $array = `listConnections -d 1 $shaders[$i]`;
        for ($item in $array) {
            if (`nodeType $item` == "shadingEngine") {
                $connectedShaders[size($connectedShaders)] = $shaders[$i];
                select -r $item;
                catchQuiet(`rename $item ("tempName" + $i)`);
                $sels = `ls -sl`;
                $SGs[size($SGs)] = $sels[0]; 
                break;
            }
        }
    }

    for ($i = 0; $i < size($connectedShaders); $i++) {
        $array = stringToStringArray($connectedShaders[$i], "_");
        stringArrayRemoveAtIndex(size($array)-1, $array);
        $cmd = ("rename " + $SGs[$i] + " " + (stringArrayToString($array, "_") + "_SG"));
        catchQuiet(eval($cmd));
    }
    
    for ($material in `ls -mat`) {
        $array = stringToStringArray($material, "_");
        for ($item in $array) {
            if ($item == "smoothproxy" || $item == "smoothProxy" || $item == "SmoothProxy" || $item == "Smoothproxy") {
                $allProxyShaders[size($allProxyShaders)] = $material;
                break;
            }
        }
    }
    
    delete(stringArrayRemove($proxyShaders, $allProxyShaders));
}

//-------------------------------------------------------------nas_outlineLayout---------------------------------------------------------------------
global proc nas_outlineLayout(string $message, string $entries, string $label, string $cmd) {
}

//-------------------------------------------------------------nas_ctrlChecker---------------------------------------------------------------------
global proc nas_ctrlChecker() {
    global string $nas_ctrlCheckerLocked[], $nas_ctrlCheckerValued[], $nas_ctrlCheckerKeyed[];
    string $array[], $ctrls[], $keyed[], $valued[], $locked[], $attrs[];
    
    $ctrls = `ls -type transform "*_Ctrl"`;
    $ctrls = stringArrayCatenate($ctrls, {"Transform", "COG"});
    
    for ($ctrl in $ctrls) {
        if (`objExists $ctrl`) {
            $attrs = `listAttr -k $ctrl`;
            for ($attr in $attrs) {
                if (`getAttr -k ($ctrl + "." + $attr)` && `getAttr -l ($ctrl + "." + $attr)`) $locked[size($locked)] = ($ctrl + "." + $attr);
                if (`getAttr ($ctrl + "." + $attr)` != 0 && `getAttr ($ctrl + "." + $attr)` != 1 && `getAttr ($ctrl + "." + $attr)` != 10 && `getAttr -l ($ctrl + "." + $attr)` == 0) {
                    print ("\n" + ($ctrl + "." + $attr) + " = " + `getAttr ($ctrl + "." + $attr)`);
                    $valued[size($valued)] = ($ctrl + "." + $attr);
                }
                if (`keyframe -q -keyframeCount ($ctrl + "." + $attr)`) $keyed[size($keyed)] = ($ctrl + "." + $attr);
            }
        }
    }
    $locked = stringArrayRemoveDuplicates($locked);
    $valued = stringArrayRemoveDuplicates($valued);
    $keyed = stringArrayRemoveDuplicates($keyed);
    
    $nas_ctrlCheckerLocked = $locked;
    $nas_ctrlCheckerValued = $valued;
    $nas_ctrlCheckerKeyed = $keyed;
    
    if (size($locked)) nas_listWindow "The following ctrls have locked attributes that are showing" $locked;
    if (size($valued)) nas_listWindow "The following ctrls have values on them" $valued;
    if (size($keyed)) nas_listWindow "The following ctrls have keyed attributes on them" $keyed;
}

//-------------------------------------------------------------nas_isMember---------------------------------------------------------------------
global proc int nas_isMember(string $query, string $members[]) {
    int $isMember;
    for ($member in $members) {
        if ($query == $member) {
            $isMember = 1;
            break;
        }
    }
    return $isMember;
}

//-------------------------------------------------------------nas_setAttr---------------------------------------------------------------------
global proc nas_setAttr(string $objects[], string $attrs[], float $values[]) {    
    for ($object in $objects) {
        for ($i = 0; $i < size($attrs); $i++) {
            if (`objExists ($object + "." + $attrs[$i])`) {
                if (catchQuiet(`setAttr ($object + "." + $attrs[$i]) $values[$i]`)) {
                    print ("setAttr " + $object + "." + $attrs[$i] + " " + $values[$i] + ";\n");
                }
            }
        }
    }
}

//-------------------------------------------------------------nas_setAttrs---------------------------------------------------------------------
global proc nas_setAttrs(string $ctrls[], string $attrs[], float $value) {
    for ($ctrl in $ctrls) {
        for ($attr in $attrs) {
            if (`objExists ($ctrl + "." + $attr)`) {
                $cmd = ("setAttr \"" + $ctrl + "." + $attr + "\" " + $value + ";");
                catchQuiet(eval($cmd));
            }
        }
    }
}

//-------------------------------------------------------------nas_lockHideAttrs---------------------------------------------------------------------
global proc nas_lockHideAttrs(string $ctrls[], string $attrs[]) {
    for ($ctrl in $ctrls) {
        for ($attr in $attrs) {
            if (`objExists ($ctrl + "." + $attr)`) {
                $cmd = ("setAttr -lock 1 -keyable 0 -cb 0 \"" + $ctrl + "." + $attr + "\";");
                catchQuiet(eval($cmd));
            }
        }
    }
}

//-------------------------------------------------------------nas_lockAttrs---------------------------------------------------------------------
global proc nas_lockAttrs(string $ctrls[], string $attrs[], int $lock, int $key, int $channelbox) {
    for ($ctrl in $ctrls) {
        for ($attr in $attrs) {
            if (`objExists ($ctrl + "." + $attr)`) {
                $cmd = ("setAttr -lock " + $lock + " -keyable " + $key + " -cb " + $channelbox + " \"" + $ctrl + "." + $attr + "\";");
                catchQuiet(eval($cmd));
            }
        }
    }
}

//-------------------------------------------------------------nas_finalCharChecks---------------------------------------------------------------------
//performs basic checks on any kung fu panda character
global proc nas_finalCharChecks() {
    string $modelPanels[], $panels[], $tenAttrs[], $offAttrs[], $onAttrs[], $charName, $ctrls[], $shapes[], $array[];
    
    $modelPanels = `getPanel -type modelPanel`;
    $panels = stringArrayRemove((stringArrayRemove(`getPanel -vis`, $modelPanels)), $modelPanels);
    for ($panel in $panels) {
        if (`modelEditor -q -wireframeOnShaded $panel` != 0) modelEditor -e -wireframeOnShaded 0 $panel;
        if (`modelEditor -q -displayAppearance $panel` != "boundingBox") modelEditor -e -displayAppearance boundingBox $panel;
    }
    
    nas_setAttrs {"Transform"} {"LT_Arm_IKFK", "RT_Arm_IKFK", "LT_Leg_IKFK", "RT_Leg_IKFK", "LT_Arm_FollowRoot", "RT_Arm_FollowRoot", "Smooth", "Model"} 0;
    nas_setAttrs {"Transform"} {"Neck_Parent", "LT_Arm_Parent", "RT_Arm_Parent", "LT_Leg_Parent", "RT_Leg_Parent"} 1;
    nas_setAttrs {"ControllerGroupVisibility"} {"FaceControls", "EyeControls", "TeethControls", "ClothingControls", "HornControls", "FatControls", "LeftArmDeformControls", "RightArmDeformControls", "LegDeformControls", "SpineDeformControls", "HeadDeformControls", "StomachDeformControls", "SkaDooshDeformControls"} 0;
    nas_setAttrs {"ControllerGroupVisibility"} {"LeftArm", "RightArm", "Legs", "Head", "Body"} 1;
    nas_setAttrs {"LT_Arm_IK_Ctrl", "RT_Arm_IK_Ctrl", "LT_Leg_IK_Ctrl", "RT_Leg_IK_Ctrl"} {"LockLength"} 1;
    nas_setAttrs {"LT_Arm_IK_Ctrl", "RT_Arm_IK_Ctrl", "LT_Leg_IK_Ctrl", "RT_Leg_IK_Ctrl"} {"Stretchy", "PoleVector_Vis", "KneeStretch", "FootRoll", "LegTwist", "BallTwist", "BallRock", "ToeRoll", "ToePivot", "FrontFootRoll", "FrontFootTwist", "FrontFootRock", "Twist", "ElbowStretch"} 0;
    nas_lockHideAttrs {"LT_Arm_IK_Ctrl", "RT_Arm_IK_Ctrl", "LT_Leg_IK_Ctrl", "RT_Leg_IK_Ctrl"} {"MaintainBend"};
    
    if (size(`ls "Transform"`)==1) nas_lockAttrs {"Transform"} {"Smooth", "Model"} 0 0 1;
    
    if (size(`ls "Skeleton"`)==1) {
        nas_lockAttrs {"Skeleton"} {"visibility"} 0 1 1;
        nas_setAttr {"Skeleton"} {"v"} {0};
    }
    
    if (size(`ls "Deformers"`)==1) {
        nas_lockAttrs {"Deformers"} {"visibility"} 0 1 1;
        nas_setAttr {"Deformers"} {"v"} {0};
    }

    $charName = `nas_charNameFromFile`;
    nas_setAttr {"Light_Rig", "EyesTongueTeeth_Mesh", ($charName + "_Mesh")} {"visibility", "displayType"} {1, 2};    
    nas_setAttr {"Controller_Vis"} {"visibility", "displayType"} {1, 0};
    //nas_setAttr {"persp"} {"tx", "ty", "tz", "rx", "ry", "rz"} {24.0, 18.0, 24.0, -27.938353, 45.0, 0};
    
    $ctrls = `ls -type transform "*_Ctrl"`;
    for ($ctrl in $ctrls) {
        $array = `listRelatives -fullPath -s $ctrl`;
        $shapes = stringArrayCatenate($shapes, $array);
    }
    $shapes = stringArrayRemoveDuplicates($shapes);
    
    nas_setAttr $shapes {"castsShadows", "receiveShadows", "motionBlur", "primaryVisibility", "smoothShading", "visibleInReflections", "visibleInRefractions"} {0, 0, 0, 0, 0, 0, 0};
    nas_setAttr $shapes {"doubleSided"} {1};
    
    clear $shapes;
    if (`objExists "HiRes_Geo_Group"`) {
        $shapes = `listRelatives -fullPath -ad -type mesh "HiRes_Geo_Group"`;
    } else if (`objExists "HiRes"`) {
        rename "HiRes" "HiRes_Geo_Group";
        $shapes = `listRelatives -fullPath -ad -type mesh "HiRes_Geo_Group"`;
    }
    nas_setAttr $shapes {"castsShadows", "receiveShadows", "motionBlur", "primaryVisibility", "smoothShading", "visibleInReflections", "visibleInRefractions", "doubleSided"} {1, 1, 1, 1, 1, 1, 1, 1};
    /*
    string $refs[] = `ls -type reference`;
    for ($ref in $refs) {
        if ($ref != "sharedReferenceNode" && $ref != "KF_LgtRg_Character_ARN") {
            lockNode -l 0 $ref;
            delete $ref;
        }
    }*/
    lockNode -l 0 "renderPartition";

    print "house cleaning done!";    
}

//-------------------------------------------------------------nas_KFUpdateCmd---------------------------------------------------------------------
//updates characters on kung fu panda
global proc nas_KFUpdateCmd() {
    /*
    nas_deleteUnusedShadingNodes(`ls -long "Geometry"`);
    nas_deleteUnusedShadingGroups;
    nas_renameSmoothProxies;
    nas_renameShadingGroupsAndInfos;
    nas_finalCharChecks;
    
    */
    nas_matchUVAssignment "GooseVypac" "GooseVypac";
    nas_killWindows;
}

//-------------------------------------------------------------nas_KFUpdateChars---------------------------------------------------------------------
//updates characters on kung fu panda
global proc nas_KFUpdateChars(string $name, string $cmd) {
    string $names[], $array[], $path, $scene, $parts[], $newName, $command, $version;
    int $versionNum, $successes[], $fromClean, $fromRigging;
    
    file -f -options "v=0" -typ "mayaAscii" -o ("Z:/KFP/Maya_KFP/scenes/Characters/" + `substring $name 1 1` + "/" + $name + "/Old/Clean/KF_" + $name + "_Clean_NK.ma");
    if (`objExists "Transform"` || `objExists ($name + "_Transform")`) {
        $fromClean = 1;
    } else {
        file -f -options "v=0" -typ "mayaAscii" -o ("Z:/KFP/Maya_KFP/scenes/Characters/" + `substring $name 1 1` + "/" + $name + "/Old/Rigging/KF_" + $name + "_Rig_NK.ma");
        if (!`objExists "Transform"`) {
            if (!`objExists ($name + "_Transform")`) {
                print ("\n\n\n==========" + $name + " has no transform in it, so it was not finaled.==========\n\n\n");
            }
        $fromRigging = 1;
        }
    }
    
    if (`objExists "Transform"` || `objExists ($name + "_Transform")`) {
        eval($cmd);
        
        //saving
        $array = `nas_sceneInfo`;
        $path = $array[0];
        $scene = $array[1];
        
        //saves a rig file if file comes from clean
        if ($fromClean) {
            $array = stringToStringArray($path, "/");
            for ($i = 0; $i < size($array); $i++) {
                if ($array[$i] == "Clean" || $array[$i] == "Rig") $array[$i] = "Rigging";
            }
            $path = stringArrayToString($array, "/") + "/";
            $array = stringToStringArray($scene, "_");
            for ($i = 0; $i < size($array); $i++) {
                if ($array[$i] == "Clean" || $array[$i] == "Rig") $array[$i] = "Rig";
            }
            $scene = stringArrayToString($array, "_");
            file -rename ($path + $scene + ".ma");
            file -f -save -options "v=0" -type "mayaAscii";
        }
        
        //saves latest rig file
        $array = sort(`getFileList -folder ($path + "WIP/")`);
        if (size($array) < 4) {
            $parts = stringToStringArray(`basenameEx $array[size($array)-1]`, "_");
            $newName = $parts[0];
            for ($i = 1; $i < size($parts); $i++) {
                if (`gmatch $parts[$i] "v*[0-9]"` || `gmatch $parts[$i] "V*[0-9]"`) {
                    $version = `substring $parts[$i] 2 (size($parts[$i]))`;
                    $versionNum = $version;
                    $versionNum++;
                    $command = "nas_framePadding \"v";
                    for ($j = 0; $j < size($version); $j++) $command += "#";
                    $command += ("\" " + $versionNum);
                    $parts[$i] = `eval $command`;
                } else if ($parts[$i] == "CG" || $parts[$i] == "PS" || $parts[$i] == "DQ") {
                    $parts[$i] = "NK";
                }
                $newName += ("_" + $parts[$i]);
            }
            file -rename ($path + "WIP/" + $newName + ".ma");
            file -f -save -options "v=0" -type "mayaAscii";
        }
        
        //save clean version
        $array = stringToStringArray($path, "/");
        for ($i = 0; $i < size($array); $i++) {
            if ($array[$i] == "Rigging" || $array[$i] == "Rig") $array[$i] = "Clean";
        }
        $path = stringArrayToString($array, "/") + "/";
        $array = stringToStringArray($scene, "_");
        for ($i = 0; $i < size($array); $i++) {
            if ($array[$i] == "Rigging" || $array[$i] == "Rig") $array[$i] = "Clean";
        }
        $scene = stringArrayToString($array, "_");
        file -rename ($path + $scene + ".ma");
        file -f -save -options "v=0" -type "mayaAscii";
    
        //saves latest clean version
        $array = sort(`getFileList -folder ($path + "WIP/")`);
        if (size($array)) {
            $parts = stringToStringArray(`basenameEx $array[size($array)-1]`, "_");
            $newName = $parts[0];
            for ($i = 1; $i < size($parts); $i++) {
                if (`gmatch $parts[$i] "v*[0-9]"` || `gmatch $parts[$i] "V*[0-9]"`) {
                    $version = `substring $parts[$i] 2 (size($parts[$i]))`;
                    $versionNum = $version;
                    $versionNum++;
                    $command = "nas_framePadding \"v";
                    for ($j = 0; $j < size($version); $j++) $command += "#";
                    $command += ("\" " + $versionNum);
                    $parts[$i] = `eval $command`;
                } else if ($parts[$i] == "CG" || $parts[$i] == "PS" || $parts[$i] == "DQ") {
                    $parts[$i] = "NK";
                }
                $newName += ("_" + $parts[$i]);
            }
        } else {
            $newName = ("KF_" + $name + "_Clean_v001_NK");
        }
        file -rename ($path + "WIP/" + $newName + ".ma");
        file -f -save -options "v=0" -type "mayaAscii";
        print ("\n\n\n========== " + $name + " finaled ==========\n\n\n");
    }
}

//-------------------------------------------------------------nas_geosToShadingNetwork---------------------------------------------------------------------
//returns any shading nodes that have to do with specified geos
global proc string[] nas_geosToShadingNetwork(string $geos[]) {
    string $SGs[], $shaders[], $nodes[];

    clear $nodes;
    $SGs = nas_geosToShadingGroups($geos);
    $shaders = nas_geosToShaders($geos);
    for ($shader in $shaders) {
        $nodes = stringArrayCatenate ($nodes, `nas_listNetwork $shader -1 20`);
    }
    $nodes = stringArrayRemoveDuplicates(sort($nodes));
    $nodes = stringArrayCatenate($nodes, $SGs);
    return $nodes;
}

//-------------------------------------------------------------nas_deleteUnusedShadingNodes---------------------------------------------------------------------
//deletes shading, utility, and texture nodes that are not connected to specified geos
global proc nas_deleteUnusedShadingNodes(string $geos[]) {
    string $keepNodes[], $allNodes[], $deleteNodes[], $types[], $array[];
    
    $keepNodes = nas_geosToShadingNetwork($geos);
    
    $types = {"bump2d", "clamp", "file", "mib_color_mix", "place2dTexture", "ramp", "remapHsv", "remapValue", "samplerInfo", "surfaceLuminance"};
    for ($type in $types) {
        $array = `ls -type $type`;
        for ($item in $array) {
            $allNodes[size($allNodes)] = $item;
        }
    }
    $allNodes = stringArrayRemoveDuplicates(sort($allNodes));
    stringArrayRemove($keepNodes, $allNodes);
    $deleteNodes = stringArrayRemove($keepNodes, $allNodes);
    for ($node in $deleteNodes) deleteIfNotReferenced $node;
}

//-------------------------------------------------------------nas_vertsInBoundingBox---------------------------------------------------------------------
global proc string[] nas_vertsInBoundingBox(float $bbs[], int $accuracy) {
    string $geos[], $allVerts[], $verts[], $passVerts[], $array[], $shapes[], $targetGeos[], $sels[];
    int $blockSize;
    float $testbbs[];
    
    $sels = `ls -sl -long`;
    
    //get all geos in scene
    $shapes = `ls -type mesh`;
    for ($i = 0; $i < size($shapes); $i++) {
        $array = `listRelatives -p -type "transform" $shapes[$i]`;
        $geos = stringArrayCatenate($geos, $array);
    }
    $geos = stringArrayRemoveDuplicates(sort($geos));
    
    //find geos that are in the bounding box
    for ($i = 0; $i < size($geos); $i++) {
        $testbbs = `nas_boundingBox {$geos[$i]}`;
        if ($testbbs[0] < $bbs[3] && $testbbs[3] > $bbs[0] && $testbbs[1] < $bbs[4] && $testbbs[4] > $bbs[1] && $testbbs[2] < $bbs[5] && $testbbs[5] > $bbs[2]) {
            $targetGeos[size($targetGeos)] = $geos[$i];
        }
    }
    
    //store all verts from geo that is intersecting
    for ($targetGeo in $targetGeos) $allVerts = stringArrayCatenate($allVerts, `ls -fl ($targetGeo + ".vtx[*]")`);
    
    //find blocks that intersect the bounding box
    if ($accuracy < size($allVerts)) $blockSize = size($allVerts)/$accuracy;
    else $blockSize = 1;
    for ($i = 0; $i < size($allVerts); $i+=$blockSize) {
        clear $array;
        for ($j = $i; $j < ($i + $blockSize); $j++) {
            if ($j >= size($allVerts)) break;
            else $array[size($array)] = $allVerts[$j];
        }
        $testbbs = `nas_boundingBox $array`;
        if ($testbbs[0] < $bbs[3] && $testbbs[3] > $bbs[0] && $testbbs[1] < $bbs[4] && $testbbs[4] > $bbs[1] && $testbbs[2] < $bbs[5] && $testbbs[5] > $bbs[2]) {
            for ($j = $i; $j < ($i + $blockSize); $j++) if ($allVerts[$j] != "") $verts[size($verts)] = $allVerts[$j];
        }
    }
    return $verts;
}

//-------------------------------------------------------------nas_percent---------------------------------------------------------------------
global proc nas_percent(float $weights[], string $deformer, string $verts[], float $buffer) {
    string $currentVerts[], $unmatchedVerts[];
    float $currentWeight, $unmatchedWeights[];
    
    nas_progress (size($verts)) "start";
    for ($i = 0; $i < 1000000000; $i++) {
        if (size($verts) == 0 && size($weights) == 0) break;
        $currentWeight = $weights[0];
        $currentVerts[0] = $verts[0];
        for ($j = 1; $j < size($weights); $j++) {
            if ($weights[$j] >= ($currentWeight - $buffer) && $weights[$j] <= ($currentWeight + $buffer)) {
                $currentVerts[size($currentVerts)] = $verts[$j];
            } else {
                $unmatchedWeights[size($unmatchedWeights)] = $weights[$j];
                $unmatchedVerts[size($unmatchedVerts)] = $verts[$j];
            }
        }
        if ($currentWeight != 0) percent -v $currentWeight $deformer $currentVerts;
        for ($vert in $currentVerts) if (`nas_progress 0 ("applying weights to " + $vert)`) return;
        $weights = $unmatchedWeights;
        $verts = $unmatchedVerts;
        clear $unmatchedWeights;
        clear $unmatchedVerts;
        clear $currentVerts;
    }
    nas_progress 0 "end";
}

//-------------------------------------------------------------nas_stringArrayRemoveDuplicates---------------------------------------------------------------------
global proc string[] nas_stringArrayRemoveDuplicates(string $inputs[]) {
    string $outputs[];
    int $duplicate;
        
    for ($i = 0; $i < size($inputs); $i++) {
        $duplicate = 0;
        for ($j = 0; $j < size($outputs); $j++) {
            if ($inputs[$i] == $outputs[$j]) {
                $duplicate = 1;
                break;
            }
        }
        if ($duplicate == 0) $outputs[size($outputs)] = $inputs[$i];
    }
    return $outputs;
}

//-------------------------------------------------------------nas_stringArrayCatenate---------------------------------------------------------------------
global proc string[] nas_stringArrayCatenate(string $array[], string $adds[]) {
    int $duplicate;
    
    for ($i = 0; $i < size($adds); $i++) {
        $duplicate = 0;
        for ($j = 0; $j < size($array); $j++) {
            if ($adds[$i] == $array[$j]) {
                $duplicate = 1;
                break;
            }
        }
        if ($duplicate == 0) $array[size($array)] = $adds[$i];
    }
    return $array;
}

//-------------------------------------------------------------nas_deformationToClusterInteractive---------------------------------------------------------------------
global proc string[] nas_deformationToClusterInteractive(int $each) {
    string $sels[], $ctrls[], $deformers[], $verts[], $clusters[], $geos[], $shapes[], $array[];
    int $pointCount, $vertCount, $clusterCount;
    
    nas_progress 1 "startOverride";
    nas_progress 0 "";
    $sels = `ls -sl -fl`;
    for ($sel in $sels) {
        $array = `nas_getDeformerInfo $sel`;
        if (`gmatch $sel "*.pt*"` || `gmatch $sel "*.cv*"`) {
            $pointCount++;
        } else if (`gmatch $sel "*.vtx*"`) {
            $vertCount++;
        } else if (size($array) == 2 && size($array[0]) > 0 && size($array[1]) > 0) {
            if (`nodeType $array[0]` == "cluster") $clusterCount++;
        }
    }
    
    if ($pointCount == size($sels)) {        
        $ctrls = $sels;
        for ($sel in $sels) {
            $array = stringToStringArray($sel, ".");
            $deformers = stringArrayCatenate($deformers, {$array[0]});
        }
        for ($deformer in (stringArrayRemoveDuplicates($deformers))) {
            for ($vert in (nas_getDeformerVerts($deformer))) $verts[size($verts)] = $vert;
        }
    } else if ($vertCount == size($sels)) {
        for ($i = 0; $i < size($sels); $i++) {
            $array = stringToStringArray($sels[$i], ".");
            $geos[$i] = $array[0];
        }
        $geos = stringArrayRemoveDuplicates($geos);
        
        for ($vert in `ls -fl "*.vtx[*]"`) {
            $array = stringToStringArray($vert, ".");
            for ($geo in $geos) {
                if ($array[0] == $geo) {
                    $verts[size($verts)] = $vert;
                    break;
                }
            }
        }
    } else if ($clusterCount == size($sels)) {
        $ctrls = $sels;
        for ($sel in $sels) $verts = stringArrayCatenate($verts, `nas_getDeformerVerts($sel)`);
    } else {
        for ($sel in $sels) if (`gmatch $sel "*.vtx*"` || `gmatch $sel "*.pt*"` || `gmatch $sel "*.cv*"`) $verts[size($verts)] = $sel;
        $ctrls = stringArrayRemove($verts, $sels);
    }
    if (size($verts) == 0) error "please select verts, points, or cvs and controls before running";
    $verts = stringArrayRemoveDuplicates($verts);
    
    
    if ($each) {
        nas_progress (size($ctrls)) "start";
        for ($i = 0; $i < size($ctrls); $i++) {
            select -r $ctrls[$i];
            $clusters[size($clusters)] = `nas_deformationToCluster $verts`;
            if (`nas_progress 1 ""`) return{};
        }
    } else {
        select -r $ctrls;
        $clusters[0] = `nas_deformationToCluster $verts`;
    }
    nas_progress 0 "endOverride";
    return $clusters;
}

//-------------------------------------------------------------nas_deformationToCluster---------------------------------------------------------------------
global proc string nas_deformationToCluster(string $verts[]) {
    string $ctrls[], $cmd, $allVerts[], $shortName;
    float $weights[], $targetWp[], $baseWp[], $hypCalcs[], $wp[], $centerWp[], $wp[], $calc, $percent, $diffs[];
    int $numVerts;
    vector $baseVec[], $deformWp[], $vec1, $vec2;
    
    $percent = 1;
    $verts = sort($verts);
    $ctrls = `ls -sl -long`;
    $array = stringToStringArray($ctrls[0], "|");
    $shortName = $array[size($array)-1];
    
    for ($i = 0; $i < size($verts); $i++) if (!`gmatch $verts[$i] "*Proxy*"`) $allVerts[size($allVerts)] = $verts[$i];
    $numVerts = size($allVerts);
    
    //store original positions of verts
    nas_progress ($numVerts*3) "start";
    for ($i = 0; $i < $numVerts; $i++) {
        $baseVec[$i] = `xform -query -translation -worldSpace $allVerts[$i]`;
        if (`nas_progress 1 ("Creating cluster for " + $shortName + " | " + $allVerts[$i] + " - storing")`) return "";
    }
    
    //find which verts move and calculate distance
    move -r 1 1 1;
    for ($i = 0; $i < $numVerts; $i++) {
        $baseWp = $baseVec[$i];
        $targetWp = `xform -ws -q -translation $allVerts[$i]`;
        if ($baseWp[0] != $targetWp[0] || $baseWp[1] != $targetWp[1] || $baseWp[2] != $targetWp[2]) {
                        $diffs[0] = $targetWp[0] - $baseWp[0];
                        $diffs[1] = $targetWp[1] - $baseWp[1];
                        $diffs[2] = $targetWp[2] - $baseWp[2];
                        //print ($allVerts[$i] + "\t" + $diffs[0] + "\t" + $diffs[1] + "\t" + $diffs[2] + "\n");
                        $hypCalcs[0] = `pow $diffs[0] 2`;
                        $hypCalcs[1] = `pow $diffs[1] 2`;
                        $hypCalcs[2] = `pow $diffs[2] 2`;
            $calc = sqrt($hypCalcs[0] + $hypCalcs[1] + $hypCalcs[2]);
            $calc /= sqrt(3);
            $calc *= $percent;
            $weights[$i] = $calc;
        } else {
            $weights[$i] = 0;
        }
        $verts[$i] = $allVerts[$i];
        
        if (`nas_progress 1 ("Creating cluster for " + $shortName + " | " + $allVerts[$i] + " - finding")`) return "";
    }
    move -r -1 -1 -1;
    
    if (size($verts) == 0) error ($ctrls[0] + " does not move any verts. No cluster was created");

    //cluster creation
    //create cluster from selected verts
    $array = `cluster -foc -rel $verts`;
    $cluster = $array[0];
    $clusterHandle = $array[1];

    //find out where the pivot of cluster should be
    for ($ctrl in $ctrls) {
        if (`gmatch $ctrl "*.vtx*"` || `gmatch $ctrl "*.pt*"` || `gmatch $ctrl "*.cv*"`) $wp = `xform -ws -q -translation $ctrl`;
        else $wp = `xform -ws -q -rp $ctrl`;
        $centerWp = {$centerWp[0]+$wp[0], $centerWp[1]+$wp[1], $centerWp[2]+$wp[2]};
    }
    $centerWp = {$centerWp[0]/(size($ctrls)), $centerWp[1]/(size($ctrls)), $centerWp[2]/(size($ctrls))};
    
    //change cluster pivot to centerWp
    xform -ws -rp $centerWp[0] $centerWp[1] $centerWp[2] $clusterHandle;
    xform -ws -sp $centerWp[0] $centerWp[1] $centerWp[2] $clusterHandle;
    $array = `listRelatives -s $clusterHandle`;
    setAttr ($array[0] + ".origin") $centerWp[0] $centerWp[1] $centerWp[2];
    
    //apply weights on verts for new cluster
    select -r $verts;
    percent -v 0 $cluster $verts;
    nas_percent $weights $cluster $verts .001;
    
    /*
    $cmd = ("nmpApiLib.deformers('" + $cluster + "').setWeights([");
    for ($i = 0; $i < size($weights)-1; $i++) $cmd += ($weights[$i] + ",");
    $cmd += ($weights[$i] + "], [");
    for ($i = 0; $i < size($verts)-1; $i++) $cmd += ("'" + $verts[$i] + "', ");
    $cmd += ("'" + $verts[$i] + "'])");
    python($cmd);
    */
    nas_progress 0 "end";
    select -r $clusterHandle;
    return $cluster;
}

//-------------------------------------------------------------nas_deformationToClusterUI---------------------------------------------------------------------
global proc nas_deformationToClusterUI() {
    global string $nas_deformationToClusterUISlider, $nas_deformationToClusterUIField;
    string $window, $form, $button;
    
    $window = `nas_window "nas_deformationToCluster" 1 0 0`;
    $form = `formLayout`;
    
    $nas_deformationToClusterUISlider = `floatSliderGrp -label "Verts To Deform:" -precision 2 -field 1 -fieldMinValue .001 -fieldMaxValue 1000 -minValue 0 -maxValue 3 -value 1 -columnAlign 1 "left" -cw3 100 30 139 -adj 3 -changeCommand "nas_drawBoundingBoxCurve `floatSliderGrp -q -v $nas_deformationToClusterUISlider`"`;
    $text = `text -al "left" -w 100 -label "Multiply Deformation"`;
    $nas_deformationToClusterUIField = `floatField -w 30 -value 1.0`;
    $button = `button -label "Create Cluster" -w 100 -c "nas_deformationToCluster(nas_vertsInBoundingBox((nas_drawBoundingBoxCurve(`floatSliderGrp -q -v $nas_deformationToClusterUISlider`)), 1000), `floatField -q -v $nas_deformationToClusterUIField`);delete nas_boundingBoxVisualizer_Cube"`;
    
    formLayout -e 
        -af $nas_deformationToClusterUISlider "left" 5
        -af $nas_deformationToClusterUISlider "top" 5
        -af $nas_deformationToClusterUISlider "right" 5
        
        -ac $text "top" 0 $nas_deformationToClusterUISlider
        -af $text "bottom" 5
        -af $text "left" 5
        
        -ac $nas_deformationToClusterUIField "top" 0 $nas_deformationToClusterUISlider
        -ac $nas_deformationToClusterUIField "left" 0 $text
        -af $nas_deformationToClusterUIField "bottom" 5
        
        -ac $button "top" 0 $nas_deformationToClusterUISlider
        -ac $button "left" 5 $nas_deformationToClusterUIField
        -af $button "bottom" 5
        -af $button "right" 10
        $form;

    window -e -wh 320 90 $window;
    showWindow $window;
}

//-------------------------------------------------------------nas_drawBoundingBoxCurve---------------------------------------------------------------------
global proc float[] nas_drawBoundingBoxCurve(float $unit) {
    string $sels[], $visualCurve, $attrs[];
    float $bbs[], $wps[];
    
    $sels = `ls -fl -sl`;
    for ($sel in $sels) {
        $wps = `xform -q -ws -translation $sel`;
        if ($wps[0] == 0 && $wps[1] == 0 && $wps[2] == 0) $wps = `xform -q -ws -rp $sel`;
        $bbs[0] += $wps[0];
        $bbs[1] += $wps[1];
        $bbs[2] += $wps[2];
        $bbs[3] += $wps[0];
        $bbs[4] += $wps[1];
        $bbs[5] += $wps[2];
    }
    for ($i = 0; $i <size($bbs); $i++) $bbs[$i] /= size($sels);
    
    for ($i = 0; $i < size($bbs); $i++) {
        if ($i < 3) $bbs[$i] -= $unit;
        else $bbs[$i] += $unit;
    }
    
    if (`objExists nas_boundingBoxVisualizer_Cube`) delete nas_boundingBoxVisualizer_Cube;
    $visualCurve = `curve -d 1 -p $bbs[0] $bbs[1] $bbs[5] -p $bbs[0] $bbs[4] $bbs[5] -p $bbs[0] $bbs[4] $bbs[2] -p $bbs[0] $bbs[1] $bbs[2] -p $bbs[3] $bbs[1] $bbs[2] -p $bbs[3] $bbs[4] $bbs[2] -p $bbs[3] $bbs[4] $bbs[5] -p $bbs[3] $bbs[1] $bbs[5] -p $bbs[0] $bbs[1] $bbs[5] -p $bbs[0] $bbs[1] $bbs[2] -p $bbs[0] $bbs[4] $bbs[2] -p $bbs[3] $bbs[4] $bbs[2] -p $bbs[3] $bbs[1] $bbs[2] -p $bbs[3] $bbs[1] $bbs[5] -p $bbs[3] $bbs[4] $bbs[5] -p $bbs[0] $bbs[4] $bbs[5] -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -n nas_boundingBoxVisualizer_Cube`;
    $array = `listRelatives -s $visualCurve`;
    setAttr ($array[0] + ".overrideEnabled") 1;
    setAttr ($array[0] + ".overrideColor") 17;
    $attrs = `listAttr -k $visualCurve`;
    for ($attr in $attrs) setAttr -lock 1 -channelBox 0 -keyable 0 ($visualCurve + "." + $attr);
    
    select -r $sels;
    return $bbs;
}
    
/*
    for ($val in $valued) {
        $array = stringToStringArray($val, ".");
        if ($array[1] == "scaleX" || $array[1] == "scaleY" || $array[1] == "scaleZ") setAttr $val 1;
        else setAttr $val 0;
    }
    
    for ($lock in $locked) setAttr -k 0 $lock;
    
    for ($key in $keyed) cutKey -cl -t ":" -f ":" $key;
    
*/
//----------------------------------------------------------------UNORGANIZED---------------------------------------------------------------------------
global proc int nas_riggingUINumRows(int $numButtons, int $buttonWidth, string $window) {
    string $height, $array[];
    int $num, $remainder;

    $height = ($numButtons/((`window -q -w $window` - 32.0)/$buttonWidth)); 
    $array = stringToStringArray($height, ".");
    $num = $array[0];
    if ($array[1] == "") $remainder = 0;
    else $remainder = $array[1];
    if ($num == 0) $num = 1;
    else if ($remainder > 0) $num += 1;

    return $num;
}

global proc nas_quick(string $mode) {
    global string $nasQuickSelectionMaskButton, $nasQuickIsolateButton;
    global int $nasSelectionMaskToggle;
    string $panels[];
    
    if ($mode == "mask") {
        nas_selectionMask;
        button -e -vis off $nasQuickSelectionMaskButton;
        if ($nasSelectionMaskToggle) button -e -bgc .627 .07 0 $nasQuickSelectionMaskButton;
        else button -e -bgc .38 .38 .38 $nasQuickSelectionMaskButton;
        button -e -vis on $nasQuickSelectionMaskButton;
    } else if ($mode == "isolate") {
        dkIsolate 0;
        $panels = `nas_getVisibleModelPanels`;
        button -e -vis off $nasQuickIsolateButton;
        if (`isolateSelect -q -state $panels[0]`) button -e -bgc .921 .46 0 $nasQuickIsolateButton;
        else button -e -bgc .38 .38 .38 $nasQuickIsolateButton;    
        button -e -vis on $nasQuickIsolateButton;
    }
}

global proc nas_quickUI() {
    if (size(`lsUI -type window`) <= 0) return;        //checks if the user is running maya interactively (as opposed to mayabatch).
    global string $nasQuickSelectionMaskButton, $dkAutoSaveButton, $nasQuickIsolateButton, $nasQuickTimerButton;
    global int $nasSelectionMaskToggle;
    string $window, $labels[], $commands[], $annotations[], $cmd, $rows[], $users[], $buttons[];
    int $buttonWidth, $numButtons;
    
    $buttonWidth = 60;
    
    //layout creation
    $window = `nas_window nas_quickUI 1 0 0`;
    $form = `formLayout`;
    
    //quick buttons************************************************    
    //selection mask button
    $nasQuickSelectionMaskButton = `button -al center -label "Mask" -c "nas_quick \"mask\"" -ann "Will set your selection mask to whatever you have selected" -bgc .38 .38 .38`;
    
    //isolate button
    $nasQuickIsolateButton = `button -al center -label "Isolate" -c "nas_quick \"isolate\"" -ann "Isolates you selection while adding new items to isolation. Press again to show all. Right click to add or remove from isolation." -bgc .38 .38 .38`;
    nas_markingMenu 3  "" {
        "Add", "dkIsolate 1", "E", "0", "", 
        "Remove", "dkIsolate -1", "W", "0", ""};
    
    //timer marking menu
    $nasQuickTimerButton = `button -al center -label "Timer" -ann "A tool to keep track of how fast your finishing repetitive tasks." -bgc .3 .65 1`;
    nas_markingMenu 1 "" {
        "Start", "nas_timer \"start\"", "W", "0", "", 
        "End", "nas_timer \"end\"", "E", "0", "", 
        "Pause", "nas_timer \"pause\"", "N", "0", "", 
        "Resume", "nas_timer \"resume\"", "S", "0", ""};
    
    
    formLayout -e
        -af $nasQuickSelectionMaskButton "top" 0
        -af $nasQuickSelectionMaskButton "left" 0
        -ap $nasQuickSelectionMaskButton "right" 0 40
        -af $nasQuickSelectionMaskButton "bottom" 0
        
        -af $nasQuickTimerButton "top" 0
        -ac $nasQuickTimerButton "left" 0 $nasQuickSelectionMaskButton
        -ac $nasQuickTimerButton "right" 0 $nasQuickIsolateButton
        -af $nasQuickTimerButton "bottom" 0
        
        -af $nasQuickIsolateButton "top" 0
        -ap $nasQuickIsolateButton "left" 0 60
        -af $nasQuickIsolateButton "right" 0
        -af $nasQuickIsolateButton "bottom" 0
        $form;
    
    //find out how big the window should be and reveal    
    //window -e -s 1 -wh (10+2*60) (34+1*22) $window;
    $array[0] = `about -v`;
    $array = stringToStringArray($array[0], " ");
    if (`about -os` == "win64" && $array[0] == "2011") window -e -toolbox 1 $window;
    if (`about -os` == "win64" && $array[0] == "2012") window -e -toolbox 1 $window;
    showWindow $window;
}

//-------------------------------------------------------------nas_markingMenu---------------------------------------------------------------------
//creates a marking menu pop up; use after button command or any other command that creates a control
global proc nas_markingMenu(int $button, string $modifierList, string $array[]) {
    string $labels[], $commands[], $positions[], $annotations[];
    int $subMenus[], $currentSubMenus[], $subMenu, $ctrl, $shift, $alt;
    
    for ($i = 0; $i < size($array); $i+=5) { 
        $labels[size($labels)] = $array[$i];
        $commands[size($commands)] = $array[$i+1];
        $positions[size($positions)] = $array[$i+2];
        $subMenus[size($subMenus)] = $array[$i+3];
        $annotations[size($annotations)] = $array[$i+4];
    }
    
    if (`gmatch $modifierList "*ctrl*"`) $ctrl = 1;
    if (`gmatch $modifierList "*shift*"`) $shift = 1;
    if (`gmatch $modifierList "*alt*"`) $alt = 1;
    if ($button) popupMenu -markingMenu 1 -b $button -ctrlModifier $ctrl -shiftModifier $shift -altModifier $alt -allowOptionBoxes true;
    for ($i = 0; $i < size($labels); $i++) {
        if ($subMenus[$i] == 2) $subMenu = 0;
        else $subMenu = $subMenus[$i];        
        menuItem
            -ann $annotations[$i]
            -label $labels[$i]
            -divider 0
            -subMenu $subMenu 
            -command $commands[$i] 
            -altModifier 0
            -optionModifier 0
            -commandModifier 0
            -ctrlModifier 0 
            -shiftModifier 0
            -optionBox 0
            -enable 1
            -data 0
            -radialPosition $positions[$i] 
            -enableCommandRepeat 1
            -image "commandButton.xpm" 
            -echoCommand 0
            -italicized 0
            -boldFont 0;
        if ($subMenus[$i] == 0) setParent -m ..;
    }
}

//-------------------------------------------------------------nas_channelBox---------------------------------------------------------------------
//Creates a custom channel box with a right click marking menu for animation and a middle click marking menu for rigging
global proc nas_channelBox() {
    global string $nasChannelBox, $nasChannelBoxMinusButton, $nasChannelBoxPlusButton;
    global float $nasChannelBoxSensitivity;
    string $window, $form, $clearButton, $displayButton;
    float $speed;
    int $height;
    
    if ($nasChannelBoxSensitivity < .0000000001) $nasChannelBoxSensitivity = 1;
    $window = `nas_window nas_channelBox 1 0 2`;
         $form = `formLayout`;
             $nasChannelBoxMinusButton = `button -label "-" -command "$nasChannelBoxSensitivity/=2.0;channelBox -e -speed $nasChannelBoxSensitivity $nasChannelBox;button -e -label $nasChannelBoxSensitivity $nasChannelBoxMinusButton;button -e -label $nasChannelBoxSensitivity $nasChannelBoxPlusButton;"`;
            $nasChannelBoxPlusButton = `button -label "+" -command "$nasChannelBoxSensitivity*=2.0;channelBox -e -speed $nasChannelBoxSensitivity $nasChannelBox;button -e -label $nasChannelBoxSensitivity $nasChannelBoxMinusButton;button -e -label $nasChannelBoxSensitivity $nasChannelBoxPlusButton;"`;
            //$displayButton = `button -h 40 -bgc .139 .851 .139 -label "Layers" -ann "     Hey TDs!!! It's Dave, right click me for shortcuts!" -command "nas_layerEditorUI"`;
            nas_markingMenu 3 "" {
                "Light Vis", "nas_layerEditor vis light", "W", "0", "", 
                "Mesh Vis", "nas_layerEditor vis mesh", "NE", "0", "",
                "Mesh Temp", "nas_layerEditor temp mesh", "NW", "0", "",  
                "Mesh Ref", "nas_layerEditor ref mesh", "N", "0", "",
                "Default", "nas_layerEditor hello bye", "E", "0", ""};

            $nasChannelBox = `channelBox -useManips "invisible" -speed 1 -precision 6 nas_channelBox`;
            nas_markingMenu 2 "ctrl" {
                "Copy", "nas_cbFuncs copy", "NW", "0", "", 
                "Paste", "nas_cbFuncs paste", "NE", "0", "",
                "Delete Keys", "nas_cbFuncs delete", "W", "0", "",  
                "Key", "nas_cbFuncs key", "E", "0", "",
                "Mute", "nas_cbFuncs mute", "SW", "0", "",
                "UnMute", "nas_cbFuncs unmute", "SE", "0", "",
                "Order", "nas_orderHierarchy", "N", "0", "",
                "Check Weighting", "nas_cbFuncs checkWeighting", "S", "0", ""};
            setParent..;
            nas_markingMenu 3 "shift" {
                "Modify", "", "N", "1", "",
                    "Lock & Hide", "nas_cbFuncs lockHide", "W", "2", "",  
                    "Lock", "nas_cbFuncs lock", "NW", "2", "",
                    "Keyable", "nas_cbFuncs keyable", "S", "2", "", 
                    "Hide", "nas_cbFuncs hide", "N", "2", "",
                    "Limit & Hide", "nas_cbFuncs limitHide", "E", "2", "", 
                    "Unlock", "nas_cbFuncs unlock", "NE", "2", "",
                    "Unlimit", "nas_cbFuncs unlimit", "SE", "2", "",
                    "Unhide", "nas_cbFuncs unhide", "SW", "0", "",
                "Nuke", "", "W", "1", "",
                    "Disconnect", "nas_cbFuncs breakConnection", "N", "2", "",     
                    "Freeze", "nas_cbFuncs freeze", "W", "2", "",
                    "History", "delete -ch", "SW", "2", "",
                    "Center", "nas_cbFuncs center", "S", "0", "", 
                "Connect", "", "E", "1", "",
                    "Connect From", "nas_cbFuncs connectFrom", "NE", "2", "",  
                    "Connect To", "nas_cbFuncs connectTo", "SE", "2", "",
                    "Reverse To", "nas_cbFuncs reverseConnect", "E", "2", "",
                    "SDK From", "nas_cbFuncs sdkFrom", "NW", "2", "",
                    "SDK To", "nas_cbFuncs sdkTo", "SW", "0", "",
                "Attrs", "", "S", "1", "",
                    "Edit", "dynRenameAttrWin( {} );", "W", "2", "",  
                    "Add", "dynAddAttrWin( {} );", "S", "2", "",
                    "Delete", "nas_cbFuncs deleteAttr", "E", "2", "",
                    "Move Up", "nas_moveAttr 1", "SE", "2", "",
                    "Move Down", "nas_moveAttr -1", "SW", "2", "", 
                    "Channel Control", "ChannelControlEditor", "N", "0", ""};
            nas_markingMenu 3 "ctrl" {"Shoot Out", "nas_cbFuncs test", "W", "0", "",
                        "Default", "nas_cbFuncs \"default\"", "E", "0", "",
                        "Zero", "nas_cbFuncs zero", "S", "0", "",
                        "One", "nas_cbFuncs one", "N", "0", ""};
         formLayout -e
            -af $nasChannelBoxMinusButton "top" 0
             -af $nasChannelBoxMinusButton "left" 0
             -ap $nasChannelBoxMinusButton "right" 0 50
             
             -af $nasChannelBoxPlusButton "top" 0
             -ap $nasChannelBoxPlusButton "left" 0 50
             -af $nasChannelBoxPlusButton "right" 0
             
             -ac $nasChannelBox "top" 0 $nasChannelBoxMinusButton
             -af $nasChannelBox "left" 0
             -af $nasChannelBox "right" 0
             -af $nasChannelBox "bottom" 0
/*
             -ac $nasChannelBox "bottom" 0 $displayButton

            -an $displayButton "top" 
            -af $displayButton "left" 0
            -af $displayButton "right" 0
            -af $displayButton "bottom" 0
*/
             $form;
     showWindow $window;
}

global proc nas_cbFuncs(string $func) {
    global string $nasCBConnectSourceAttrsList, $nasCBConnectSourceObjects[], $nasCBSdkSourceAttrs[], $nasCBSdkSourceObjects[];
    global float $nasCBCopyValues[];
    string $attrs[], $sels[], $targetList, $array[], $ancestor, $sourceAttrs[], $sourceObjectName, $attrName, $targetObjectName;
    int $translate, $rotate, $scale, $intArray[];
    
    //int $autoKeySetting = `autoKeyframe -q -state`;
    //autoKeyframe -state 0;

    
    $attrs = `nas_getCBSelection`;
    if (size($attrs) == 0) $attrs = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"};
    $sels = `ls -sl -long`;
    
    switch ($func) {
        case "key":
            for ($attr in $attrs) setKeyframe -at $attr;
            break;
        case "lock":
            for ($sel in $sels) for ($attr in $attrs) if (`objExists ($sel + "." + $attr)`) setAttr -lock true ($sel + "." + $attr);
            break;
        case "unlock":
            for ($sel in $sels) for ($attr in $attrs) {
                if (`objExists ($sel + "." + $attr)`) { 
                    $ancestor = `connectionInfo -gla ($sel + "." + $attr)`;
                    if ($ancestor == "") {
                        setAttr -lock false ($sel + "." + $attr);
                    } else {
                        setAttr -lock false $ancestor;
                        setAttr -lock false ($sel + "." + $attr);
                    }
                }
            }
            break;
        case "mute":
            for ($sel in $sels) for ($attr in $attrs) if (`objExists ($sel + "." + $attr)`) mute ($sel + "." + $attr);
            break;
        case "unmute":
            for ($sel in $sels) for ($attr in $attrs) if (`objExists ($sel + "." + $attr)`) mute -force -disable ($sel + "." + $attr);
            break;
        case "copy":
            clear $nasCBCopyValues;
            for ($attr in $attrs) $nasCBCopyValues[size($nasCBCopyValues)] = `getAttr ($sels[size($sels)-1] + "." + $attr)`;
            break;
        case "paste":
            for ($sel in $sels) for ($i=0; $i<size($attrs); $i++) setAttr ($sel+"."+$attrs[$i]) $nasCBCopyValues[$i];
            break;
        case "delete":
            for ($sel in $sels) {
                for ($attr in $attrs) {
                    $array = `listConnections -d 0 -type "animCurve" ($sel + "." + $attr)`;
                    delete $array[0];
                }
            }
            break;
        case "connectFrom":
            $nasCBConnectSourceObjects = $sels;
            $nasCBConnectSourceAttrsList = stringArrayToString($attrs, ", ");    
            break;
        case "connectTo":
            if (size($nasCBConnectSourceAttrsList)) {
                $targetList = stringArrayToString($attrs, ", ");
                if (size($nasCBConnectSourceObjects) == size($sels)) {
                    for ($i = 0; $i < size($nasCBConnectSourceObjects); $i++) {
                        select -r $nasCBConnectSourceObjects[$i] $sels[$i];
                        nas_connectAttr $nasCBConnectSourceAttrsList $targetList;
                    }
                    select -r $nasCBConnectSourceObjects;
                } else if (size($nasCBConnectSourceObjects) == 1 && size($sels) > 0) {
                    for ($sel in $sels) {
                        select -r $nasCBConnectSourceObjects[0] $sel;
                        nas_connectAttr $nasCBConnectSourceAttrsList $targetList;
                    }
                    select -r $nasCBConnectSourceObjects[0];
                } else {
                    error "Number of source attrs to connect exceeds the number of target attrs. Please select one source attr or an equal number of attrs between source and target attrs.";
                }
            }
            break;
        case "reverseConnect":
            for ($i = 0; $i < size($attrs); $i++) {
                if ($attr == "tx") $attrs[$i] = "translateX";
                else if ($attr == "ty") $attrs[$i] = "translateY";
                else if ($attr == "tz") $attrs[$i] = "translateZ";
                else if ($attr == "rx") $attrs[$i] = "rotateX";
                else if ($attr == "ry") $attrs[$i] = "rotateY";
                else if ($attr == "rz") $attrs[$i] = "rotateZ";
                else if ($attr == "sx") $attrs[$i] = "scaleX";
                else if ($attr == "sy") $attrs[$i] = "scaleY";
                else if ($attr == "sz") $attrs[$i] = "scaleZ";
            }
            if (size($nasCBConnectSourceAttrsList)) {
                $sourceAttrs = stringToStringArray($nasCBConnectSourceAttrsList, ", ");
                if (size($nasCBConnectSourceObjects) == size($sels)) {
                    for ($i = 0; $i < size($nasCBConnectSourceObjects); $i++) {
                        $array = stringToStringArray($nasCBConnectSourceObjects[$i], "|");
                        $sourceObjectName = stringArrayToString($array, "_");
                        $array = stringToStringArray($sels[$i], "|");
                        $targetObjectName = stringArrayToString($array, "_");
                        if (size($sourceAttrs) == 1 && size($attrs) > 0) {
                            $attrName = `capitalizeString $sourceAttrs[0]`;
                            $reverse = `createNode reverse`;
                            connectAttr ($nasCBConnectSourceObjects[$i] + "." + $sourceAttrs[0]) ($reverse + ".inputX");
                            for ($j = 0; $j < size($attrs); $j++) connectAttr ($reverse + ".outputX") ($sels[$i] + "." + $attrs[$j]);
                        } else if (size($sourceAttrs) == size($attrs)) {
                            for ($j = 0; $j < size($sourceAttrs); $j++) {
                                $attrName = `capitalizeString $sourceAttrs[$j]`;
                                $reverse = `createNode reverse`;
                                connectAttr ($nasCBConnectSourceObjects[$i] + "." + $sourceAttrs[$j]) ($reverse + ".inputX");
                                connectAttr ($reverse + ".outputX") ($sels[$i] + "." + $attrs[$j]);
                            }
                        } else {
                            error "Please select 1 source attr and many or equal numbers of source attrs and target attrs.";
                        }
                    }
                    select -r $nasCBConnectSourceObjects;
                } else if (size($nasCBConnectSourceObjects) == 1 && size($sels) > 0) {
                    $array = stringToStringArray($nasCBConnectSourceObjects[0], "|");
                    $sourceObjectName = stringArrayToString($array, "_");
                    for ($sel in $sels) {
                        $array = stringToStringArray($sel, "|");
                        $targetObjectName = stringArrayToString($array, "_");
                        if (size($sourceAttrs) == 1 && size($sels) > 0) {
                            $attrName = `capitalizeString $sourceAttrs[0]`;
                            $reverse = `createNode reverse`;
                            connectAttr ($nasCBConnectSourceObjects[0] + "." + $sourceAttrs[0]) ($reverse + ".inputX");
                            for ($j = 0; $j < size($attrs); $j++) connectAttr ($reverse + ".outputX") ($sel + "." + $attrs[$j]);
                        } else if (size($sourceAttrs) == size($attrs)) {
                            for ($j = 0; $j < size($sourceAttrs); $j++) {
                                $attrName = `capitalizeString $sourceAttrs[$j]`;
                                $reverse = `createNode reverse`;
                                connectAttr ($nasCBConnectSourceObjects[0] + "." + $sourceAttrs[$j]) ($reverse + ".inputX");
                                connectAttr ($reverse + ".outputX") ($sel + "." + $attrs[$j]);
                            }
                        } else {
                            error "Please select 1 source attr and many or equal numbers of source attrs and target attrs.";
                        }
                    }
                    select -r $nasCBConnectSourceObjects[0];
                } else {
                    error "Please select one source object and many or an equal number of source and target objects.";
                }
            }
            break;
        case "sdkFrom":
            $nasCBSdkSourceObjects = $sels;
            $nasCBSdkSourceAttrs = $attrs;
            break;
        case "sdkTo":
            if (size($nasCBSdkSourceAttrs)) {
                if (size($nasCBSdkSourceObjects) == size($sels)) {
                    for ($i = 0; $i < size($nasCBSdkSourceObjects); $i++) {
                        if (size($nasCBSdkSourceAttrs) == size($attrs)) {
                            for ($j = 0; $j < size($attrs); $j++) {
                                setDrivenKeyframe -currentDriver ($nasCBSdkSourceObjects[$i] + "." + $nasCBSdkSourceAttrs[$j]) ($sels[$i] + "." + $attrs[$j]);
                            }
                        } else if (size($nasCBSdkSourceAttrs) == 1 && size($attrs) > 0) {
                            for ($j = 0; $j < size($attrs); $j++) {
                                setDrivenKeyframe -currentDriver ($nasCBSdkSourceObjects[$i] + "." + $nasCBSdkSourceAttrs[0]) ($sels[$i] + "." + $attrs[$j]);
                            }
                        }
                    }
                    select -r $nasCBSdkSourceObjects;
                } else if (size($nasCBSdkSourceObjects) == 1 && size($sels) > 0) {
                    if (size($nasCBSdkSourceAttrs) == size($attrs)) {
                        for ($i = 0; $i < size($sels); $i++) {
                            for ($j = 0; $j < size($attrs); $j++) {
                                setDrivenKeyframe -currentDriver ($nasCBSdkSourceObjects[0] + "." + $nasCBSdkSourceAttrs[$j]) ($sels[$i] + "." + $attrs[$j]);
                            }
                        }
                    } else if (size($nasCBSdkSourceAttrs) == 1 && size($attrs) > 0) {
                        for ($i = 0; $i < size($sels); $i++) {
                            for ($j = 0; $j < size($attrs); $j++) {
                                setDrivenKeyframe -currentDriver ($nasCBSdkSourceObjects[0] + "." + $nasCBSdkSourceAttrs[0]) ($sels[$i] + "." + $attrs[$j]);
                            }
                        }
                    }
                    select -r $nasCBSdkSourceObjects[0];
                } else {
                    error "Number of source attrs to connect exceeds the number of target attrs. Please select one source attr or an equal number of attrs between source and target attrs.";
                }
            }
            select -r $sels;
            break;
        case "breakConnection":
            for ($sel in $sels) {
                for ($attr in $attrs) {
                    string $target = ($sel + "." + $attr);
                    string $source = `connectionInfo -sfd $target`;
                    disconnectAttr $source $target;
                      $array = stringToStringArray($source, ".");
                    $unitConversion = $array[0];
                    if (size($unitConversion)) {
                        if (`nodeType $unitConversion` == "unitConversion") {
                            delete $unitConversion;
                        }
                    }
                }
            }
            break;
        case "hide":
            for ($sel in $sels) for ($attr in $attrs) setAttr -keyable false -channelBox false ($sel + "." + $attr);
            break;
        case "unhide":
            for ($sel in $sels) {
                setAttr -k on ($sel + ".tx");
                setAttr -k on ($sel + ".ty");
                setAttr -k on ($sel + ".tz");
                setAttr -k on ($sel + ".rx");
                setAttr -k on ($sel + ".ry");
                setAttr -k on ($sel + ".rz");
                setAttr -k on ($sel + ".sx");
                setAttr -k on ($sel + ".sy");
                setAttr -k on ($sel + ".sz");
                setAttr -k on ($sel + ".v");
            }
            break;
        case "lockHide":
            for ($sel in $sels) for ($attr in $attrs) setAttr -lock true -keyable false -channelBox false ($sel + "." + $attr);
            break;
        case "keyable":
            for ($sel in $sels) for ($attr in $attrs) {
                //setAttr -k (1 - `getAttr -k ($sel + "." + $attr)`) -channelBox true ($sel + "." + $attr);
                if (`getAttr -k ($sel + "." + $attr)`) setAttr -keyable false -channelBox true ($sel + "." + $attr);
                else setAttr -keyable true ($sel + "." + $attr);
            }
            break;
        case "limit":
            for ($attr in $attrs) {
                /*$intArray = eval("transformLimits -q -e" + $attr + ";");
                if ($intArray[0]) dkLimitAttrs 0 $attr;
                else */dkLimitAttrs 1 $attr;
            }
            break;
        case "unlimit":
            for ($attr in $attrs) {
                /*$intArray = eval("transformLimits -q -e" + $attr + ";");
                if ($intArray[0]) dkLimitAttrs 0 $attr;
                else */nas_limitAttrs 0 $attr;
            }
            break;
        case "limitHide":
            for ($attr in $attrs) {
                /*$intArray = eval("transformLimits -q -e" + $attr + ";");
                if ($intArray[0]) dkLimitAttrs 0 $attr;
                else */nas_limitAttrs 1 $attr;
            }
            for ($sel in $sels) for ($attr in $attrs) setAttr -lock false -keyable false ($sel + "." + $attr); 
            break;
        case "center":
            for ($sel in $sels) {
                $array = `listRelatives -s $sel`;
                if ($array[0] != "" && `objectType -isType clusterHandle $array[0]`) {
                    select -r $sel; nas_centerCluster;
                } else {
                    select -r $sel; CenterPivot;
                }
            }
            select -r $sels;
            break;
        case "deleteAttr":
            for ($sel in $sels) for ($attr in $attrs) if (`objExists ($sel + "." + $attr)`) deleteAttr -attribute $attr $sel;
            break;
        case "freeze":
            if (size($attrs)) {
                for ($attr in $attrs) {
                    if (`gmatch $attr "translate?"` || `gmatch $attr "t?"`) $translate = 1;
                    if (`gmatch $attr "rotate?"` || `gmatch $attr "r?"`) $rotate = 1;
                    if (`gmatch $attr "scale?"` || `gmatch $attr "s?"`) $scale = 1;
                }
                if ($translate || $rotate || $scale) makeIdentity -apply true -t $translate -r $rotate -s $scale -n 0;
            } else {
                makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;
            }
            break;
        case "freezeKF":
            for ($sel in `ls -sl`) {
                setAttr -k 1 -l 0 ($sel + ".sy");
                setAttr -k 1 -l 0 ($sel + ".sz");
                if (size(`listConnections -c 1 ($sel + ".sy")`)) disconnectAttr ($sel + ".sx") ($sel + ".sy");
                if (size(`listConnections -c 1 ($sel + ".sz")`)) disconnectAttr ($sel + ".sx") ($sel + ".sz");
                makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $sel;
                setAttr -k 0 -l 1 ($sel + ".sy");
                setAttr -k 0 -l 1 ($sel + ".sz");
            }
            break;
        case "checkWeighting":
            nas_checkWeighting $attrs;
            break;
        case "default":
            for ($sel in $sels) {
                catchQuiet(`setAttr ($sel + ".tx") 0`);
                catchQuiet(`setAttr ($sel + ".ty") 0`);
                catchQuiet(`setAttr ($sel + ".tz") 0`);
                catchQuiet(`setAttr ($sel + ".rx") 0`);
                catchQuiet(`setAttr ($sel + ".ry") 0`);
                catchQuiet(`setAttr ($sel + ".rz") 0`);
                catchQuiet(`setAttr ($sel + ".sx") 1`);
                catchQuiet(`setAttr ($sel + ".sy") 1`);
                catchQuiet(`setAttr ($sel + ".sz") 1`);
            }
            print "";
            break;
        case "test":
            for ($sel in $sels) {
                catchQuiet(`setAttr ($sel + ".tx") 99`);
                catchQuiet(`setAttr ($sel + ".ty") 99`);
                catchQuiet(`setAttr ($sel + ".tz") 99`);
                catchQuiet(`setAttr ($sel + ".rx") 99`);
                catchQuiet(`setAttr ($sel + ".ry") 99`);
                catchQuiet(`setAttr ($sel + ".rz") 99`);
                catchQuiet(`setAttr ($sel + ".sx") .1`);
                catchQuiet(`setAttr ($sel + ".sy") .1`);
                catchQuiet(`setAttr ($sel + ".sz") .1`);
            }
            print "";
            break;
        case "zero":
            if (size($attrs) == 0) {
                $attrs = {"tx", "ty", "tz", "rx", "ry", "rz"};
            }
            for ($sel in $sels) for ($attr in $attrs) {
                if (`objExists ($sel + "." + $attr)`) {
                    if (`getAttr -l ($sel + "." + $attr)` == 0) {
                        setAttr ($sel + "." + $attr) 0;
                    }
                }
            }
            break;
        case "one":
            if (size($attrs) == 0) {
                $attrs = {"sx", "sy", "sz"};
            }
            for ($sel in $sels) for ($attr in $attrs) {
                if (`objExists ($sel + "." + $attr)`) {
                    if (`getAttr -l ($sel + "." + $attr)` == 0) {
                        setAttr ($sel + "." + $attr) 1;
                    }
                }
            }
            break;
        default:
            break;
    }
    //autoKeyframe -state $autoKeySetting;
}

//-------------------------------------------------------------nas_layerEditorUI---------------------------------------------------------------------
global proc nas_layerEditorUI() {
    string $channelBoxName = "nas_channelBox_1_0_2";
    int $tlc[], $wh[], $LEHeight;
    $tlc = `window -q -tlc $channelBoxName`;
    $wh = `window -q -wh $channelBoxName`;
    
    $LEHeight = (size(`ls -type displayLayer`) - 1) * 21 + 80;// + 30;
    if ($LEHeight < 170) $LEHeight = 170;
    if (`window -ex LEWindow`) {
        if (`window -q -vis LEWindow`) {
            if (($tlc[0] + $wh[1] + $LEHeight) > 1200) window -e -h (1200 - $tlc[0]) $channelBoxName; 
            else window -e -h ($wh[1] + $LEHeight) $channelBoxName;
            window -e -vis 0 LEWindow; 
        } else {
            optionVar -iv leInMainWindow false;
            DisplayLayerEditorWindow;
            optionVar -iv leInMainWindow true;
            
            window -e -h ($wh[1] - $LEHeight) $channelBoxName;
            window -e -tb off -tlc ($tlc[0] + $wh[1] - $LEHeight) $tlc[1] LEWindow;
            window -e -wh $wh[0] $LEHeight LEWindow;
        }
    } else {
        optionVar -iv leInMainWindow false;
        DisplayLayerEditorWindow;
        optionVar -iv leInMainWindow true;
        
        window -e -h ($wh[1] - $LEHeight) $channelBoxName;
        window -e -tb off -tlc ($tlc[0] + $wh[1] - $LEHeight) $tlc[1] LEWindow;
        window -e -wh $wh[0] $LEHeight LEWindow;
    }
}

//-------------------------------------------------------------nas_layerEditor---------------------------------------------------------------------
global proc nas_layerEditor(string $action, string $layer) {
    string $allLayers[], $meshes[], $light, $ctrl;

    if (size(`ls "*_Mesh"`) == 0) error "Mesh layers do not exist!";
    for ($item in `ls "*_Mesh"`) {
        if (`objectType $item` == "displayLayer" && $item != "EyesTongueTeeth_Mesh") {
            $meshes[0] = $item;
            break;
        }
    }
    $meshes[1] = "EyesTongueTeeth_Mesh";
    $light = "Light_Rig";
    $ctrl = "Controller_Vis";
    
    if ($action == "vis" && $layer == "light") {
        if (!`objExists $light`) error "Light_Rig layer doesn't exist!";
        if (`getAttr ($light + ".v")`) {
            setAttr ($light + ".v") 0;
            print "light rig turned OFF";
        } else {
            setAttr ($light + ".v") 1;
            print "light rig turned ON";
        }
    } else if ($layer == "mesh") {
        if (!`objExists $meshes[1]`) error "EyesTongueTeeth_Mesh layer doesn't exist!";
        if ($action == "vis") {
            for ($item in $meshes) {
                setAttr ($item + ".v") (1 - `getAttr ($meshes[1] + ".v")`);
                if (`getAttr ($meshes[1] + ".v")` == 1) print "mesh visibility ON";
                else print "mesh visibility OFF";
            }
        } else if ($action == "temp") {
            if (`getAttr ($meshes[0] + ".displayType")` == 1) {
                for ($item in $meshes) setAttr ($item + ".displayType") 0;
                print "mesh template OFF";
            } else {
                for ($item in $meshes) setAttr ($item + ".displayType") 1;
                print "mesh template ON";
            }
        } else if ($action == "ref") {
            if (`getAttr ($meshes[0] + ".displayType")` == 2) {
                for ($item in $meshes) {
                    setAttr ($item + ".displayType") 0;
                    print "mesh reference OFF";
                }
            } else {
                for ($item in $meshes) {
                    setAttr ($item + ".displayType") 2;
                    print "mesh reference ON";
                }
            }
        }
    } else {
        if (!`objExists $light`) warning "Light_Rig layer doesn't exist!";
        if (!`objExists $meshes[1]`) warning "EyesTongueTeeth_Mesh layer doesn't exist!";
        if (!`objExists $ctrl`) warning "Controller_Vis layer doesn't exist!";
        for ($item in {$light, $ctrl, $meshes[0], $meshes[1]}) if (`objExists ($item + ".v")`) setAttr ($item + ".v") 1;
        for ($item in {$light, $meshes[0], $meshes[1]}) if (`objExists ($item + ".displayType")`) setAttr ($item + ".displayType") 2;
        setAttr ($ctrl + ".displayType") 0;
        print "visibility and reference modes set to DEFAULT";
    }
}

//-------------------------------------------------------------nas_orderHierarchy---------------------------------------------------------------------
global proc nas_orderHierarchy() {
    string $array[], $sels[], $group, $parents[];
    $sels = `ls -sl`;
    for ($sel in $sels) {
        $array = `listRelatives -p $sel`;
        $parents[size($parents)] = $array[0];
    }
    $group = `group $sels`;
    for ($i=0;$i<size($sels);$i++) {
        if ($parents[$i] == "") parent -w $sels[$i];
        else parent $sels[$i] $parents[$i];
    }
    delete $group;
    select -r $sels;
}

//-------------------------------------------------------------nas_moveAttr---------------------------------------------------------------------
global proc nas_moveAttr(int $direction) {
    string $sels[], $attrs[], $userAttrs[], $resultAttrs[];
    int $index, $lock;
    print "";
    $sels = `ls -sl`;
    $channelBoxes = {" $gChannelBoxName", " $nasChannelBox"};
    for ($channelBox in $channelBoxes) {
        $array = eval("channelBox -q -sma" + $channelBox);
        $attrs = stringArrayCatenate($attrs, $array);
    }
    for ($sel in $sels) {
        for ($attr in $attrs) {
            $userAttrs = `listAttr -ud $sel`;
            $index = -1;
            for ($i = 0; $i < size($userAttrs); $i++) {
                if ($userAttrs[$i] == $attr) {
                    $index = $i;
                    break;
                }
            }
            if ($index > -1) {
                $userAttrs = stringArrayRemove({$attr}, $userAttrs);
                if (($index-$direction) > size($userAttrs)) {
                    warning ($attr + " is already at bottom of list.");
                    return;
                } else if (($index-$direction) < 0) {
                    warning ($attr + " is already at top of list.");
                    return;
                } else {
                    for ($i = 0; $i < size($userAttrs)+1; $i++) {
                        if ($i < ($index-$direction)) $resultAttrs[$i] = $userAttrs[$i];
                        else if ($i == ($index-$direction)) $resultAttrs[$i] = $attr;
                        else if ($i > ($index-$direction)) $resultAttrs[$i] = $userAttrs[$i-1];
                    }
                }
                for ($i = 0; $i < $index - $direction; $i++) $resultAttrs[size($resultAttrs)] = $userAttrs[$i];
                $resultAttrs[size($resultAttrs)] = $attr;
                for ($i = $index - $direction + 1; $i < size($userAttrs); $i++) $resultAttrs[size($resultAttrs)] = $userAttrs[$i];
                $resultAttrs = `stringArrayRemoveDuplicates $resultAttrs`;
                for ($resultAttr in $resultAttrs) {
                    $lock = `getAttr -lock ($sel + "." + $resultAttr)`;
                    if ($lock) setAttr -lock 0 ($sel + "." + $resultAttr); 
                    renameAttr ($sel + "." + $resultAttr) ($resultAttr + "TempName");
                    renameAttr ($sel + "." + $resultAttr + "TempName") $resultAttr;
                    if ($lock) setAttr -lock 1 ($sel + "." + $resultAttr);
                    select -cl;
                    select -r $sel;
                }
            } else {
                warning ($attr + " is not user defined. Cannot change order.");
            }
        }
    }
}

//-------------------------------------------------------------nas_connectAttr---------------------------------------------------------------------
//connects attrs from your first selection to subsequent selections
//if no target list is specified, all attrs in the sourceList will get connected to similar attrs on targets
//if there is only one attr in the source list, that attr will get connected to each of the attrs in the target list
//if the source list and target list have the same number of attrs, each attr will connect to each corresponding attr
//if no attrs are specified, attrs are taken from the channel box selection
global proc nas_connectAttr (string $sourceList, string $targetList) {
    string $sels[], $sourceAttrs[], $targetAttrs[];
    $sels = `ls -sl -long`;
    if (size($sourceList) == 0 && size($targetList) == 0) {
        $sourceAttrs = `nas_getCBSelection`;
        $targetAttrs = $sourceAttrs;
    } else {
        $sourceAttrs = stringToStringArray($sourceList, ", ");
        $targetAttrs = stringToStringArray($targetList, ", ");
    }
    for ($i = 1; $i < size($sels); $i++) {
        if (size($targetAttrs) == 0) for ($attr in $sourceAttrs) connectAttr -f ($sels[0] + "." + $attr) ($sels[$i] + "." + $attr);
        else if (size($sourceAttrs) == 1 && size($targetAttrs) > 0) for ($targetAttr in $targetAttrs) connectAttr -f ($sels[0] + "." + $sourceAttrs[0]) ($sels[$i] + "." + $targetAttr);
        else if (size($sourceAttrs) == size($targetAttrs)) for ($j = 0; $j < size($sourceAttrs); $j++) connectAttr -f ($sels[0] + "." + $sourceAttrs[$j]) ($sels[$i] + "." + $targetAttrs[$j]);
        else if (size($targetAttrs) == 1) for ($j = 0; $j < size($sourceAttrs); $j++) connectAttr -f ($sels[0] + "." + $sourceAttrs[$j]) ($sels[$j+1] + "." + $targetAttrs[0]);
    }
}

//-------------------------------------------------------------nas_breakConnection---------------------------------------------------------------------
global proc nas_breakConnection(string $destName) {
    string $unitConversion, $array[];
    if ( `connectionInfo -isDestination $destName` ){
        string $destination = `connectionInfo -getExactDestination $destName`;

        // When deleting a src connection from a character, you must remove
        // the item from the character set or the character will no longer
        // work consistently: bug 127212
        //
        string $srcConn[] = `listConnections -s 1 -d 0 -type character $destination`;
        if (size($srcConn)) {
            string $warnMsg = (uiRes("m_generateChannelMenu.kRemovedWarn"));
            string $warnDisplay = `format -s $destination -s $srcConn[0] $warnMsg`;
            warning($warnDisplay);
            character -e -rm $srcConn[0] $destination;
        }
        
        // delete -icn doesn't work if destination attr is readOnly 
        // so use disconnectAttr in this case
        //
        string $sArr[1] = `ls -ro $destination`;
        if (size($sArr)) {
            string $src = `connectionInfo -sourceFromDestination $destination`;
            disconnectAttr $src $destination;
        } else {
            delete -icn $destination;
        }
    }
    $array = stringToStringArray(`connectionInfo -sfd $destName`, ".");
    $unitConversion = $array[0];
    if (size($unitConversion)) if (`nodeType $unitConversion` == "unitConversion") delete $unitConversion;
}

//-------------------------------------------------------------nas_limitAttrs---------------------------------------------------------------------
//limits default attrs
global proc nas_limitAttrs (int $toggle, string $attrList) { 
    string $sels[], $attrs[];
    float $value;
    if (size($attrList) == 0) $attrs = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"};
    else $attrs = stringToStringArray($attrList, ", ");
    $sels = `ls -sl`;
    for ($sel in $sels) {
        for ($attr in $attrs) {
            if ($toggle) {
                $value = `getAttr ($sel + "." + $attr)`;
                eval("transformLimits -" + $attr + " " + $value + " " + $value + " -e" + $attr + " 1 1 " + $sel);
            } else {
                eval("transformLimits -e" + $attr + " 0 0 " + $sel);
            }                
        }                                                             
    }
}

//-------------------------------------------------------------nas_centerCluster---------------------------------------------------------------------
global proc nas_centerCluster() {
    string $array[], $cluster, $shape;
    vector $wp;
    $array = `ls -sl`;
    $cluster = $array[0];
    $array = `listRelatives -s $cluster`;
    $shape = $array[0];
    $wp = `xform -q -ws -rp $cluster`;
    setAttr ($shape + ".origin") ($wp.x) ($wp.y) ($wp.z);
}

//-------------------------------------------------------------nas_checkWeighting---------------------------------------------------------------------
//sets keys for selected controls so that user can see how geo is deforming
global proc nas_checkWeighting(string $attrs[]) {
    string $sels[], $result, $text;
    int $time, $currentTime;
    float $value;
    $currentTime = `currentTime -q`;
    $time = $currentTime;
    $sels = `ls -sl`;
    if (`gmatch $attrs[0] "t?"` || `gmatch $attrs[0] "translate?"`) $text = "1";
    else $text = "90";
    $result = `promptDialog -title "By how much?" -ma "center" -message "Value:" -text $text -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
    if ($result == "OK") {
        $value = `promptDialog -query -text`;
        for ($sel in $sels) {
            for ($attr in $attrs) {
                setKeyframe -itt linear -ott linear -at $attr -time $time -v 0 $sel;
                setKeyframe -itt linear -ott linear -at $attr -time ($time + 120) -v $value $sel;
                setKeyframe -itt linear -ott linear -at $attr -time ($time + 240) -v (-1 * $value) $sel;
                setKeyframe -itt linear -ott linear -at $attr -time ($time + 360) -v 0 $sel;
                $time+=360;
            }
        }
        playbackOptions -min $currentTime -max $time -ast 0 -aet $time;
        currentTime $currentTime;
    }
}

//-------------------------------------------------------------nas_outliner---------------------------------------------------------------------
//Creates a custom picker for dag objects
global proc nas_outliner() {
    global string $nasOutlinerScroll, $nasOutlinerFlatCheck;
    string $window, $items[], $scrollCommand, $form, $selectButton, $upButton, $downButton, $flatCheck;

    if (`optionVar -exists "nasOutlinerItems"`) $items = `optionVar -q "nasOutlinerItems"`;
    $window = `nas_window nas_outliner 1 0 0`;
        $form = `formLayout`;
            $scrollCommand = "textScrollList -doubleClickCommand \"nas_outlinerFunctions selectAll\" -allowMultiSelection true -selectCommand \"nas_outlinerFunctions select\" -showIndexedItem 1";
            for ($item in $items) $scrollCommand += (" -append \"" + $item + "\"");
             $nasOutlinerScroll = `eval ($scrollCommand)`;
            nas_markingMenu 3 "" {
                "Add", "nas_outlinerFunctions add", "E", "0", "", 
                "Remove", "nas_outlinerFunctions remove", "W", "0", "", 
                "Sort", "nas_outlinerFunctions sort", "S", "0", "", 
                "Clear", "nas_outlinerFunctions clear", "N", "0", ""};
            $flatCheck = `checkBox -h 24 -label "Flatten"`;
             $selectButton = `button -label "Select" -c "nas_outlinerFunctions select"`;
             $upButton = `button -label "Up" -c "nas_outlinerFunctions up"`;
             $downButton = `button -label "Down" -c "nas_outlinerFunctions down"`;
            setParent..;
        formLayout -e
            -ap $flatCheck "right" 0 33
            -af $flatCheck "left" 5
            -af $flatCheck "top" 5    
        
            -ap $upButton "right" 0 66
            -ap $upButton "left" 0 33
            -af $upButton "top" 5 
            
            -af $downButton "right" 5
            -ap $downButton "left" 0 66
            -af $downButton "top" 5 
            
            -ac $nasOutlinerScroll "top" 5 $upButton
            -af $nasOutlinerScroll "right" 5
            -af $nasOutlinerScroll "left" 5
            -ac $nasOutlinerScroll "bottom" 5 $selectButton
            
            -af $selectButton "right" 5
            -af $selectButton "left" 5
            -af $selectButton "bottom" 5
           $form;
    $nasOutlinerFlatCheck = $flatCheck;
           
    window -e -rtf 1 $window;
    showWindow $window;
    nas_outlinerFunctions "add";
}

global proc nas_outlinerFunctions(string $option) {
    global string $nasOutlinerScroll, $nasOutlinerFlatCheck;
    string $items[], $allItems[], $sels[], $command, $selectCommand;
    int $indices[];
    
    if (`checkBox -q -v $nasOutlinerFlatCheck` == 1) $sels = `ls -os -fl`;
    else  $sels = `ls -os`;
    $items = `textScrollList -q -si $nasOutlinerScroll`;
    $allItems = `textScrollList -q -allItems $nasOutlinerScroll`;
    $indices = `textScrollList -q -selectIndexedItem $nasOutlinerScroll`;
    sort $indices;

    $command = "textScrollList -e ";
    switch ($option) {
        case "select":
            catchQuiet(`select -r $items`);
            break;
        case "selectAll":
            for ($item in $allItems) $command += ("-si " + "\"" + $item + "\" ");
                        select -cl;
                        for ($item in $allItems) {
                            catchQuiet(`select -add $item`);
                        }
            break;
        case "up":
            for ($i = 0; $i < size($items); $i++) {
                if (($indices[$i] - 1) < 1) $command += ("-ri " + "\"" + $items[$i] + "\" -appendPosition " + $indices[$i] + " \"" + $items[$i] + "\" ");
                else $command += ("-ri " + "\"" + $items[$i] + "\" -appendPosition " + ($indices[$i] - 1) + " \"" + $items[$i] + "\" ");
                $command += ("-si " + "\"" + $items[$i] + "\" ");
            }
            break;
        case "down":
            for ($i = 0; $i < size($items); $i++) $command += ("-ri " + "\"" + $items[$i] + "\" -appendPosition " + ($indices[$i] + 1) + " \"" + $items[$i] + "\" -si " + "\"" + $items[$i] + "\" ");
            break;
        case "add":
            if (size($sels) > 0) {
                textScrollList -e -da $nasOutlinerScroll;
                $selectCommand = "textScrollList -e ";
                for ($sel in $sels) for ($item in $allItems) if ($sel == $item) $selectCommand += ("-si \"" + $sel + "\" ");
                $selectCommand += $nasOutlinerScroll;
                eval $selectCommand;
                $sels = stringArrayRemove($allItems, $sels);
                if (size($sels) > 0) for ($sel in $sels) $command += ("-append \"" + $sel + "\" -si \"" + $sel + "\" ");
            }
            break;
        case "remove":
            if (size($items) > 0) {
                for ($item in $items) $command += ("-ri \"" + $item + "\" ");
                catchQuiet (`select -d $item`);
            }
            break;
        case "sort":
            if (size($allItems)) {
                for ($item in $allItems) $command += ("-ri \"" + $item + "\" ");
                for ($item in `sort $allItems`) $command += ("-append \"" + $item + "\" ");
                if (size($sels) > 0) for ($sel in $sels) $command += ("-si \"" + $sel + "\" ");
            }
            break;
        case "clear":
            if (size($allItems)) for ($item in $allItems) $command += ("-ri \"" + $item + "\" ");
            break;
    }
    $command += $nasOutlinerScroll;
    eval $command;
    
    //store items in scroll list in the nasOutliner optionVar
    $allItems = `textScrollList -q -allItems $nasOutlinerScroll`;
    if (`optionVar -exists "nasOutlinerItems"`) optionVar -rm "nasOutlinerItems";
    for ($item in $allItems) optionVar -stringValueAppend "nasOutlinerItems" $item;
}

//-------------------------------------------------------------nas_timeFormat---------------------------------------------------------------------
global proc string nas_timeFormat(float $time, int $nice) {
    string $secString, $timeString, $milliseconds, $array[];
    int $minutes, $seconds;
    
    $array[0] = $time%1.00;
    $array = stringToStringArray($array[0], ".");
    
    if (size($array[1]) > 2) $array[1] = `substring $array[1] 1 2`;
    else if (size($array[1]) < 2) $array[1] = ($array[1] + "0");
    $milliseconds = ("." + $array[1]);
    
    $seconds = $time%60;
    if ($seconds < 10) $secString = ("0" + $seconds);
    else $secString = $seconds;
    $minutes = $time/60;
    if ($nice) {
        if ($time > 30) {
            if ($minutes > 0) $timeString = ("about " + ($minutes + 1) + " minutes");
            else $timeString = "about 1 minute";
        } else {
            if ($time > 10) $timeString = "about 30 seconds";
            else $timeString = ("about " + (nas_roundTime($seconds)) + " seconds");
        }
    } else {
        $timeString = ($minutes + ":" + $secString + $milliseconds);
    }
    return $timeString;
}

//-------------------------------------------------------------nas_roundTime---------------------------------------------------------------------
global proc int nas_roundTime(int $seconds) {
    int $digit;
    string $num, $array[];
    
    $num = $seconds;
    $digit = `endString $num 1`;
    if ($digit < 5 && $digit > 0) {
        if (size($num) > 1) $num = (`substring $num 1 (size($num)-1)` + "5");
        else $num = "5";
    } else if ($digit > 5 && $digit > 0) {
        if (size($num) > 1) $array[0] = `substring $num (size($num)-1) (size($num)-1)`;
        else $array[0] = "0";
        $digit = $array[0];

        if (size($num) > 2) $num = (`substring $num 1 (size($num)-2)` + ($digit + 1) + "0");
        else $num = (($digit + 1) + "0");
       } else {
           $num = "5";
       }
    
    $digit = $num;
    return $digit;
}

//-------------------------------------------------------------nas_progress---------------------------------------------------------------------
//created by Nick Man Puetz
//modified by Dave T-shirt Kim
//make loop number -1 to start the progress bar outside of loop
//make loop number -2 to end progress bar outside of loop at end of proc
global proc int nas_progress(int $maxValue, string $status) {
    global string $gMainProgressBar;
    global int $nas_progressStartTime, $nas_progressMaxValue, $nas_progressOverride, $nas_progressCyclesLeft, 
    $nas_progressStartMax;
    string $message;
    float $time;
    int $override, $count;

    $count = `progressBar -q -progress $gMainProgressBar`;
    if ($status == "startOverride") {
        SelectTool;
        waitCursor -state 1;
        progressBar -e -isInterruptable true -beginProgress -maxValue $maxValue $gMainProgressBar;
        $nas_progressMaxValue = $maxValue;
        $nas_progressCyclesLeft = $maxValue;
        $nas_progressStartTime = `timerX`;
        $nas_progressOverride = 1;
    }
    if ($nas_progressOverride == 1) {
        if ($status == "start") {
            $nas_progressMaxValue = $count + $nas_progressCyclesLeft * $maxValue;
            //progressBar -e -maxValue $nas_progressMaxValue $gMainProgressBar;
        } else if ($status == "endOverride") {
            waitCursor -state 0;
            progressBar -e -endProgress $gMainProgressBar;
            $nas_progressOverride = 0;
            print ("\nTotal Elapsed Time: " + (nas_timeFormat(`timerX -startTime $nas_progressStartTime`, 0)));
        } else if ($status == "end") {
            $nas_progressCyclesLeft--;
        }
    } else {
        if ($status == "start") {
            SelectTool;
            waitCursor -state 1;
            progressBar -e -isInterruptable true -beginProgress -progress 1 -maxValue $maxValue $gMainProgressBar;
            $nas_progressMaxValue = $maxValue;
            $nas_progressStartTime = `timerX`;
        }  else if ($status == "end") {
            waitCursor -state 0;
            progressBar -e -endProgress $gMainProgressBar;
            print ("\nTotal Elapsed Time: " + (nas_timeFormat(`timerX -startTime $nas_progressStartTime`, 0)));
        }
    }
    if ($status != "startOverride" && $status != "start" && $status != "end") {
        if ($count < 1) $count = 1;
        $time = (($nas_progressMaxValue-$count) * (`timerX -startTime $nas_progressStartTime`/$count));
        if ($nas_progressMaxValue > 20) {
            if ($count < 10) $message = "estimating time remaining...";
            else $message = ((nas_timeFormat($time, 1)) + " remaining. " + $status);
        } else {
            if ($count < 3) $message = "estimating time remaining...";
            else $message = ((nas_timeFormat($time, 1)) + " remaining. " + $status);
        }
        progressBar -e -step 1 -status $message $gMainProgressBar;
    }
    
    if (`progressBar -q -isCancelled $gMainProgressBar`) {
        waitCursor -state 0;
        progressBar -e -endProgress $gMainProgressBar;
        print ("\nOperation Cancelled\nTotal Elapsed Time: " + (nas_timeFormat(`timerX -startTime $nas_progressStartTime`, 0)));
        return 1;
    } else {
        return 0;
    }
}

//-------------------------------------------------------------nas_getSkinCluster---------------------------------------------------------------------
global proc string nas_getSkinCluster(string $object) {
    string $hists[], $skinCluster, $array[];
    $hists = `listHistory -pdo 1 -il 2 $object`;
    for ($hist in $hists) if (nodeType($hist) == "skinCluster") {
        $skinCluster = $hist;
        break;
    }
    return $skinCluster;
}

//-------------------------------------------------------------nas_skinCluster---------------------------------------------------------------------
global proc string nas_skinCluster() {
    string $joints[], $surfaces[], $array[], $cmd, $shape, $geo, $skinCluster, $tempJoint, $infs[];
    int $holds[];
    
    //separate surfaces from joints
    $array = `ls -sl`;
    $geo = $array[size($array)-1];
    $array = stringArrayRemove({$geo}, $array);
    $joints = `ls -sl -type joint`;
    $array = stringArrayRemove($joints, $array);
    $surfaces = $array;
    $skinCluster = `nas_getSkinCluster $geo`;
    
    //get rid of influences that already exist in the skincluster
    if (`objExists $skinCluster`) {
        $array = `skinCluster -q -inf $skinCluster`;
        $joints = stringArrayRemove($array, $joints);
        $surfaces = stringArrayRemove($array, $surfaces);
    } else {
        print "\nBound the following joints:\n";
        print $joints;
        print ("to " + $geo);
    }
    
    //hold all influences on skinCluster if it exists
    if (`objExists $skinCluster`) {
        $infs = `skinCluster -q -inf $skinCluster`;
        for ($i = 0; $i < size($infs); $i++) {
            $holds[$i] = `getAttr ($infs[$i] + ".liw")`;
            setAttr ($infs[$i] + ".liw") 1;
        }
    }
    
    //bind joints
    if (size($joints)) {
        if (`objExists $skinCluster`) {
            $cmd = "skinCluster -e -ug -dr 10 -ps 0 -ns 10";
            for ($joint in $joints) $cmd += (" -ai " + $joint);
            $cmd += (" " + $skinCluster);
            eval($cmd);
        } else {
            select -r $joints $geo;
            $array = `newSkinCluster "-toSelectedBones -ignoreHierarchy -dr 10 -rui false"`;
            $skinCluster = $array[0];
        }
    }
    
    //bind surfaces
    if (size($surfaces)) {
        if (!`objExists $skinCluster`) {
            select -cl;
            $tempJoint = `joint -n "tempJoint" -p 0 0 0`;
            select -r $tempJoint $geo;
            $array = `newSkinCluster "-toSelectedBones -ignoreHierarchy -dr 10 -rui false"`;
            $skinCluster = $array[0];
        }
        nas_progress (size($surfaces)) "start";
        for ($i = 0; $i < (size($surfaces)); $i++) {
            if (`nas_progress 0 ("binding " + $surfaces[$i] + " to " + $geo + ", " + ((size($surfaces))-$i) + " influences left")`) return "";
            skinCluster -e -ug -dr 10 -ps 0 -ns 10 -ai $surfaces[$i] $skinCluster;
        }
        nas_progress 0 "end";
        for ($surface in $surfaces) setAttr ($surface + ".v") 1;        
        if (`objExists $tempJoint`) delete $tempJoint;
    }
    if (size($infs)) for ($i = 0; $i < size($infs); $i++) setAttr ($infs[$i] + ".liw") $holds[$i];
    select -r $joints $surfaces;
    return $skinCluster;
}

//-------------------------------------------------------------nas_weight---------------------------------------------------------------------
global proc nas_weight(int $ave, int $center, string $joints[]) {
    string $verts[], $loc, $skinCluster, $hists[], $object, $array[];
    float $floatArray[];
    int $currentTime;

    for ($joint in $joints) if (!`objExists $joint`) error ($joint + " does not exist.");
    if (size($joints) > 2) error "Please select 2 joints or less.";
    
    $array = `ls -sl -fl`;
    if (`gmatch $array[0] "*.cv*"`) {
    } else {
        ConvertSelectionToVertices;
    }
    $verts = `ls -sl -fl`;
    $array = stringToStringArray($verts[0], ".");
    $object = $array[0];
    $hists = `listHistory -pdo 1 -il 2`;
    for ($hist in $hists) {
        if (nodeType($hist) == "skinCluster") {
            $skinCluster = $hist;
            break;
        }
    }
    if ($skinCluster == "") error "no skin cluster associated with selected verts";
    setAttr ($skinCluster + ".envelope") 0;
    $currentTime = `currentTime -q`;
    currentTime 0;
    skinPercent -pruneWeights 100 -normalize off $skinCluster $verts;
    if (size($joints) == 1) {
        skinPercent -normalize off -tv $joints[0] 1 $skinCluster $verts;
    } else {
        if (size($joints) == 2 && $ave == 1) {
            if ($center) {
                $array = `nas_locator 0`;
                $loc = $array[0];
                $floatArray = `nas_distanceBetween $loc $joints[0] $joints[1]`;
                skinPercent -normalize off -tv $joints[0] $floatArray[0] $skinCluster $verts;
                skinPercent -normalize off -tv $joints[1] (1-$floatArray[0]) $skinCluster $verts;
                delete $loc;
            } else {
                for ($vert in $verts) {
                    $floatArray = `nas_distanceBetween $vert $joints[0] $joints[1]`;
                    skinPercent -normalize off -tv $joints[0] $floatArray[0] $skinCluster $vert;
                    skinPercent -normalize off -tv $joints[1] (1-$floatArray[0]) $skinCluster $vert;
                }
            }
        } else {
            $cmd = "skinPercent -normalize off";
            for ($joint in $joints) $cmd += (" -tv " + $joint + " " + (1.0/(size($joints))));
            $cmd += (" " + $skinCluster + " `ls -sl`");
            eval($cmd);
        }
    }
    skinPercent -normalize on $skinCluster $verts;
    setAttr ($skinCluster + ".envelope") 1;
    currentTime $currentTime;
    select -r $verts;
    hilite -r $object;
    $message = "weight painted for";
    for ($joint in $joints) $message += (" " + $joint);
    print ($message + "!");
}

global proc nas_weightFoundation(string $baseJnt, float $amount, string $joints[]) {
    string $verts[], $loc, $skinCluster, $histories[], $array[];
    float $totalDist, $totalWeight, $weights[];

    for ($joint in $joints) if (!`objExists $joint`) error ($joint + " does not exist.");
    if (!`objExists $baseJnt`) error ($baseJnt + " does not exist.");
    $array = `nas_stringArrayIntersection {$baseJnt} $joints`;
    if (size($array)) error "Foundation joint must be different than the joints you are trying to preserve.";
    $verts = `ls -sl -fl`;
    $histories = `listHistory -pdo 1 -il 2`;
    for ($history in $histories) if (nodeType($history) == "skinCluster") {
        $skinCluster = $history;
        break;
    }
    for ($vert in $verts) {
        $totalWeight = 0;
        for ($joint in $joints) {
            $weights[size($weights)] = `skinPercent -transform $joint -query $skinCluster $vert`;
            $totalWeight += `skinPercent -transform $joint -query $skinCluster $vert`;
        }
        skinPercent -pruneWeights 100 -normalize off $skinCluster $vert;
        skinPercent -normalize off -tv $baseJnt $amount $skinCluster $vert;
        for ($i = 0; $i < size($joints); $i++) skinPercent -normalize off -tv $joints[$i] ((1-$amount) * ($weights[$i]/$totalWeight)) $skinCluster $vert;
    }
}

global proc nas_weightUI() {
    string $window, $items[], $nas_weightScrollCommand;
    string $form, $upButton, $downButton, $weightButton, $sels[], $foundationName, $holdButton, $unholdButton, $paintButton, 
    $mimicButton, $pinchButton, $vertsButton, $workButton, $selsButton, $compButton;
    string $version, $array[];
    $version = `about -v`;
    $array = stringToStringArray($version, " ");
    $version = $array[0];
    
    global string $nas_weightScroll, $nas_weightWindow, $nas_weightCenterCheckBox, $nas_weightBaseJntText, $nas_weightFoundationSlider;
    if (`optionVar -exists "nas_weightPrefsFoundation"`) $foundationName = `optionVar -q "nas_weightPrefsFoundation"`;
    if (`optionVar -exists "nas_weightPrefs"`) $items = `optionVar -q "nas_weightPrefs"`;

    $window = `nas_window nas_weightWindow 1 1 0`;
        $form = `formLayout`;
            //$nas_weightBaseJntText = `textField -text $foundationName -width 100 -annotation "Type name of foundation joint here!" -font "boldLabelFont"`;
            //$nas_weightFoundationSlider = `floatSliderGrp -adjustableColumn 2 -cw 1 40 -field 1 -changeCommand "nas_weightUIExecute 1" -fieldMinValue 0 -fieldMaxValue .9 -minValue 0 -maxValue .9 -value 0 -step .001`;
            $nas_weightScrollCommand = "textScrollList -deleteKeyCommand \"textScrollList -e -da $nas_weightScroll;\" ";
            for ($item in $items) $nas_weightScrollCommand += ("-append \"" + $item + "\" ");
            $nas_weightScrollCommand += " -doubleClickCommand \"for ($i = 1; $i <= `textScrollList -q -numberOfItems $nas_weightScroll`; $i++) textScrollList -e -sii $i $nas_weightScroll;\" -allowMultiSelection true -showIndexedItem 1 nas_weightScroll";
            $nas_weightScroll = eval($nas_weightScrollCommand);
                nas_markingMenu 3 "" {
                    "Clear", "nas_weightFunctions clear", "N", "0", "", 
                    "Sort", "nas_weightFunctions sort", "S", "0", "", 
                    "Add", "nas_weightFunctions add", "E", "0", "", 
                    "Add All", "nas_weightFunctions addAll", "SE", "0", "", 
                    "Remove", "nas_weightFunctions remove", "W", "0", "", 
                    "Select", "nas_weightFunctions select", "SW", "0", ""};
                nas_markingMenu 2 "" {
                    "Source", "nas_weightAverageGet", "W", "0", "", 
                    "Average", "nas_weightAverage 2", "E", "0", "", 
                    "Slider", "nas_weightAverageBias", "N", "0", "", 
                    "Closest", "nas_weightExact", "S", "0", ""};
                nas_markingMenu 3 "ctrl" {
                    "Opacity: 100%", "nas_paintSettings opacity 1", "NE", "0", "", 
                    "Opacity: 50%", "nas_paintSettings opacity .5", "E", "0", "",
                    "Opacity: 10%", "nas_paintSettings opacity .1", "SE", "0", "",
                    "Value: .02", "nas_paintSettings value .02", "SW", "0", "", 
                    "Value: .05", "nas_paintSettings value .05", "W", "0", "", 
                    "Value: .10", "nas_paintSettings value .10", "NW", "0", "",
                    "Full", "nas_paintSettings value 1; nas_paintSettings opacity 1;", "N", "0", ""};
                nas_markingMenu 3 "alt" {
                                        "Opacity -", "nas_paintSet \"opacity\" -1.0", "W", "0", "",
                                        "Opacity +", "nas_paintSet \"opacity\" 1.0", "E", "0", "", 
                                        "Value -", "nas_paintSet \"value\" -1.0", "S", "0", "", 
                                        "Value +", "nas_paintSet \"value\" 1.0", "N", "0", ""};
                                nas_markingMenu 2 "alt" {
                    "-", "nas_paintSettings value .125; nas_paintSettings opacity .9;", "SW", "0", "",
                    "Blocking", "nas_paintSettings value .125; nas_paintSettings opacity .82;", "W", "0", "",
                    "-", "nas_paintSettings value .125; nas_paintSettings opacity .67;", "NW", "0", "", 
                    "Breakdown", "nas_paintSettings value .125; nas_paintSettings opacity .50;", "N", "0", "",
                    "-", "nas_paintSettings value .125; nas_paintSettings opacity .32;", "NE", "0", "", 
                    "Fine Tuning", "nas_paintSettings value .125; nas_paintSettings opacity .16;", "E", "0", "", 
                    "-", "nas_paintSettings value .125; nas_paintSettings opacity .1;", "SE", "0", "",
                    "Full", "nas_paintSettings value 1; nas_paintSettings opacity 1;", "S", "0", ""};
            $workButton = `button -label "Work" -c "nas_weightFunctions work"`;
                nas_markingMenu 3 "" {
                    "Unhold All", "nas_weightFunctions \"unholdall\"", "W", "0", "",
                    "Hold All", "nas_weightFunctions \"holdall\"", "E", "0", ""
                    };
            //$paintButton = `button -label "Paint" -c "ArtPaintSkinWeightsTool;"`;
            $compButton = `button -label "Scroll" -c "nas_paintValueUI"`;
             $upButton = `button -label "Up" -c "nas_weightFunctions up"`;
             $downButton = `button -label "Down" -c "nas_weightFunctions down"`;
            
            $executeForm = `formLayout`;
                $divideButton = `button -label "Divide" -c "nas_weightUIExecute 0"`;
                $weightButton = `button -label "Weight" -c "nas_weightUIExecute 1"`;
                popupMenu -b 3;
                    $nas_weightCenterCheckBox = `menuItem -label "Based Off Center of Verts" -ann "Weights selected verts all at once based off of the distance from the center of selection to selected joints in joint list." -checkBox true`;
                    setParent -m ..;
                setParent..;
            setParent..;
        
        formLayout -e 
            -ap $divideButton "right" 0 50
            -af $divideButton "left" 0
            -af $divideButton "top" 0
            -af $divideButton "bottom" 0
            
            -ap $weightButton "left" 0 50
            -af $weightButton "right" 0
            -af $weightButton "top" 0
            -af $weightButton "bottom" 0
        $executeForm;
        
        formLayout -e
            -ap $upButton "right" 0 50
            -af $upButton "left" 0 
            -af $upButton "top" 0 

            -ap $downButton "left" 0 50
            -af $downButton "right" 0 
            -af $downButton "top" 0 

            -ac $nas_weightScroll "top" 0 $upButton 
            -af $nas_weightScroll "right" 0
            -af $nas_weightScroll "left" 0
            -ac $nas_weightScroll "bottom" 0 $workButton

            //-ap $paintButton "right" 0 25
            //-af $paintButton "left" 0
            //-ac $paintButton "bottom" 0 $executeForm

            -ap $workButton "right" 0 50
            -af $workButton "left" 0
            -ac $workButton "bottom" 0 $executeForm 

            -af $compButton "right" 0
            -ap $compButton "left" 0 50
            -ac $compButton "bottom" 0 $executeForm

            -af $executeForm "left" 0 
            -af $executeForm "right" 0
            -af $executeForm "bottom" 0 
        $form;
    
    print ("\n" + $window);
    //window -e -wh 259 198 $window;
    showWindow $window;
    $nas_weightWindow = $window;
}

global proc nas_weightUIExecute(int $ave) {
    global string $nas_weightScroll, $nas_weightCenterCheckBox;

    nas_weight $ave `menuItem -q -cb $nas_weightCenterCheckBox` `textScrollList -q -si $nas_weightScroll`;
}

global proc nas_weightFunctions(string $option) {
    global string $nas_weightScroll, $nas_weightBaseJntText, $nas_mimicTargetObj;
    int $indices[], $windowHeight, $num, $selNotJoints;
    string $items[], $allItems[], $command, $selectCommand, $attrs[], $sels[], $baseJnt, $array[], $result, $geo, $verts[],  
    $baseObj, $panels[], $skinCluster, $allInfs[], $holds[], $shapes[], $message;
    
    $items = `textScrollList -q -si $nas_weightScroll`;
    $allItems = `textScrollList -q -allItems $nas_weightScroll`;
    $indices = `textScrollList -q -selectIndexedItem $nas_weightScroll`;
    sort $indices;
    
    $command = "textScrollList -e ";
    if ($option == "selectAll") {
        for ($item in $allItems) $command += ("-si " + "\"" + $item + "\" ");
        select -r $allItems;
    } else if ($option == "work") {
        /*$array = `ls -sl -fl`;
        if (size($array) == 0) error "No geometry selected, please select a geometry before running holding operations.";
        $shapes = `listRelatives -s $array[0]`;
        if (size($shapes) > 0) {
            if (`nodeType $shapes[0]` != "mesh" && `nodeType $shapes[0]` != "nurbsCurve" && `nodeType $shapes[0]` != "nurbsSurface" && `nodeType $shapes[0]` != "lattice") error "No geometry selected, please select a geometry before running holding operations.";
        } else {
            if (`gmatch $array[0] "*.vtx*"` == 0 && `gmatch $array[0] "*.pt*"` == 0 && `gmatch $array[0] "*.cv*"` == 0) error "Dude, no geometry selected, please select a geometry before running holding operations.";
        }
        
        $skinCluster = `nas_getSkinCluster $array[0]`;
        $allInfs = `skinCluster -q -inf $skinCluster`;
        */
        $allInfs = `ls -type "joint"`;
        if (size($items)) {
            for ($inf in $allInfs) {
                catchQuiet(`setAttr ($inf + ".liw") 0`);
            }
            $holds = stringArrayRemove($items, $allInfs);
            for ($hold in $holds) {
                catchQuiet(`setAttr ($hold + ".liw") 1`);
            }
            $message = "Working on";
            for ($item in $items) $message += (" " + $item);
            print ($message + ".");
        } else {
            if (`getAttr ($allInfs[0] + ".liw")` == 0) {
                for ($inf in $allInfs) {
                    catchQuiet(`setAttr ($inf + ".liw") 1`);
                }
                print "All joints set to HOLD";
            } else {
                for ($inf in $allInfs) {
                    catchQuiet(`setAttr ($inf + ".liw") 0`);
                }
                print "All joints set to UN-HOLD";
            }
        }
        
        if (`window -exists skinningToolsUI`) {
            ST_ListSmoothSkinInfluences `textField -q -tx skinningTools_SkinClusterTF` `ST_GetActiveSet`;
            textScrollList -e -sii 1 skinningTools_InfluenceTSL;
        }
    } else if ($option == "unholdall" || $option == "holdall") {
        $allInfs = `ls -type "joint"`;
        if ($option == "holdall") {
            for ($inf in $allInfs) {
                if (`objExists ($inf + ".liw")`) {
                    setAttr ($inf + ".liw") 1;
                }
            }
            print "All joints set to HOLD";
        } else if ($option == "unholdall") {
            for ($inf in $allInfs) {
                if (`objExists ($inf + ".liw")`) {
                    setAttr ($inf + ".liw") 0;
                }
            }
            print "All joints set to UN-HOLD";
        }
    } else if ($option == "up") {    
        for ($i = 0; $i < size($items); $i++) {
            if (($indices[$i] - 1) < 1) $command += ("-ri " + "\"" + $items[$i] + "\" -appendPosition " + $indices[$i] + " \"" + $items[$i] + "\" ");
            else $command += ("-ri " + "\"" + $items[$i] + "\" -appendPosition " + ($indices[$i] - 1) + " \"" + $items[$i] + "\" ");
            $command += ("-si " + "\"" + $items[$i] + "\" ");
        }
    } else if ($option == "down") {
        for ($i = 0; $i < size($items); $i++) $command += ("-ri " + "\"" + $items[$i] + "\" -appendPosition " + ($indices[$i] + 1) + " \"" + $items[$i] + "\" -si " + "\"" + $items[$i] + "\" ");
    } else if ($option == "add") {
        //$sels = `skinCluster -q -inf TSM2_skinCluster`;
        $sels = `ls -sl`;
        if (size($sels)) {
            for ($sel in $sels) if (`nodeType $sel` != "joint") {
                $selNotJoints = 1;
                break;
            }
            if ($selNotJoints) {
                            if (`nodeType $sel` == "mesh" || `nodeType $sel` == "lattice" || `nodeType $sel` == "nurbsCurve" || `nodeType $sel` == "nurbsSurface") {
                $sels = `nas_influencesFromVerts`;
                $array = `ls -sl`;
                $skinCluster = `nas_getSkinCluster $array[0]`;
                setAttr ($skinCluster + ".normalizeWeights") 1;
                            }
            }
            textScrollList -e -da $nas_weightScroll;
            $selectCommand = "textScrollList -e ";
            for ($sel in $sels) for ($item in $allItems) if ($sel == $item) $selectCommand += ("-si \"" + $sel + "\" ");
            $selectCommand += $nas_weightScroll;
            eval $selectCommand;
            $sels = stringArrayRemove($allItems, $sels);
            for ($sel in $sels) if (`nodeType $sel` == "joint") $command += ("-append \"" + $sel + "\" -si \"" + $sel + "\" ");
        }
    } else if ($option == "addAll") {
        //$sels = `skinCluster -q -inf TSM2_skinCluster`;
        $sels = `ls -sl`;
        if (size($sels)) {
            for ($sel in $sels) if (`nodeType $sel` != "joint") {
                $selNotJoints = 1;
                break;
            }
            if ($selNotJoints) {
                $array = `ls -sl`;
                $skinCluster = `nas_getSkinCluster $array[0]`;
                setAttr ($skinCluster + ".normalizeWeights") 1;
                $sels = `skinCluster -q -inf $skinCluster`;
            }
            textScrollList -e -da $nas_weightScroll;
            $selectCommand = "textScrollList -e ";
            for ($sel in $sels) for ($item in $allItems) if ($sel == $item) $selectCommand += ("-si \"" + $sel + "\" ");
            $selectCommand += $nas_weightScroll;
            eval $selectCommand;
            $sels = stringArrayRemove($allItems, $sels);
            for ($sel in $sels) if (`nodeType $sel` == "joint") $command += ("-append \"" + $sel + "\" -si \"" + $sel + "\" ");
        }
    } else if ($option == "remove") {
        if (size($items) > 0) for ($item in $items) $command += ("-ri \"" + $item + "\" ");
    } else if ($option == "pinch") {
        nas_weightPinch $items;
    } else if ($option == "mimic") {
        $sels = `ls -sl`;
        $array = stringToStringArray($sels[0], ".");
        if (`objExists $nas_mimicTargetObj`) {
            nas_mimic $items $nas_mimicTargetObj;
        } else {
            $result = `promptDialog -title "Name of target geo?" -ma "center" -message "Name of target geo:" -text ($array[0] + "1") -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;
            if ($result == "OK") nas_mimic $items `promptDialog -query -text`;
        }
    } else if ($option == "get") {
        $sels = `nas_influencesFromVerts`;
        $array = `ls -sl`;
        $skinCluster = `nas_getSkinCluster $array[0]`;
        setAttr ($skinCluster + ".normalizeWeights") 1;
        textScrollList -e -da $nas_weightScroll;
        $selectCommand = "textScrollList -e ";
        for ($sel in $sels) for ($item in $allItems) if ($sel == $item) $selectCommand += ("-si \"" + $sel + "\" ");
        $selectCommand += $nas_weightScroll;
        eval $selectCommand;
        $sels = stringArrayRemove($allItems, $sels);
        if (size($sels) > 0) for ($sel in $sels) $command += ("-append \"" + $sel + "\" -si \"" + $sel + "\" ");
    } else if ($option == "verts") {
        ConvertSelectionToVertices;
        $panels = `nas_getVisibleModelPanels`;
        for ($panel in $panels) {
            enableIsolateSelect $panel 0;
            isolateSelect -state 0 $panel;
        }
        $sels = `ls -sl`;
        $array = stringToStringArray($sels[0], ".");
        $nas_mimicTargetObj = $array[0];
        hide $nas_mimicTargetObj;
        $baseObj = startString($array[0], size($array[0])-1);
        setAttr ($baseObj + ".v") 1;
        for ($sel in $sels) {
            $array = stringToStringArray($sel, ".");
            $verts[size($verts)] = ($baseObj + "." + $array[1]);
        }
        select -r $verts;
    } else if ($option == "select") {
        select -r $items;
    } else if ($option == "sort") {
        if (size($allItems)) for ($item in $allItems) $command += ("-ri \"" + $item + "\" ");
        if (size($allItems)) for ($item in sort($allItems)) $command += ("-append \"" + $item + "\" ");
        if (size($items)) for ($item in $items) $command += ("-si \"" + $item + "\" ");
    } else if ($option == "clear") {
        if (size($allItems)) for ($item in $allItems) $command += ("-ri \"" + $item + "\" ");
    }
        
    $command += $nas_weightScroll;
    eval $command;
    
    $allItems = `textScrollList -q -allItems $nas_weightScroll`;
    if (`optionVar -exists "nas_weightPrefs"`) optionVar -rm "nas_weightPrefs";
    for ($allItem in $allItems) optionVar -stringValueAppend "nas_weightPrefs" $allItem;
    
    //$baseJnt = `textField -q -text $nas_weightBaseJntText`;
    //optionVar -stringValue "nas_weightPrefsFoundation" $baseJnt;
    
    $num = `textScrollList -q -ni $nas_weightScroll`;
}

//-------------------------------------------------------------nas_holdInfluences---------------------------------------------------------------------
global proc nas_holdInfluences(int $hold) {
    string $sels[];
    
    $sels = `ls -sl`;
    for ($inf in `skinCluster -q -inf $sels[0]`) setAttr ($inf + ".liw") $hold;
}

//-------------------------------------------------------------nas_influencesFromVerts---------------------------------------------------------------------
global proc string[] nas_influencesFromVerts() {
    string $verts[], $hists[], $skinCluster, $influences[];
    $verts = `ls -sl`;
    $hists = `listHistory -pdo 1 -il 2`;
    for ($hist in $hists) {
        if (nodeType($hist) == "skinCluster") {
            $skinCluster = $hist;
            break;
        }
    }
    $influences = `skinPercent -ignoreBelow .0000000001 -q -t $skinCluster $verts`;
    return $influences;
}

//-------------------------------------------------------------nas_mimic---------------------------------------------------------------------
//mimics how a duplicate looks through weighting of two influences
global proc nas_mimic(string $joints[], string $targetObj) {
    global string $gMainProgressBar, $nas_mimicTargetObj;
    string $verts[], $skinCluster, $object, $array[], $loc, $targetVerts[], $undoCmd, $influences[];
    float $lowestDist, $lowestWeight, $totalWeight, $finalTerm, $distance;
    vector $wp, $pos1, $pos2;

    $verts = `ls -sl -flatten`;
    if (size($joints) != 2) error "please input only two influences";
    
    $skinCluster = `nas_getSkinCluster $verts[0]`;
    $influences = `skinPercent -q -t $skinCluster $verts`;
    for ($influence in $influences) setAttr ($influence + ".liw") 1;
    for ($joint in $joints) {
        if (!`objExists $joint`) error ($joint + " does not exist.");
        setAttr ($joint + ".liw") 0;
    }
    
    for ($i = 0; $i < size($verts); $i++) {
        $array = stringToStringArray($verts[$i], ".");
        $targetVerts[$i] = ($targetObj + "." + $array[1]);
    }
    $object = $array[0];
    
    hide $targetObj;
    nas_progress (size($verts)) "start";
    
    for ($i = 0; $i < size($verts); $i++) {
        $pos1 = `xform -query -translation -worldSpace $targetVerts[$i]`;
        
        $totalWeight = 0;
        for ($joint in $joints) $totalWeight += `skinPercent -transform $joint -query $skinCluster $verts[$i]`;
        if ($totalWeight > 0) {
            select -r $verts[$i];
            $array = `nas_locator 0`;
            $loc = $array[0];
            skinPercent -normalize off -tv $joints[0] 0 $skinCluster $verts[$i];
            skinPercent -normalize off -tv $joints[1] $totalWeight $skinCluster $verts[$i];
            $wp = `xform -q -translation -ws $verts[$i]`;
            setKeyframe -itt linear -ott linear -t 0 -v ($wp.x) ($loc + ".tx");
            setKeyframe -itt linear -ott linear -t 0 -v ($wp.y) ($loc + ".ty");
            setKeyframe -itt linear -ott linear -t 0 -v ($wp.z) ($loc + ".tz");
            skinPercent -normalize off -tv $joints[0] $totalWeight $skinCluster $verts[$i];
            skinPercent -normalize off -tv $joints[1] 0 $skinCluster $verts[$i];
            $wp = `xform -q -translation -ws $verts[$i]`;
            setKeyframe -itt linear -ott linear -t 100 -v ($wp.x) ($loc + ".tx");
            setKeyframe -itt linear -ott linear -t 100 -v ($wp.y) ($loc + ".ty");
            setKeyframe -itt linear -ott linear -t 100 -v ($wp.z) ($loc + ".tz");
            
            $pos2 = `getAttr -t 0 ($loc + ".translate")`;
            $finalTerm = (pow(($pos2.x - $pos1.x), 2)) + (pow(($pos2.y - $pos1.y), 2)) + (pow(($pos2.z - $pos1.z), 2));
            $lowestDist = `sqrt $finalTerm`;
            $lowestWeight = 0;
            for ($j = 0; $j <= 100; $j++) {
                $pos2 = `getAttr -t $j ($loc + ".translate")`;
                $finalTerm = (pow(($pos2.x - $pos1.x), 2)) + (pow(($pos2.y - $pos1.y), 2)) + (pow(($pos2.z - $pos1.z), 2));
                $distance = `sqrt $finalTerm`;
    
                if ($distance < $lowestDist) {
                    $lowestDist = $distance;
                    $lowestWeight = (.01*$j*$totalWeight);
                }
            }
            skinPercent -normalize off -tv $joints[0] $lowestWeight $skinCluster $verts[$i];
            skinPercent -normalize off -tv $joints[1] ($totalWeight-$lowestWeight) $skinCluster $verts[$i];
            delete $loc;
        }
        if (`nas_progress 0 ""`) return;
    }
    for ($influence in $influences) setAttr ($influence + ".liw") 0;
    nas_progress 0 "end";
    select -r $verts;
    setSelectMode components Components;
    selectType -v 1 -smp 0 -sme 0 -smf 0 -smu 0 -pv 1 -pe 0 -pf 0 -puv 0;
    hilite -r $object;
    print "Mimic finished!";
}

//-------------------------------------------------------------nas_distanceBetween---------------------------------------------------------------------
//input one object and two anchor objects
//returns a 0 to 1 percentage of the object to the first anchor object
//also returns the distances from each anchor on the line that the two anchors create
//and finally returns the distance between the two anchors
global proc float[] nas_distanceBetween(string $object, string $anchor1, string $anchor2) {
    float $hyps[], $dists[], $angle, $percent;
    vector $anchor1WS, $anchor2WS, $objectWS;

    $hyps[0] = `nas_distance{$object, $anchor1}`;
    $hyps[1] = `nas_distance{$object, $anchor2}`;
    
    if (`nodeType $object` == "mesh") $objectWS = `xform -ws -q -translation $object`;
    else $objectWS = `xform -ws -q -rp $object`;
    if (`nodeType $anchor1` == "mesh") $anchor1WS = `xform -ws -q -translation $anchor1`;
    else $anchor1WS = `xform -ws -q -rp $anchor1`;
    if (`nodeType $anchor2` == "mesh") $anchor2WS = `xform -ws -q -translation $anchor2`;
    else $anchor2WS = `xform -ws -q -rp $anchor2`;
    
    //get first distance
    $angles[0] = angle(($objectWS - $anchor1WS), ($anchor2WS - $anchor1WS));
    $dists[0] = cos($angles[0]) * $hyps[0];
    //get second distance
    $angles[1] = angle(($objectWS - $anchor2WS), ($anchor1WS - $anchor2WS));
    $dists[1] = cos($angles[1]) * $hyps[1];
    if (`rad_to_deg $angles[0]` > 90) {
        $percent = 1;
    } else {
        if (`rad_to_deg $angles[1]` > 90) $percent = 0;
        else $percent = 1-($dists[0]/($dists[0]+$dists[1]));
    }

    return {$percent, $dists[0], $dists[1], ($dists[0]+$dists[1])};
}

//-------------------------------------------------------------nas_weightAverageGet---------------------------------------------------------------------
global proc nas_weightAverageGet() {
    global string $nas_weightAverageSourceObj, $nas_weightAverageSourceVerts[];    
    string $array[];
    $array = `ls -sl -flatten`;    
    if (`gmatch $array[0] "*.e*"`) {
        $nas_weightAverageSourceVerts = `nas_getEndVerts`;
        $array = stringToStringArray($nas_weightAverageSourceVerts[0], ".");
        $nas_weightAverageSourceObj = $array[0];
        selectType -v 1 -smp 0 -sme 0 -smf 0 -smu 0 -pv 1 -pe 0 -pf 0 -puv 0;
        hilite -r $nas_weightAverageSourceObj;
    } else if (`gmatch $array[0] "*.vtx*"` || `gmatch $array[0] "*.pt*"` || `gmatch $array[0] "*.cv*"`) {
        $nas_weightAverageSourceVerts = `ls -sl -flatten`;
        $array = stringToStringArray($nas_weightAverageSourceVerts[0], ".");
        $nas_weightAverageSourceObj = $array[0];
    } else {
        $nas_weightAverageSourceObj = $array[0];
        clear $nas_weightAverageSourceVerts;
    }
}

//-------------------------------------------------------------nas_weightAverageBias---------------------------------------------------------------------
global proc nas_weightAverageBias() {
    global string $nas_weightAverageBiasSlider;
    string $window, $form;
    
    $window = `nas_window nas_weightAverageBias 1 0 0`;
        $form = `formLayout`;
            $nas_weightAverageBiasSlider = `floatSliderGrp -label "Vert Bias" -field true
                -minValue 0.0 -maxValue 1.0
                -fieldMinValue 0.0 -fieldMaxValue 1.0
                -cw 1 60 -cw 2 40 -adjustableColumn 3
                -value .5 -fieldStep .001 -sliderStep .001
                -changeCommand "nas_weightAverage `floatSliderGrp -q -v $nas_weightAverageBiasSlider`"`; 
                //-dragCommand "nas_weightAverage `floatSliderGrp -q -v $nas_weightAverageBiasSlider`"`;
        formLayout -e 
            -af $nas_weightAverageBiasSlider "left" 5
            -af $nas_weightAverageBiasSlider "right" 5
            -af $nas_weightAverageBiasSlider "top" 5
            -af $nas_weightAverageBiasSlider "bottom" 5
        $form;
    window -e -wh 400 66 $window;
    showWindow $window;
}

//-------------------------------------------------------------nas_weightAverageMulti---------------------------------------------------------------------
//weights the average of two closest source verts per vert
global proc nas_weightAverageMulti() {
    global string $nas_weightAverageSourceObj, $nas_weightAverageSourceVerts[];
    string $array[], $sels[], $sourceVerts[], $targetVerts[], $sels[], $sourceObj, $closestVerts[], $verts[];
    float $lowestDistance, $distance;
    
    if (size($nas_weightAverageSourceVerts) < 2) error "Must source at least two verts for nas_weightAverageMulti";
    $sourceVerts = $nas_weightAverageSourceVerts;
    $sels = `ls -sl -flatten`;
    $targetVerts = stringArrayRemove($sourceVerts, $sels);
    
    nas_progress (size($targetVerts)) "start";
    for ($targetVert in $targetVerts) {
        clear $closestVerts;
        $lowestDistance = `nas_distance {$targetVert, $sourceVerts[0]}`;
        $closestVerts[0] = $sourceVerts[0];
        for ($i = 0; $i < size($sourceVerts); $i++) {
            $distance = `nas_distance {$targetVert, $sourceVerts[$i]}`;
            if ($distance < $lowestDistance) {
                $closestVerts[1] = $closestVerts[0];
                $closestVerts[0] = $sourceVerts[$i];
                $lowestDistance = $distance;
            }
        }
        if ($closestVerts[1] == "") {
            $verts = stringArrayRemove({$closestVerts[0]}, $sourceVerts);
            $lowestDistance = `nas_distance {$targetVert, $verts[0]}`;
            $closestVerts[1] = $verts[0];
            for ($i = 0; $i < size($verts); $i++) {
                $distance = `nas_distance {$targetVert, $verts[$i]}`;
                if ($distance < $lowestDistance) {
                    $closestVerts[1] = $verts[$i];
                    $lowestDistance = $distance;
                }
            }
        }
        
        $nas_weightAverageSourceVerts = $closestVerts;
        select -r $targetVert;
        nas_weightAverage -1;
        if (`nas_progress 0 ""`) return;
    }
    $nas_weightAverageSourceVerts = $sourceVerts;
    nas_progress 0 "end";
    print "Finished weighting target verts to source verts.";
}

//-------------------------------------------------------------nas_getEndVerts---------------------------------------------------------------------
global proc string[] nas_getEndVerts() {
    string $edges[], $verts[], $endVerts[], $array[], $dupeVerts[], $compVerts[];
    $edges = `ls -sl -flatten`;
    for ($edge in $edges) {
        select -r $edge;
        ConvertSelectionToVertices;
        $array = `ls -sl -fl`;
        $verts = stringArrayCatenate($verts, $array);
    }
    $array = stringArrayRemoveDuplicates($verts);
    $array = stringArrayRemoveExact($array, $verts);
    $endVerts = stringArrayRemove($array, $verts);
    if (size($endVerts) != 2) error "Please select edges that are connected together.";
    select -r $edges;
    return $endVerts;
}

//-------------------------------------------------------------nas_weightAverageLine---------------------------------------------------------------------
global proc nas_weightAverageLine() {
    global string $nas_weightAverageSourceVerts[];
    string $edges[], $array[], $verts[], $object;
    $edges = `ls -sl -flatten`;
    ConvertSelectionToVertices;
    $verts = `ls -sl -flatten`;
    $array = stringToStringArray($verts[0], ".");
    $object = $array[0];
    
    select -r $edges;
    $nas_weightAverageSourceVerts = `nas_getEndVerts`;
    select -r $verts;
    nas_weightAverage 2;
    setSelectMode components Components;
    selectType -smp 0 -sme 1 -smf 0 -smu 0 -pv 0 -pe 1 -pf 0 -puv 0;
    hilite -r $object;
    select -r $edges;
}

//-------------------------------------------------------------nas_weightAverage---------------------------------------------------------------------
global proc nas_weightAverage(float $bias) {
    global string $nas_weightAverageSourceObj, $nas_weightAverageSourceVerts[];
    string $array[], $joints[], $sourceSkinCluster, $targetSkinCluster, $sourceVerts[], $targetVerts[], $args[], $sels[], $sourceObj, $cmd;
    string $edges[], $verts[], $object;
    int $setting;
    float $values[], $distances[], $totalDistance, $weight, $hyps[], $angle, $dists[], $percents[], $percent, $floatArray[];
    vector $v0, $v1, $sourceVertWS1, $sourceVertWS2, $targetVertWS;
    
    
    $sels = `ls -sl -flatten`;
        $args = $sels;
    if (`gmatch $sels[0] "*.e*"`) {
        $nas_weightAverageSourceVerts = `nas_getEndVerts`;
        ConvertSelectionToVertices;
        $sels = `ls -sl -flatten`;
    } else {
        if (`gmatch $sels[0] "*.f*"`) ConvertSelectionToVertices;
        $sels = `ls -sl -flatten`;
    }

    if (size($nas_weightAverageSourceVerts)) {
        $sourceVerts = $nas_weightAverageSourceVerts;
        $targetVerts = stringArrayRemove($sourceVerts, $sels);
    } else {
        for ($sel in $sels) {
            $array = stringToStringArray($sel, ".");
            if ($array[0] == $nas_weightAverageSourceObj) $sourceVerts[size($sourceVerts)] = $sel;
            else $targetVerts[size($targetVerts)] = $sel;
        }
    }
    if (size($sourceVerts) == 0) error "Could not find any source verts.";
    if (size($targetVerts) == 0) error "Please select target verts before running.";
    if ($bias >= 0 && $bias <= 1 && size($sourceVerts) != 2) error "must select only two source verts for bias to work";
    $targetSkinCluster = `nas_getSkinCluster $targetVerts[0]`;
    $sourceSkinCluster = `nas_getSkinCluster $sourceVerts[0]`;
    setAttr ($sourceSkinCluster + ".normalizeWeights") 1;
    setAttr ($targetSkinCluster + ".normalizeWeights") 1;
    setAttr ($sourceSkinCluster + ".envelope") 0;
    setAttr ($targetSkinCluster + ".envelope") 0;
    if ($bias == 2) nas_progress ((size($targetVerts))*(size($sourceVerts))) "start";
        
    //print ("\n\n\n");
    //print $targetVerts;
    //print ("\n\n\n");
    
    //figure out percentages
    if (size($sourceVerts) == 2) {
        for ($targetVert in $targetVerts) {
            $floatArray = `nas_distanceBetween $targetVert $sourceVerts[0] $sourceVerts[1]`;
            $percents[size($percents)] = $floatArray[0];
        }
    } else if (size($sourceVerts) > 2) {
        for ($targetVert in $targetVerts) {
            for ($i = 0; $i < size($sourceVerts); $i++) {
                $distances[$i] = `nas_distance {$targetVert, $sourceVerts[$i]}`;
                $totalDistance += $distances[$i];
            }
            for ($i = 0; $i < size($distances); $i++) $percents[$i] = 1-($distances[$i]/$totalDistance);
        }
    }
    //weight targetVert with neighbors weights with percentage
    setAttr ($targetSkinCluster + ".normalizeWeights") 0;
    skinPercent -pruneWeights 100 -normalize off $targetSkinCluster $targetVerts;
    
    for ($i=0;$i<size($sourceVerts);$i++) {
        $joints = `skinPercent -q -t $sourceSkinCluster $sourceVerts[$i]`;
        for ($j = 0; $j < size($joints); $j++) $values[$j] = `skinPercent -transform $joints[$j] -q $sourceSkinCluster $sourceVerts[$i]`;
        
        for ($j = 0; $j < size($targetVerts); $j++) {
            if (size($sourceVerts) == 1 ) {
                $cmd = "skinPercent -normalize off";
                for ($k=0;$k<size($joints);$k++) $cmd += (" -tv " + $joints[$k] + " " + $values[$k]); 
                $cmd += (" " + $targetSkinCluster + " " + $targetVerts[$j]);
                eval($cmd);
            } else if (size($sourceVerts) == 2) {
                $cmd = "skinPercent -normalize off";
                if ($bias >= 0 && $bias <= 1) {
                    for ($k=0;$k<size($joints);$k++) {
                        if ($bias <= .5) {
                            if ($i == 0) $percent = $bias*2*$percents[$j];
                            else $percent = 1 - ($bias*2*$percents[$j]);
                        } else {
                            if ($i == 0) $percent = $percents[$j] + ((($bias-.5)*2) * (1-$percents[$j]));
                            else $percent = 1 - ($percents[$j] + ((($bias-.5)*2) * (1-$percents[$j])));
                        }
                        $weight = `skinPercent -normalize off -t $joints[$k] -q -v $targetSkinCluster $targetVerts[$j]`;
                        $cmd += (" -tv " + $joints[$k] + " " + ($weight+($values[$k]*$percent)));
                    }
                } else {
                    for ($k=0;$k<size($joints);$k++) {
                        if ($i == 0) $percent = $percents[$j];
                        else $percent = 1 - $percents[$j];
                        $weight = `skinPercent -normalize off -t $joints[$k] -q -v $targetSkinCluster $targetVerts[$j]`;
                        $cmd += (" -tv " + $joints[$k] + " " + ($weight+($values[$k]*$percent)));
                    }
                }
                $cmd += (" " + $targetSkinCluster + " " + $targetVerts[$j]);
                eval($cmd);
            } else {
                for ($k=0;$k<size($joints);$k++) {
                    $weight = `skinPercent -normalize off -t $joints[$k] -q -v $targetSkinCluster $targetVerts[$j]`;
                    skinPercent -normalize off -tv $joints[$k] ($weight+($values[$k]*$percents[$i])) $targetSkinCluster $targetVerts[$j];
                }
            }
            if ($bias == 2) {
                if (`nas_progress 0 ""`) return;
            }
        }
    }
    skinPercent -normalize on $targetSkinCluster $targetVerts;
    if ($bias == 2) nas_progress 0 "end";
    setAttr ($sourceSkinCluster + ".normalizeWeights") 1;
    setAttr ($targetSkinCluster + ".normalizeWeights") 1;
    setAttr ($sourceSkinCluster + ".envelope") 1;
    setAttr ($targetSkinCluster + ".envelope") 1;
    select -r $args;
}

//-------------------------------------------------------------nas_weightAverageMultiSel---------------------------------------------------------------------
//select source verts followed by target vert
//be careful when selecting because it is based on undos
global proc nas_weightAverageMultiSel() {
    string $array[], $sels[], $sourceObj, $targetObj, $sourceVerts[];
    $sels = `nas_getSels`;
    $sels = `ls -flatten $sels`;
    $array = stringToStringArray($sels[0], ".");
    $sourceObj = $array[0];
    for ($i = 0; $i < size($sels); $i+=3) {
        $nas_weightAverageSourceVerts = {$sels[$i], $sels[$i+1]};
        select -r $sels[$i+2];
        nas_weightAverage -1;
    }
}

//-------------------------------------------------------------nas_weightExact---------------------------------------------------------------------
global proc nas_weightExact() {
    global string $nas_weightAverageSourceObj, $nas_weightAverageSourceVerts[];
    string $array[], $sourceObj, $targetObj, $sels[], $sourceVerts[], $targetVerts[], $closestSource;
    float $lowestDistance, $distance;
    //ConvertSelectionToVertices;
    $sels = `ls -sl -flatten`;
    if (size($nas_weightAverageSourceVerts)) {
        $sourceVerts = $nas_weightAverageSourceVerts;
        $targetVerts = stringArrayRemove($sourceVerts, $sels);
    } else {
        for ($sel in $sels) {
            $array = stringToStringArray($sel, ".");
            if ($array[0] == $nas_weightAverageSourceObj) $sourceVerts[size($sourceVerts)] = $sel;
            else $targetVerts[size($targetVerts)] = $sel;
        }
    }
    
    nas_progress (size($targetVerts)) "start";
    for ($targetVert in $targetVerts) {
        $closestSource = `nas_findClosest $targetVert $sourceVerts`;
        $nas_weightAverageSourceVerts = {$closestSource};
        select -r $targetVert;
        nas_weightAverage -1;
        if (`nas_progress 0 ""`) return;
    }
    $nas_weightAverageSourceVerts = $sourceVerts;
    nas_progress 0 "end";
    print "Target verts weighted exactly to nearest source verts.";
}

//-------------------------------------------------------------nas_getSels---------------------------------------------------------------------
global proc string[] nas_getSels() {
    string $redoCmds[], $components[], $undoCmd, $array[], $tempArray[];
    int $status, $counter;
    $status = 1;
    while ($status) {
        $undoCmd = `undoInfo -q -undoName`;
        $redoCmds[size($redoCmds)] = $undoCmd;
        $array = stringToStringArray($undoCmd, " ");
        if ($array[0] == "select") {
            if ($array[1] == "-r") { $tempArray[size($tempArray)] = $array[2]; $status = 0;
            } else if ($array[1] == "-tgl" || $array[1] == "-add") { $tempArray = stringArrayCatenate($tempArray, `ls $array[2]`);
            } else { $status = 0;
            }
        } else { 
            $counter++;
        }
        if ($counter == 5) $status = 0;
        undo;
    }
    for ($i = size($redoCmds)-1; $i >= 0; $i--) eval $redoCmds[$i];
    for ($i = size($tempArray)-1; $i >= 0; $i--) $components[size($components)] = $tempArray[$i];
    return $components;
}

//-------------------------------------------------------------nas_getDeformerVerts---------------------------------------------------------------------
global proc string[] nas_getDeformerVerts(string $deformer) {
    string $array[], $set, $verts[], $type;
    
    $type = `nodeType $deformer`;
    if ($type == "transform") {
        $array = `listHistory -lv 1 -pdo 1 -f 1 $deformer`;
        $deformer = $array[0];
    }
    $type = `nodeType $deformer`;
    if ($type == "wrap" || $type == "cluster" || $type == "wire" || $type == "ffd" || $type == "nonLinear") {
        $array = `listConnections -type objectSet $deformer`;
        $verts = `sets -q $array[0]`;
        $verts = `ls -flatten $verts`;
                $verts = `nas_checkComponents $verts`;                
    }
    return $verts;
}

//-------------------------------------------------------------nas_findClosest---------------------------------------------------------------------
global proc string nas_findClosest(string $object, string $objs[]) {
    string $array[], $closestObj;
    float $lowestDistance;
    
    $lowestDistance = `nas_distance {$object, $objs[0]}`;
    $closestObj = $objs[0];
    for ($i = 1; $i < size($objs); $i++) {
        if (`nas_distance {$object, $objs[$i]}` < $lowestDistance) {
            $closestObj = $objs[$i];
            $lowestDistance = `nas_distance {$object, $objs[$i]}`;
        }
    }
    return $closestObj;
}

//-------------------------------------------------------------nas_getDeformerSet---------------------------------------------------------------------
global proc string nas_getDeformerSet(string $deformer) {
    string $array[], $set, $verts[], $connections[];
    $connections = `connectionInfo -dfs ($deformer + ".message")`;
    for ($connection in $connections) if (`nodeType $connection` == "objectSet") {
        $array = stringToStringArray($connection, ".");
        $set = $array[0];
        break;
    }
    return $set;
}

//-------------------------------------------------------------nas_pruneDeformerWeights---------------------------------------------------------------------
global proc nas_pruneDeformerWeights(string $deformers[], float $pruneAmount) {
    string $array[], $verts[], $set, $removeVerts[];
    float $floatArray[], $values[];
    
    for ($i = 0; $i < size($deformers); $i++) {
        $array = `nas_getDeformerInfo $deformers[$i]`;
        $deformers[$i] = $array[0];
        $verts = `nas_getDeformerVerts $deformers[$i]`;
        $set = `nas_getDeformerSet $deformers[$i]`;
        $values = `percent -q -v $deformers[$i] $verts`;
        clear $removeVerts;
        for ($i = 0; $i < size($verts); $i++) if ($values[$i] <= $pruneAmount) $removeVerts[size($removeVerts)] = $verts[$i];
        if (size($removeVerts)) sets -rm $set $removeVerts;
    }
    print "\n";
    print "Removed unused verts from deformers";
}

//-------------------------------------------------------------nas_pruneDeformerWeightsFromSels---------------------------------------------------------------------
global proc nas_pruneDeformerWeightsFromSels(float $pruneAmount) {
    string $sels[], $array[], $deformers[];
    
    $sels = `ls -sl`;
    for ($sel in $sels) {
        $array = `listHistory -pdo 1 -f 1 $sel`;
        $deformers = stringArrayCatenate($deformers, {$array[0]});
    }
    nas_pruneDeformerWeights $deformers $pruneAmount;
}

//-------------------------------------------------------------nas_clusters---------------------------------------------------------------------
//creates a locator at the center of the selected object or selected vertices
global proc string[] nas_clusters() {
    string $sels[], $array[], $panels[], $clusters[];
    
    $sels = `ls -sl -flatten`;
    for ($sel in $sels) {
        select -r $sel;
        $array = `newCluster " -envelope 1"`;
        $clusters[size($clusters)] = $array[1];
    }
    select -r $clusters;
    $panels = `nas_getVisibleModelPanels`;
    if (size($panels)) {
            for ($panel in $panels) isolateSelect -addSelected $panel;
        }
    return $clusters;
}

//-------------------------------------------------------------nas_checkComponents---------------------------------------------------------------------
global proc string[] nas_checkComponents(string $verts[]){
        string $geos[], $trials[], $array[], $intersector;

        for ($vert in $verts) {
               $array = stringToStringArray($vert, ".");
                $geos[size($geos)] = $array[0];
        }
        $geos = stringArrayRemoveDuplicates($geos);
        for ($geo in $geos) {
                for ($type in {"vtx", "cv", "pt"}) {
                    clear $array;
                    $array = `ls -fl ($geo + "." + $type + "[:]")`;
                    if (size($array)) $trials = stringArrayCatenate($trials, $array);
                }
        }
        $intersector = `stringArrayIntersector`;
        stringArrayIntersector -e -intersect $verts $intersector;
        stringArrayIntersector -e -intersect $trials $intersector;
        $verts = `stringArrayIntersector -q $intersector`;
        deleteUI $intersector;
        return $verts;
}

//-------------------------------------------------------------nas_wireDeformerSetup---------------------------------------------------------------------
global proc int nas_wireDeformerSetup() {
    string $array[], $sels[], $clusters[], $curve, $wire, $geo, $ctrls[], $name, $num, $groups[], $skinCluster, $joints[], $rotClusters[], $verts[], 
    $wireRotateCtrl, $result, $geos[], $deformerVerts[], $joint1, $joint2, $constraint, $baseWire, $clGroup, $ctrlGroup, $wireGroup, $hists[], $binds[];
    float $floatArray[];
    
    //confirmDialog -message "Please make sure that your curve is named properly.\nBase wire does not need to be named." -button "OK";
    
    $sels = `ls -sl -fl`;
    if (`gmatch $sels[0] "*Deformer*"` == 0) error "Please name your curve and make sure that the word \"Deformer\" comes after the part you are rigging.";
    $array = stringToStringArray($sels[0], ".");
    $curve = $array[0];
    $array = stringToStringArray($curve, "_");
    for ($i = 0; $i < size($array); $i++) {
        if ($array[$i] != "Deformer") {
            if ($i == 0) $name = $array[0];
            else $name += ("_" + $array[$i]);
        } else {
            break;
        }
    }

    //wire
    $hists = `listHistory -pdo 1 -lv 1 -f 1 $curve`;
    if (size($hists) == 0) error "Could not find the name of the wire deformer. Make sure that only cvs are selected and that the deformer exists in the output of the curve transform.";
    for ($hist in $hists) {
        if (`nodeType $hist` == "wire") {
            $wire = $hist;
            print $wire;
            break;
        }
    }
    if ($wire == "") error "no wire deformer detected on selected curve";
    //nas_pruneDeformerWeights {$wire} .001;
    $wire = `rename $wire ($name + "_Wire")`;
    setAttr ($wire + ".rotation") 0;
    
    //baseWire
    $baseWire = `connectionInfo -sfd ($wire + ".baseWire[0]")`;
    $array = stringToStringArray($baseWire, ".");
    $array = `listRelatives -p $array[0]`;
    $baseWire = `rename $array[0] ($name + "_Deformer_01_BaseWire")`;
    
    //controls and regular clusters
    select -r $sels;
    $clusters = `nas_clusters`;
    for ($i = 0; $i < size($clusters); $i++) $clusters[$i] = `rename $clusters[$i] ($name + "_Deformer_" + nas_framePadding("##", ($i+1)) + "_CL")`;
    $ctrls = `nas_controls surfaceDeformerSphere`;
    makeIdentity -apply true -t 1 -s 1 $ctrls;
    $groups = `nas_group 0 Group`;

    //create rotate clusters
    for ($i = 0; $i < size($ctrls); $i++) {
        for ($attr in {".tx", ".ty", ".tz"}) connectAttr ($ctrls[$i] + $attr) ($clusters[$i] + $attr);
        $deformerVerts = `nas_getDeformerVerts $wire`;
        select -r $ctrls[$i];
        $rotClusters[$i] = `nas_deformationToCluster $deformerVerts`;
        $rotClusters[$i] = `rename ($name + "_Deformer_" + nas_framePadding("##", ($i+1)) + "_Rot_CL")`;
        $array = `listHistory -pdo 1 -future 1 $rotClusters[$i]`;
        //nas_pruneDeformerWeights {$array[0]} .001;
        for ($attr in {".rx", ".ry", ".rz", ".sx", ".sy", ".sz"}) connectAttr ($ctrls[$i] + $attr) ($rotClusters[$i] + $attr);
    }

    //setup wire rotation attr
    if (size($ctrls) == 1) $wireRotateCtrl = $ctrls[0];
    else $wireRotateCtrl = $ctrls[size($ctrls)/2];
    addAttr -ln "WireRotation" -at double -dv .5 -min 0 -max 1 $wireRotateCtrl;
    setAttr -e-keyable true ($wireRotateCtrl + ".WireRotation");
    connectAttr ($wireRotateCtrl + ".WireRotation") ($wire + ".rotation");

    //constrain to closest joints
    $deformerVerts = `nas_getDeformerVerts $wire`;
    for ($vert in $deformerVerts) {
        $array = stringToStringArray($vert, ".");
        $geos[size($geos)] = $array[0];
    }
    $geos = stringArrayRemoveDuplicates($geos);

    for ($geo in $geos) if (size(nas_getSkinCluster($geo))) {
        $array = `skinCluster -q -inf (nas_getSkinCluster($geo))`;
        $joints = stringArrayCatenate($joints, $array);
    }
    $joints = stringArrayRemoveDuplicates($joints);

    if (size($joints)) {
        for ($group in $groups) {
            select -r $group; 
            $array[0] = `nas_findClosest $group $joints`;
            $joint1 = $array[0];
            $array[0] = `nas_findClosest $group (stringArrayRemove({$joint1}, $joints))`;
            $joint2 = $array[0];
            select -r $joint1 $joint2 $group;
            nas_constrainBetween "parent" 1;
        }
        for ($sel in $sels) {
            $binds[size($binds)] = `nas_findClosest $sel $joints`;
            $joints = stringArrayRemove({$binds[size($binds)-1]}, $joints);
            $binds[size($binds)] = `nas_findClosest $sel $joints`;
            $joints = stringArrayRemove({$binds[size($binds)-1]}, $joints);
        }
        select -r $binds $curve;
        nas_skinCluster;
    }

    //organize
    $clGroup = `nas_parentGroup (stringArrayCatenate($clusters, $rotClusters)) ($name + "_Deformer_CL_Group")`;
    $ctrlGroup = `nas_parentGroup $groups ($name + "_Deformer_Ctrl_Group")`;
    $wireGroup = `nas_parentGroup {$curve, $baseWire} ($name + "_Deformer_01_Wire_Group")`;
    $deformerGroup = `nas_parentGroup {$clGroup, $wireGroup} ($name + "_Deformer_Group")`;
    
    if (`objExists "COG_Pivot_Null"`) parent $ctrlGroup "COG_Pivot_Null";
    else if (`objExists "COG"`) parent $ctrlGroup "COG";

    select -r $ctrls;
    nas_showAttrs 1 1 1 1 1 1 1 1 1 0;
    print ("Deformers created for " + $name);
    return 1;
}

//-------------------------------------------------------------nas_reorderHistory---------------------------------------------------------------------
//bends above squash
global proc nas_reorderHistory() {
    string $array[], $clusters[], $wires[], $skinClusters[], $geos[], $hists[], $deformers[], $rotateClusters[], $translateClusters[], 
    $ffds[], $blendshapes[], $squashes[], $nonLinears[], $bends[], $sculpts[];
    $geos = `ls -sl -long`;
    for ($geo in $geos) {
        clear $clusters;
        clear $rotateClusters;
        clear $translateClusters;
        clear $wires;
        clear $skinClusters;
        clear $ffds;
        clear $blendshapes;
        clear $squashes;
        clear $hists;
        clear $bends;
        clear $sculpts;
        
        $hists = `listHistory -il 2 -pdo 1 $geo`;
        for ($hist in $hists) {
            if (`nodeType $hist` == "cluster") $clusters[size($clusters)] = $hist;
            else if (`nodeType $hist` == "wire") $wires[size($wires)] = $hist;
            else if (`nodeType $hist` == "skinCluster") $skinClusters[size($skinClusters)] = $hist;
            else if (`nodeType $hist` == "ffd") $ffds[size($ffds)] = $hist;
            else if (`nodeType $hist` == "blendShape") $blendshapes[size($blendshapes)] = $hist;
            else if (`nodeType $hist` == "nonLinear") $nonLinears[size($nonLinears)] = $hist;
            else if (`nodeType $hist` == "sculpt") $sculpts[size($sculpts)] = $hist;
        }
        for ($cluster in $clusters) {
            if (`gmatch $cluster "*Rot_CLCluster"`) $rotateClusters[size($rotateClusters)] = $cluster;
            else $translateClusters[size($translateClusters)] = $cluster;
        }
        
        for ($nonLinear in $nonLinears) {
            if (`gmatch $nonLinear "*bend*"` || `gmatch $nonLinear "*Bend*"`) $bends[size($bends)] = $nonLinear;
            if (`gmatch $nonLinear "*squash*"` || `gmatch $nonLinear "*Squash*"`) $squashes[size($squashes)] = $nonLinear;
        }
        
        $translateClusters = `sort $translateClusters`;
        $rotateClusters = `sort $rotateClusters`;
        $wires = `sort $wires`;
        $skinClusters = `sort $skinClusters`;
        $blendshapes = `sort $blendshapes`;
        $squashes = `sort $squashes`;
        $bends = `sort $bends`;
    
        $deformers = $blendshapes;
        $deformers = stringArrayCatenate($deformers, $translateClusters);
        $deformers = stringArrayCatenate($deformers, $rotateClusters);
        $deformers = stringArrayCatenate($deformers, $skinClusters);
        $deformers = stringArrayCatenate($deformers, $ffds);
        $deformers = stringArrayCatenate($deformers, $squashes);        
        $deformers = stringArrayCatenate($deformers, $wires);
        $deformers = stringArrayCatenate($deformers, $bends);
        $deformers = stringArrayCatenate($deformers, $sculpts);
        $deformers = stringArrayRemoveDuplicates($deformers);

        for ($i = size($deformers)-1; $i > 0; $i--) catchQuiet(`reorderDeformers $deformers[$i] $deformers[$i-1] $geo`);
        clear $deformers;
    }
    //select -deselect $geos;
    select -r $geos;
}

//-------------------------------------------------------------nas_constrainBetween---------------------------------------------------------------------
//select two objects that you would like to constrain the last selected object to
//this script will calculate how close the last object is to the first two objects selected in a straight line formed by the first two objects
//those percentages get input into the constraint weights
global proc nas_constrainBetween(string $type, int $maintainOffset) {
    string $array[], $constraint, $sels[];
    float $floatArray[], $percent;

    $sels = `ls -sl -long`;

    $floatArray = `nas_distanceBetween $sels[2] $sels[0] $sels[1]`;
    $percent = $floatArray[0];

    if ($maintainOffset) $array = `eval(($type + "Constraint -mo " + $sels[0] + " " + $sels[1] + " " + $sels[2]))`;
    else $array = `eval(($type + "Constraint " + $sels[0] + " " + $sels[1] + " " + $sels[2]))`;
    $constraint = $array[0];

    $array = stringToStringArray($sels[0], "|");
    $sels[0] = $array[size($array)-1];
    $array = stringToStringArray($sels[1], "|");
    $sels[1] = $array[size($array)-1];

    setAttr ($constraint + "." + $sels[0] + "W0") $percent;
    setAttr ($constraint + "." + $sels[1] + "W1") (1-$percent);
}

//-------------------------------------------------------------nas_copySkinWeights---------------------------------------------------------------------
global proc nas_copySkinWeights(string $verts[]) {
    global string $nasSkinSourceJoints[];
    global float $nasSkinSourceWeights[];
    
    clear $nasSkinSourceJoints;
    $nasSkinSourceWeights = {};
    
    string $skin, $joints[], $sourceVerts[], $targetVerts[], $sels[], $geo;
    float $weights[], $floatArray[];
    
    $geo = "";
    nas_progress (size($verts)) "start";
    for ($i = 0; $i < size($verts); $i++) {
        $skin = `nas_getSkinCluster $verts[$i]`;
        
        $joints = `skinPercent -ignoreBelow .000000001 -q -transform $skin $verts[$i]`;
        $weights = `skinPercent -ignoreBelow .000000001 -q -value $skin $verts[$i]`;
        
        //store joints and weights
        $nasSkinSourceJoints[size($nasSkinSourceJoints)] = $verts[$i];
        for ($joint in $joints) $nasSkinSourceJoints[size($nasSkinSourceJoints)] = $joint;
        
        $nasSkinSourceWeights[size($nasSkinSourceWeights)] = 999999999;
        for ($weight in $weights) $nasSkinSourceWeights[size($nasSkinSourceWeights)] = $weight;
        
        if (`nas_progress 0 ("Storing weight information for " + $verts[$i])`) return;
    }
    
    nas_progress 0 "end";
    print "\nWeights stored for selected verts.";
}

//-------------------------------------------------------------nas_pasteSkinWeights---------------------------------------------------------------------
global proc nas_pasteSkinWeights(string $verts[]) {
    global string $nasSkinSourceJoints[];
    global float $nasSkinSourceWeights[];
    
    string $cmd, $vert, $joints[], $geo, $skin, $clearCmd, $geos[], $array[], $sourceVerts[];
    int $store, $counter;
    
    //find which verts and geos match target verts and geos
    for ($vert in $nasSkinSourceJoints) if (`gmatch $vert "*.vtx*"`) $sourceVerts[size($sourceVerts)] = $vert;        //find verts in storage
    for ($i = 0; $i < size($verts); $i++) {                                        //link source and target geo with ":"
           $array = stringToStringArray($sourceVerts[$i], ".");
           $geos[$i] = ($array[0] + ":");
           $array = stringToStringArray($verts[$i], ".");
           $geos[$i] = $geos[$i] + $array[0];
    }
    $geos = stringArrayRemoveDuplicates($geos);

    //bind joints to target geos if joints are not part of skin
    for ($geo in $geos) {
        $array = stringToStringArray($geo, ":");
        $sourceGeo = $array[0];
        $targetGeo = $array[1];
        for ($i = 0; $i < size($nasSkinSourceJoints); $i++) {
            if (`gmatch $nasSkinSourceJoints[$i] "*.vtx*"`) {
                $array = stringToStringArray($nasSkinSourceJoints[$i], ".");
                if ($array[0] == $sourceGeo) $store = 1;
                else $store = 0;
            } else {
                if ($store) $joints[size($joints)] = $nasSkinSourceJoints[$i];
            }
        }
        $joints = stringArrayRemoveDuplicates($joints);
        select -r $joints $targetGeo;
        //print "\n";
        //print `ls -sl`;
        nas_skinCluster;
        for ($joint in $joints) setAttr ($joint + ".liw") 0;
        clear $joints;
    }

    //build each skin command for each vert and execute
    $cmd = "skinPercent";
      nas_progress (size($nasSkinSourceJoints)) "start";
    for ($i = 1; $i < size($nasSkinSourceJoints); $i++) {
        if (`gmatch $nasSkinSourceJoints[$i] "*.vtx*"` || $i == (size($nasSkinSourceJoints)-1)) {
            $skin = `nas_getSkinCluster $verts[$counter]`;
            setAttr ($skin + ".normalizeWeights") 0;
            
            //zero weights on current target vert
            $joints = `skinPercent -q -transform $skin $verts[$counter]`;
            $clearCmd = "skinPercent";
            for ($joint in $joints) $clearCmd += " -tv " + $joint + " 0";
            eval ($clearCmd + " " + $skin + " " + $verts[$counter]);
            
            //run skin command on target vert
            if ($i == (size($nasSkinSourceJoints)-1)) $cmd += (" -tv " + $nasSkinSourceJoints[$i] + " " + $nasSkinSourceWeights[$i]);
            //print ("\n" + $cmd + " " + $skin + " " + $verts[$counter]);
            eval ($cmd + " " + $skin + " " + $verts[$counter]);
            setAttr ($skin + ".normalizeWeights") 1;

            //prep for next vert
            $cmd = "skinPercent";
            $counter++;
        } else {
            $cmd += (" -tv " + $nasSkinSourceJoints[$i] + " " + $nasSkinSourceWeights[$i]);
        }
        if (`nas_progress 0 ("Setting weight information for " + $verts[$counter])`) return;
    }
      nas_progress 0 "end";
      print "\nWeights pasted for selected verts.";
      select -r $verts;
}

//-------------------------------------------------------------nas_mirrorXform---------------------------------------------------------------------
global proc float[] nas_mirrorXform(string $axis, float $offset, float $sourceWp[]) {
    float $axisFloat[], $wp[];
    vector $axisVec;
    
    if (size($sourceWp) != 3) error "Input does not contain exactly 3 elements";
    $axisVec = `nas_axisToVector $axis`;
    $axisFloat = {($axisVec.x), ($axisVec.y), ($axisVec.z)};
    
    for ($i = 0; $i < 3; $i++) {
        if ($axisFloat[$i] == 0) $wp[$i] = $sourceWp[$i] + $offset;
        else $wp[$i] = $sourceWp[$i] * -1 + $offset;
    }
    return $wp;
}

//-------------------------------------------------------------nas_getMirrorVerts---------------------------------------------------------------------
global proc string[] nas_getMirrorVerts(string $axis, string $sourceVerts[], float $buffer) {
    string $targetVerts[], $mirrorVerts[], $verts[], $array[], $loc, $geo;
    float $minWp[], $maxWp[], $sourceWp[], $targetWp[], $axisFloat[], $floatArray[], $wp[], $dists[], $variance;
    int $flag;
    
    //figure out if the target vert needs to be found on another geo or on the same geo 
    $array = stringToStringArray($sourceVerts[0], ".");
    $geo = $array[0];
    $array = stringToStringArray($array[0], "_");
    if ($array[0] == "LT") {
        $array[0] = "RT";
        $targetVerts = `ls -fl (stringArrayToString($array, "_") + ".vtx[*]")`;
    } else if ($array[0] == "RT") {
        $array[0] = "LT";
        $targetVerts = `ls -fl (stringArrayToString($array, "_") + ".vtx[*]")`;
    } else {
        $array = stringToStringArray($sourceVerts[0], ".");
        $targetVerts = `ls -fl ($array[0] + ".vtx[*]")`;
    }
    
    //store all source and target worldspace positions
    for ($i = 0; $i < size($sourceVerts); $i++) {
        $wp = `xform -ws -q -translation $sourceVerts[$i]`;
        $sourceWp[$i*3+0] = $wp[0];
        $sourceWp[$i*3+1] = $wp[1];
        $sourceWp[$i*3+2] = $wp[2];
    }
    for ($i = 0; $i < size($targetVerts); $i++) {
        $wp = `xform -ws -q -translation $targetVerts[$i]`;
        $targetWp[$i*3+0] = $wp[0];
        $targetWp[$i*3+1] = $wp[1];
        $targetWp[$i*3+2] = $wp[2];
    }
        
    //find the mirror vert using two different methods
    nas_progress (size($sourceVerts)) "start";
    $array = `spaceLocator -p 0 0 0`;
    $loc = $array[0];
    for ($i = 0; $i < size($sourceVerts); $i++) {
        //store the min, max, and value of current source vert based off of the buffer
        $minWp = `nas_mirrorXform $axis (-1*$buffer) {$sourceWp[$i*3+0], $sourceWp[$i*3+1], $sourceWp[$i*3+2]}`;
        $maxWp = `nas_mirrorXform $axis $buffer {$sourceWp[$i*3+0], $sourceWp[$i*3+1], $sourceWp[$i*3+2]}`;
        $wp = `nas_mirrorXform $axis 0 {$sourceWp[$i*3+0], $sourceWp[$i*3+1], $sourceWp[$i*3+2]}`;
        
        //1st method: store mirror verts that are in the bounding box of mirrored source vert
        for ($j = 0; $j < size($targetVerts); $j++) {
            if ($targetVerts[$j] != $geo) {
                if ($minWp[0] < $targetWp[$j*3] && $maxWp[0] > $targetWp[$j*3] && $minWp[1] < $targetWp[$j*3+1] && $maxWp[1] > $targetWp[$j*3+1] && $minWp[2] < $targetWp[$j*3+2] && $maxWp[2] > $targetWp[$j*3+2]) {
                    $mirrorVerts[$i] = $targetVerts[$j];
                    $targetVerts[$j] = $geo;
                    break;
                }
            }
        }
        /*
        //2nd method: if 1st method fails, position a locator at target world position and find the closest vert
        if ($mirrorVerts[$i] == "") {
            move -ws $wp[0] $wp[1] $wp[2] $loc;
            $mirrorVerts[$i] = `nas_findClosest $loc $targetVerts`;
            if (`nas_distance {$sourceVerts[$i], $mirrorVerts[$i]}` > $variance) $variance = `nas_distance {$sourceVerts[$i], $mirrorVerts[$i]}`;
            //for ($j = 0; $j < size($targetVerts); $j++) if ($targetVerts[$j] == $closestVert) $targetVerts[$j] = $geo;
        }
        */
        if (`nas_progress 0 ("Finding mirror vert for " + $sourceVerts[$i])`) return {};
    }
    delete $loc;
    nas_progress 0 "end";
    select -r $mirrorVerts;
    if ($variance) warning ("one or more mirror verts were estimated; try increasing buffer to a number greater than " + $variance);
    return $mirrorVerts;
}

//-------------------------------------------------------------nas_mirrorSkinWeights---------------------------------------------------------------------
//nas_mirrorSkinWeights "LT" "RT";
global proc nas_mirrorSkinWeights(string $search, string $replace) {
    global string $nasSkinSourceJoints[];
    string $array[], $geos[], $sourceVerts[], $targetVerts[], $skinCluster, $geoVerts[], $searches[], $replaces[], $mirrorVerts[], $verts[];
    float $wp[];
    int $counter;

    clear $geos;
    clear $geoVerts;
    clear $verts;

    $searches = stringToStringArray($search, ", ");
    $replaces = stringToStringArray($replace, ", ");

    $sels = sort(`ls -sl -fl`);
    if (size($sels) == 0) error "Please make a selection before using this tool.";
    for ($sel in $sels) {
        if (`nodeType $sel` == "transform") {
            select -r $sel;
            ConvertSelectionToVertices;
            $verts = `ls -sl -fl`;
            for ($vert in $verts) {
                $wp = `xform -ws -q -translation $vert`;
                if ($wp[0] > 0) $sourceVerts[size($sourceVerts)] = $vert;
            }
        } else if (`nodeType $sel` == "mesh") {
            $sourceVerts[size($sourceVerts)] = $sel;
        }
    }
    
    for ($vert in $sourceVerts) {
        $array = stringToStringArray($vert, ".");
        $geos[size($geos)] = $array[0];
    }
    $geos = stringArrayRemoveDuplicates($geos);
    
    for ($geo in $geos) {
        clear $geoVerts;
        $skinCluster = `nas_getSkinCluster $geo`;
        setAttr ($skinCluster + ".envelope") 0;
        for ($i = 0; $i < size($sourceVerts); $i++) {
            $array = stringToStringArray($sourceVerts[$i], ".");
            if ($array[0] == $geo) $geoVerts[size($geoVerts)] = $sourceVerts[$i];
        }
        stringArrayRemove($geoVerts, $sourceVerts);
        nas_copySkinWeights $geoVerts;
        for ($i = 0; $i < size($nasSkinSourceJoints); $i++) {
            if (!`gmatch $nasSkinSourceJoints[$i] "*.vtx*"`) {
                for ($j = 0; $j < size($searches); $j++) {
                    $nasSkinSourceJoints[$i] = `substitute $searches[$j] $nasSkinSourceJoints[$i] $replaces[$j]`;
                }
            }
        }
        $targetVerts = `nas_getMirrorVerts x $geoVerts .001`;
        $array = stringToStringArray($targetVerts[0], ".");
        nas_pasteSkinWeights $targetVerts;
        setAttr ($skinCluster + ".envelope") 1;
        $mirrorVerts = stringArrayCatenate($mirrorVerts, $targetVerts);
        $counter++;
    }
    select -r $geos;
}

//-------------------------------------------------------------nas_getDeformerInfo---------------------------------------------------------------------
global proc string[] nas_getDeformerInfo(string $obj) {
    string $array[], $handle, $type, $deformer;
    
    $objType = `nodeType $obj`;
    if ($objType == "wrap" || $objType == "cluster" || $objType == "wire" || $objType == "ffd" || $objType == "nonLinear") {
        $deformer = $obj;
        if (`objExists ($deformer + ".matrix")`) $array[0] = `connectionInfo -sfd ($deformer + ".matrix")`;
        else $array[0] = `connectionInfo -sfd ($deformer + ".deformedWire[0]")`;
        $array = stringToStringArray($array[0], ".");
        $handle = $array[0];
    } else if ($objType == "transform") {
        $handle = $obj;
        $array = `listHistory -pdo 1 -f 1 $obj`;
        $type = `nodeType $array[0]`;
        if ($type == "wrap" || $type == "cluster" || $type == "wire" || $type == "ffd" || $type == "nonLinear") $deformer = $array[0];            
    } else {
        //error "Please make sure that object specified is either a deformer handle or the deformer itself.";
    }
    return {$deformer, $handle};
}

//-------------------------------------------------------------nas_copyDeformerWeights---------------------------------------------------------------------
global proc string[] nas_copyDeformerWeights(string $deformer) {
    global string $nasDeformerSourceVerts[];
    global float $nasDeformerSourceWeights[];
    
    clear $nasDeformerSourceVerts;
    $nasDeformerSourceWeights = {};
    
    $nasDeformerSourceVerts = `nas_getDeformerVerts $deformer`;
    $nasDeformerSourceWeights = `percent -q -v $deformer $nasDeformerSourceVerts`;
    print "\nDeformer weights stored for selected verts.";
    return $nasDeformerSourceVerts;
}

//-------------------------------------------------------------nas_multiplyDeformerWeights---------------------------------------------------------------------
global proc nas_multiplyDeformerWeights(float $multiple) {
    string $sels[], $deformers[], $array[], $verts[];
    float $weights[];
    int $numVerts;
    
    $sels = `ls -sl`;
    nas_progress (size($sels)) "start";    
    for ($i = 0; $i < size($sels); $i++) {
        $array = `nas_getDeformerInfo $sels[$i]`;
        $deformers[$i] = $array[0];
        $verts = `nas_getDeformerVerts $deformers[$i]`;
        percent -v $multiple -mp $deformers[$i] $verts;
        if (`nas_progress 0 ("Multiplying weight for " + $deformers[$i] + ".")`) return;
    }
    nas_progress 0 "end";
    print ("Multiplied cluster weights by " + $multiple);
}

//-------------------------------------------------------------nas_addMembership---------------------------------------------------------------------
global proc nas_addMembership(string $verts[], string $deformer) {
    string $handle, $array[], $set;
    
    $array = `nas_getDeformerInfo $deformer`;
    $deformer = $array[0];
    $handle = $array[1];
    
    $set = `nas_getDeformerSet $deformer`;
    $array = `sets -q $set`;
    $verts = stringArrayRemove(`ls -fl $array`, $verts);
    if (size($verts)) sets -e -add $set $verts;
    for ($vert in $verts) {
        percent -v 0 $deformer $vert;
    }
}

//-------------------------------------------------------------nas_pasteDeformerWeights---------------------------------------------------------------------
global proc string nas_pasteDeformerWeights(string $deformer, string $verts[]) {
    global float $nasDeformerSourceWeights[];

    string $array[], $handle, $members[], $set;
    
    $set = `nas_getDeformerSet $deformer`;
    $array = `sets -q $set`;
    $members = stringArrayRemove(`ls -fl $array`, $verts);
    if (size($members)) sets -e -add $set $members;        
    
    nas_progress (size($verts)) "start";
    for ($i = 0; $i < size($verts); $i++) {
        percent -v $nasDeformerSourceWeights[$i] $deformer $verts[$i];
        if (`nas_progress 0 ("Setting " + $deformer + " weights on " + $verts[$i])`) return "";
    }
    nas_progress 0 "end";
    return $handle;
}

//-------------------------------------------------------------nas_mirrorDeformerWeights---------------------------------------------------------------------
global proc string[] nas_mirrorDeformerWeights(string $axis, int $create) {
    string $sels[], $array[], $sourceHandles[], $sourceDeformers[], $targetHandles[], $targetDeformers[], $sourceVerts[], $targetVerts[], $allMirrorVerts[], 
    $allVerts[], $geos[], $geoVerts[], $mirrorVerts[], $geo;
    float $wp[];
    
    clear $allVerts;
    clear $geoVerts;
    clear $allMirrorVerts;
    
    $sels = `ls -sl`;
    for ($i = 0; $i < size($sels); $i++) {
        $array = `nas_getDeformerInfo $sels[$i]`; 
        $sourceDeformers[$i] = $array[0];
        $sourceHandles[$i] = $array[1];
    }
    
    nas_pruneDeformerWeights $sourceDeformers .0000000001;
    for ($i = 0; $i < size($sourceDeformers); $i++) {
        $verts = `nas_getDeformerVerts $sourceDeformers[$i]`;
        for ($vert in $verts) $allVerts[size($allVerts)] = $vert;
    }
    $allVerts = stringArrayRemoveDuplicates($allVerts);
    $allVerts = sort($allVerts);

    //store geo verts
    nas_progress (size($allVerts)+size($sourceDeformers)) "startOverride";
    for ($i = 0; $i < size($allVerts); $i++) {
        $array = stringToStringArray($allVerts[$i], ".");
        if ($i == 0 || $array[0] != $geo || $i == (size($allVerts)-1)) {
            if ($i > 0) {
                if ($i == (size($allVerts)-1)) $geoVerts[size($geoVerts)] = $allVerts[$i];
                $mirrorVerts = `nas_getMirrorVerts $axis $geoVerts .001`;
                for ($mirrorVert in $mirrorVerts) $allMirrorVerts[size($allMirrorVerts)] = $mirrorVert;
                clear $geoVerts;
            }
            $geo = $array[0];
            $geoVerts[size($geoVerts)] = $allVerts[$i];
        } else {
            $geoVerts[size($geoVerts)] = $allVerts[$i];
        }
        if (`nas_progress 1 ""`) return {};
    }
    
    //
    if ($create) {
        for ($i = 0; $i < size($sourceDeformers); $i++) {
            $wp = nas_mirrorXform($axis, 0, `xform -ws -q -rp $sourceHandles[$i]`);
            $sourceVerts = `nas_getDeformerVerts $sourceDeformers[$i]`;
            clear $targetVerts;
            for ($j = 0; $j < size($sourceVerts); $j++) {
                for ($k = 0; $k < size($allVerts); $k++) {
                    if ($sourceVerts[$j] == $allVerts[$k]) {
                        $targetVerts[$j] = $allMirrorVerts[$k];
                        break;
                    }
                }
            }
            if (`nodeType $sourceDeformers[$i]` == "cluster") $array = `cluster -foc -rel $targetVerts`;
            $array = `nas_getDeformerInfo $array[0]`;
            $targetHandles[$i] = `rename $array[1] (substitute("LT", $sourceHandles[$i], "RT"))`;
            $array = `nas_getDeformerInfo $targetHandles[$i]`;
            $targetDeformers[$i] = $array[0];

            xform -ws -rp $wp[0] $wp[1] $wp[2] $targetHandles[$i];
            for ($shape in `listRelatives -fullPath -s $targetHandles[$i]`) if (`objExists ($shape + ".origin")`) setAttr ($shape + ".origin") $wp[0] $wp[1] $wp[2];
            
            nas_copyDeformerWeights $sourceDeformers[$i];
            nas_pasteDeformerWeights $targetDeformers[$i] $targetVerts;
            if (`nas_progress 1 ""`) return {};
        }
    } else {
        if (size($sels) > 2) error "Please select one deformer handle to mirror to same deformer or two deformer handles if you wish to apply mirror weights to second handle";
        if (size($sels) == 1) {
            
        } else if (size($sels) == 2) {
        }
    }
    nas_progress 0 "endOverride";
    nas_pruneDeformerWeights $targetDeformers .0000000001;
    select -r $targetHandles;
    return $targetDeformers;
}

//-------------------------------------------------------------nas_connectEmoticons---------------------------------------------------------------------
global proc nas_connectEmoticonVisibility(string $attr) {
    string $sels[], $condition, $array[];
    
    $sels = `ls -sl`;
    
    for ($i = 1; $i < size($sels); $i++) {
        $array = stringToStringArray($sels[$i], "_");
        $array[size($array)-1] = "Condition";
        $condition = `createNode -n (stringArrayToString($array, "_")) condition`;
        connectAttr ($sels[0] + "." + $attr) ($condition + ".firstTerm");
        setAttr ($condition + ".secondTerm") ($i);
        setAttr ($condition + ".colorIfTrueR") 1;
        setAttr ($condition + ".colorIfFalseR") 0;
        connectAttr ($condition + ".outColorR") ($sels[$i] + ".v");
    }
}

//-------------------------------------------------------------nas_blackBox---------------------------------------------------------------------
global proc nas_blackBox() {
    string $asset, $array[], $container, $world;
    
    //get asset name
    $asset = `nas_charNameFromFile`;
    if (`promptDialog -b "OK" -b "Cancel" -tx $asset -m "Asset Name:" -ma left -title "Black Box" -db "OK"` == "OK") $asset = `promptDialog -q -tx`;
    $world = ("World_" + $asset);
    $container = ("BB_" + $asset);
    if (!`objExists $world`) error ("Could not find " + $world);
    
    //create container and publish
    $container = `container -name $container -includeNetwork -includeShaders -includeHierarchyBelow -includeTransform -force -addNode $world`;
    container -e -pac $world "World_Publish" $container;
    for ($item in `nas_selectByType "control"`) container -e -pac $item "Ctrl_Publish" $container;
    for ($item in `nas_selectByType "bindjoint"`) container -e -pac $item "Jnt_Publish" $container;
    for ($item in `nas_selectByType "geo"`) container -e -pac $item "Geo_Publish" $container;
    setAttr -lock true ($container + ".blackBox") 1;
    
    //set layers to correct settings
    for ($item in {($asset + "_Mesh"), "EyesTongueTeeth_Mesh", "Light_Rig", "Controller_Vis"}) {
        if (`objExists $item`) {
            setAttr ($item + ".v") 1;
            setAttr ($item + ".displayType") 2;
        }
    }
    for ($item in {"Light_Rig", "Controller_Vis"}) if (`objExists $item`) setAttr ($item + ".displayType") 0;
    
    select -r $container;
    print ("Black Box created for " + $asset + ".");
}

//-------------------------------------------------------------nas_selectByType---------------------------------------------------------------------
global proc string[] nas_selectByType(string $type) {
    string $nodes[];
    
    if ($type == "bindjoint") {
        $nodes = `ls -long -type joint "*_Bind_*"`;
    } else if ($type == "control") {
        $nodes = `ls -long -type transform "*_Ctrl"`;
        $nodes = stringArrayCatenate($nodes, `ls -long "COG"`);
        $nodes = stringArrayCatenate($nodes, `ls -long "Transform"`);
        $nodes = stringArrayCatenate($nodes, `ls -long "ControllerGroupVisibility"`);
        $nodes = stringArrayCatenate($nodes, `ls -long "BrowLTShapes"`);
        $nodes = stringArrayCatenate($nodes, `ls -long "BrowRTShapes"`);
        $nodes = stringArrayCatenate($nodes, `ls -long "LeftEyelidShapes"`);
        $nodes = stringArrayCatenate($nodes, `ls -long "RightEyelidShapes"`);
        $nodes = stringArrayCatenate($nodes, `ls -long "PhonemeShapes"`);
        $nodes = stringArrayCatenate($nodes, `ls -long "MouthShapes"`);
    } else if ($type == "geo" || $type == "hires" || $type == "smoothproxy" || $type == "proxy") {
        if ($type == "geo") {
            if (`objExists "Geometry"`) {
                $nodes = stringArrayCatenate($nodes, `listRelatives -fullPath -ad -type mesh "Geometry"`);
            } else {
                $nodes = `ls -long -type mesh`;
                warning "Could not find \"Geometry\" group. Listing all geos in scene.";
            }
        } else if ($type == "hires") {
            for ($groupName in {"Hires_Geo_Group", "Hires"}) if (`objExists $groupName`) $nodes = stringArrayCatenate($nodes, `listRelatives -fullPath -ad -type mesh $groupName`);
        } else if ($type == "smoothproxy") {
            for ($groupName in {"SmoothProxy_Geo_Group", "SmoothProxy"}) if (`objExists $groupName`) $nodes = stringArrayCatenate($nodes, `listRelatives -fullPath -ad -type mesh $groupName`);
        } else if ($type == "proxy") {
            for ($groupName in {"Proxy_Geo_Group", "Proxy"}) if (`objExists $groupName`) $nodes = stringArrayCatenate($nodes, `listRelatives -fullPath -ad -type mesh $groupName`);
        }
        $nodes = `listRelatives -fullPath -p $nodes`;
        $nodes = stringArrayRemoveDuplicates($nodes);
    } else if ($type == "cluster") {
        $nodes = `ls -long -type clusterHandle`;
        $nodes = `listRelatives -fullPath -p $nodes`;
    }
    select -r $nodes;
    return $nodes;
}

//-------------------------------------------------------------nas_selectByName---------------------------------------------------------------------
global proc string[] nas_selectByName(string $search) {
    string $objs[], $parents[], $array[], $parts[], $worlds[], $cmd, $worldName, $world, $childs[], $results[];
    
    $objs = `ls -sl -long`;
    if (size($objs) > 0) {
        for ($i = 0; $i < size($objs); $i++) {
            $parts = stringToStringArray($objs[$i], "|");
            for ($j = (size($parts)-1); $j >= 0; $j--) {
                $worldName = "World_*";
                for ($k = 0; $k < 100; $k++) {
                    if (`gmatch $parts[$j] $worldName`) {
                        for ($l = 0; $l <= $j; $l++) $world = ("|" + $parts[$l]);
                        $worlds[size($worlds)] = $world;
                    }
                    $worldName = ("*:" + $worldName);
                }
            }
        }
        $worlds = stringArrayRemoveDuplicates($worlds);
    } else {
        $objs = `ls -dag -long`;
        for ($obj in $objs) {
            $array = stringToStringArray($obj, "|");
            if (size($array) == 1) {
                $worlds[size($worlds)] = $obj;
            }
        }
    }
    
    for ($i = 0; $i < size($worlds); $i++) {
        $array = `listRelatives -type transform -type joint -fullPath -ad $worlds[$i]`;
        $childs[size($childs)] = $worlds[$i];
        for ($item in $array) $childs[size($childs)] = $item;
    }
    nas_progress (size($childs)) "start";
    for ($i = 0; $i < size($childs); $i++) {
        $parts = stringToStringArray($childs[$i], "|");
        $searchName = $search;
        for ($j = 0; $j < 100; $j++) {
            if (`gmatch $parts[size($parts)-1] $searchName`) {
                $results[size($results)] = $childs[$i];
            }
            $searchName = ("*:" + $searchName);
        }    
        if (`nas_progress 0 "Searching..."`) return{};
    }
    nas_progress 0 "end";
    
    select -r $results;
    return $results;
}

global proc string[] nas_selectByNameUI() {
    string $result, $results[];
    
    $result = `promptDialog -title "nas_selectByName" -ma "center" -message "Please enter a search string:" -text "*Transform" -button "Search" -button "Cancel" -defaultButton "Search" -cancelButton "Cancel" -dismissString "Cancel"`;    
    if ($result == "Search") {
        $results = nas_selectByName(`promptDialog -query -text`);
    }
    return $results;
}

//-------------------------------------------------------------nas_addAttr---------------------------------------------------------------------
global proc nas_addAttr(string $type, float $min, float $max, string $enumString, string $attrs[]) {
    string $sels[] = `ls -sl`;
    for ($attr in $attrs) {
        for ($sel in $sels) {
            if (!`objExists ($sel + "" + $attr)`) {
                if ($type == "float") addAttr -ln $attr -at double $sel;
                else if ($type == "offon") addAttr -ln $attr -at "enum" -en "Off:On" $sel;
                else if ($type == "enum") addAttr -ln $attr -at "enum" -en $enumString $sel;
                else if ($type == "int") addAttr -ln $attr -at long $sel;
                else if ($type == "boolean") addAttr -ln $attr -at bool $sel;
                if ($min || $max) addAttr -e -min $min -max $max ($sel + "." + $attr);
                setAttr -e -keyable true ($sel + "." + $attr);
            }
        }
    }
}

//-------------------------------------------------------------nas_orientToSurface---------------------------------------------------------------------
global proc nas_orientToSurface(int $accuracy) {    
    string $offsets[], $aimLoc, $upLoc, $loc, $array[], $points[];
    float $u, $v, $dist, $lowestDist, $minU, $minV, $maxU, $maxV;
    
    $offsets = `ls -sl`;
    
    nas_progress (size($offsets)) "start";
    for ($i = 0; $i < size($offsets); $i++) {
        $array = `spaceLocator -p 0 0 0`;
        $loc = $array[0];
        $points[0] = `pointOnSurface -ch 1 nurbsPlane1`;
        connectAttr ($points[0] + ".positionX") ($loc + ".tx");
        connectAttr ($points[0] + ".positionY") ($loc + ".ty");
        connectAttr ($points[0] + ".positionZ") ($loc + ".tz");
        setAttr ($points[0] + ".turnOnPercentage") 1;
    
        //change u and v parameters until to find u and v values when locator is closest to offset group
        $lowestDist = 1000000000.0;
        $minU = 0.0;
        $minV = 0.0;
        $maxU = 1.0;
        $maxV = 1.0;
        for ($d = 0; $d < $accuracy; $d++) {
            for ($j = 0; $j < 10; $j++) {
                setAttr ($points[0] + ".parameterU") ($minU + (($maxU-$minU)/($j+1.0)));
                    for ($k = 0; $k < 10; $k++) {
                    setAttr ($points[0] + ".parameterV") ($minV + (($maxV-$minV)/($k+1.0)));
                    $dist = `nas_distance{$offsets[$i], $loc}`;
                    if ($dist < $lowestDist) {
                        $lowestDist = $dist;
                        $u = ($minU + (($maxU-$minU)/($j+1.0)));
                        $v = ($minV + (($maxV-$minV)/($k+1.0)));
                    }
                }
            }
            $minU = $u - (($maxU-$minU)/10.0);
            $maxU = $u + (($maxU-$minU)/10.0);
            $minV = $v - (($maxV-$minV)/10.0);
            $maxV = $v + (($maxV-$minV)/10.0);
        }
        setAttr ($points[0] + ".parameterU") $u;
        setAttr ($points[0] + ".parameterV") $v;
    
        //create and connect the aim locator
        $array = `spaceLocator -p 0 0 0`;
        $aimLoc = $array[0];
        $points[1] = `pointOnSurface -ch 1 nurbsPlane1`;
        connectAttr ($points[1] + ".positionX") ($aimLoc + ".tx");
        connectAttr ($points[1] + ".positionY") ($aimLoc + ".ty");
        connectAttr ($points[1] + ".positionZ") ($aimLoc + ".tz");
        setAttr ($points[1] + ".turnOnPercentage") 1;
        setAttr ($points[1] + ".parameterU") ($u+.000000001);
        setAttr ($points[1] + ".parameterV") $v;
    
        //create and connect the second axis locator
        $array = `spaceLocator -p 0 0 0`;
        $upLoc = $array[0];
        $points[2] = `pointOnSurface -ch 1 nurbsPlane1`;
        connectAttr ($points[2] + ".positionX") ($upLoc + ".tx");
        connectAttr ($points[2] + ".positionY") ($upLoc + ".ty");
        connectAttr ($points[2] + ".positionZ") ($upLoc + ".tz");
        setAttr ($points[2] + ".turnOnPercentage") 1;
        setAttr ($points[2] + ".parameterU") $u;
        setAttr ($points[2] + ".parameterV") ($v-.000000001);
        
        //aim constrain the locator using the aim and second axis locators and match the offset's rotation to the locator
        aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "object" -worldUpObject $upLoc $aimLoc $loc;
        select -r $loc $offsets[$i];
        nas_matchTransforms 0 0 0 1 1 1 0 0 0;
        
        //clean up
        delete $loc;
        delete $upLoc;
        delete $aimLoc;
        
        nas_progress 0 "";
    }
    nas_progress 0 "end";
}

/*
string $locs[], $joints[], $closest, $binds[], $curve, $points[], $loc;
float $lowestDist, $minU, $maxU, $dist, $u;

$locs = `ls -sl`;
$curve = "Rope_02_Bind_Curve";

$array = `spaceLocator -p 0 0 0`;
$loc = $array[0];

for ($i = 0; $i < size($locs); $i++) {
    $points[$i] = `pointOnCurve -ch 1 $curve`;
    setAttr ($points[$i] + ".turnOnPercentage") 1;


    connectAttr -f ($points[$i] + ".positionX") ($loc + ".tx");
    connectAttr -f ($points[$i] + ".positionY") ($loc + ".ty");
    connectAttr -f ($points[$i] + ".positionZ") ($loc + ".tz");

    $lowestDist = 1000000000.0;
    $minU = 0.0;
    $maxU = 1.0;
    for ($d = 0; $d < 100; $d++) {
        for ($j = 0; $j < 4; $j++) {
            setAttr ($points[$i] + ".parameter") ($minU + $j*(($maxU-$minU)/3.0));
            $dist = `nas_distance{$locs[$i], $loc}`;
            if ($dist < $lowestDist) {
                $lowestDist = $dist;
                $u = ($minU + $j*(($maxU-$minU)/3.0));
            }
        }
        $minU = $u - (($maxU-$minU)/3.0);
        $maxU = $u + (($maxU-$minU)/3.0);
    }
    setAttr ($points[$i] + ".parameter") $u;
    connectAttr -f ($points[$i] + ".positionX") ($locs[$i] + ".tx");
    connectAttr -f ($points[$i] + ".positionY") ($locs[$i] + ".ty");
    connectAttr -f ($points[$i] + ".positionZ") ($locs[$i] + ".tz");
}

delete $loc;
*/

//-------------------------------------------------------------nas_charNameFromDir---------------------------------------------------------------------
global proc string nas_charNameFromDir() {
    string $charName = `file -q -sn`;
    $array = stringToStringArray($charName, "/");
    if ($array[0] == "P:") {
        if ($array[3] == "Props") $charName = $array[size($array)-3];
        else if ($array[4] == "Animals") $charName = $array[6];
        else $charName = $array[5];
    } else {
        if ($array[4] == "Props") $charName = $array[size($array)-3];
        else $charName = $array[6];
    }
    return $charName;
}

//-------------------------------------------------------------nas_createLayers---------------------------------------------------------------------
global proc nas_createLayers() {
    string $charName, $array[], $names[], $layers[];
    $charName = `nas_charNameFromDir`;
    $names = {"Light_Rig", ($charName + "_Mesh"), "Controller_Vis", "EyesTongueTeeth_Mesh"};

    for ($i = size($names)-1; $i >= 0; $i--) {
        if (!`objExists $names[$i]`) {
            //$layers = `ls -type displayLayer`;
            //$array = `ls "*:defaultLayer"`;
            //$array = stringArrayCatenate ($array, {"defaultLayer"});
            //$layers = stringArrayRemove ($array, $layers);
            //createDisplayLayer -name $name -number (size($layers)+1) -empty;
            if ($i == 1) {
                $array = `ls -type transform "*_Geo"`;
                select -r `listRelatives -fullPath -s $array`;
                createDisplayLayer -name $names[$i];
            } else if ($i == 2) {
                $array = `ls -type transform "*_Ctrl"`;
                if (`objExists "COG"`) $array[size($array)] = "COG";
                if (`objExists "Transform"`) $array[size($array)] = "Transform";
                if (`objExists "Controller_Vis"`) $array[size($array)] = "Controller_Vis";
                //select -r `listRelatives -fullPath -s $array`;
                select -r $array;
                createDisplayLayer -nr -name $names[$i];
                /*if (`objExists "Controllers"`) {
                    select -r "Controllers";
                    createDisplayLayer -nr -name $names[$i];
                } else {
                    createDisplayLayer -name $names[$i] -empty;
                }*/
            } else {
                createDisplayLayer -name $names[$i] -empty;
            }
        }
    }
}

//-------------------------------------------------------------nas_groupGroups---------------------------------------------------------------------
//groups specified groups and names the group the same name as the first group in the array without the last number in its name
global proc string nas_groupGroups() {
    string $array[], $groups[], $short;
    int $num;
    
    $groups = `ls -sl -long`;
    $array = stringToStringArray($groups[0], "|");
    $short = $array[size($array)-1];    
    $array = stringToStringArray($short, "_");
    for ($i = size($array)-1; $i >= 0; $i--) {
        if (`gmatch $array[$i] "*[0-9]*"`) {
            stringArrayRemoveAtIndex($i, $array);
            break;
        }
    }
    $name = stringArrayToString($array, "_");
    if ($name == $short) $name += "_Group";
    return `group -n $name $groups`;
}

//-------------------------------------------------------------nas_rigJiggle---------------------------------------------------------------------
//select first fk system in chain and run to make a jiggle system on that part
global proc nas_rigJiggle() {
    string $ctrls[], $array[], $fkCtrlGroup, $jiggleGroups[], $locs[], $ikJoints[], $name, $upObjects[], $startJnt, $endJnt, 
    $startJntGroup, $endJntGroup, $jiggleJntGroup, $geo, $pointOnSurface, $rivetLoc, $jiggle, $aimLoc, $aimLocGroup, $ikHandle, 
    $ikCurve, $locGroups[], $geoGroup;
    int $num;
    
    //finds controls and their group
    $ctrls = `ls -sl`;
    $array = stringToStringArray($ctrls[0], "_");
    for ($i = size($array)-1; $i >= 0; $i--) {
        $num = $array[$i];
        if ($num > 0) {
            $array[$i] = "*";
            break;
        }
    }
    $ctrls = `ls (stringArrayToString($array, "_"))`;

    for ($i = size($array)-1; $i >= 0; $i--) {
        if ($array[$i] == "*") {
            stringArrayRemoveAtIndex($i, $array);
            break;
        }
    }
    $array[size($array)-1] = "Ctrl_Group";
    $fkCtrlGroup = stringArrayToString($array, "_");
    
    //creates a group above each control after the first
    for ($i = 1; $i < size($ctrls); $i++) {
        select -r $ctrls[$i];
        $array = `nas_group 0 "Group"`;
        $jiggleGroups[$i] = $array[0];
        $array = stringToStringArray($jiggleGroups[$i], "|");
        $array = stringToStringArray($array[0], "_");
        $array[size($array)-1] = "Jiggle_Group";
        $jiggleGroups[$i] = `rename $jiggleGroups[$i] (stringArrayToString($array, "_"))`;
    }
    
    //creates locators at each joint and creates all jiggle joints required
    select -r $ctrls;
    $locs = `nas_locator 1`;
    for ($i = 0; $i < size($locs); $i++) {
        $array = stringToStringArray($ctrls[$i], "_");
        $array[size($array)-1] = "Jiggle_Loc";
        $locs[$i] = `rename $locs[$i] (stringArrayToString($array, "_"))`;
    }
    select -r $locs;
    $locGroups = `nas_group 0 "Group"`;
    
    for ($i = 0; $i < size($array); $i++) {
        if ($array[$i] != "FK") $name += ($array[$i] + "_");
        else break;
    }
    select -r $locs;
    $ikJoints = `nas_joints ($name + "Jiggle_##_Jnt") x y y 0`;
    $upObjects = `duplicate $locs`;
    for ($i = 0; $i < size($ikJoints); $i++) {
        move -os -r 0 1 0 $upObjects[$i];
        select -r $ikJoints[$i] $upObjects[$i];
        nas_orientJoints x y y 1;
    }
    delete $upObjects $locGroups[0] $locGroups[size($locGroups)-1];
    
    $array = `duplicate -rc $ikJoints[0]`;
    $startJnt = `rename $array[0] ($name + "Jiggle_Start_Jnt")`;
    $array = `listRelatives -ad $startJnt`;
    parent -w $array[0];
    delete $array[size($array)-1];
    $endJnt = `rename $array[0] ($name + "Jiggle_End_Jnt")`;
    
    //groups and constrains start and end joints
    select -r $startJnt $endJnt;
    $array = `nas_group 0 "Group"`;
    $startJntGroup = $array[0];
    $endJntGroup = $array[1];
    select -r $ctrls[0] $startJntGroup $endJntGroup;
    nas_massConstrain 0 parent 1;
    
    $jiggleJntGroup = `group -n ($name + "Jiggle_Jnt_Group") $ikJoints[0] $startJntGroup $endJntGroup`;
    
    //create jiggle geo and rivet loc
    $array = `nurbsPlane -n ($name + "Jiggle_Geo") -p 0 0 0 -ax 0 1 0 -w 1 -lr 1 -d 1 -u 1 -v 1 -ch 1`;
    $geo = $array[0];
    delete `parentConstraint $ikJoints[size($ikJoints)-1] $geo`;
    
    $array[0] = `pointOnSurface -ch 1 $geo`;
    $pointOnSurface = `rename $array[0] ($name + "Jiggle_PointOnSurface")`;
    setAttr ($pointOnSurface + ".parameterU") .5;
    setAttr ($pointOnSurface + ".parameterV") .5;
    setAttr ($pointOnSurface + ".turnOnPercentage") 1;
    $array = `spaceLocator -n ($name + "Jiggle_Loc") -p 0 0 0`;
    $rivetLoc = $array[0];
    connectAttr ($pointOnSurface + ".positionX") ($rivetLoc + ".tx");
    connectAttr ($pointOnSurface + ".positionY") ($rivetLoc + ".ty");
    connectAttr ($pointOnSurface + ".positionZ") ($rivetLoc + ".tz");
    
    parentConstraint -mo $ctrls[0] $geo;
    select -r $geo;
    doJiggle 1 { "0.5", "0.5", "1", "0", "0", "default", "" };
    $array = `listHistory -pdo 1 -il 1 $geo`;
    $jiggle = `rename $array[0] ($name + "Jiggle")`;
    
    //create attrs on first ctrl and connect them to jiggle
    addAttr -ln "Jiggle" -at "enum" -en "Enable:Disable:Enable Only After Object Stops" $ctrls[0];
    addAttr -ln "JiggleWeight" -at double -min 0 -max 1 -dv .8 $ctrls[0];
    addAttr -ln "JiggleDamping" -at double -min 0 -max 1 -dv .08 $ctrls[0];
    addAttr -ln "JiggleStiffness" -at double -min 0 -max 1 -dv 0 $ctrls[0];
    for ($attr in {"Jiggle", "JiggleWeight", "JiggleDamping", "JiggleStiffness"}) setAttr -e-keyable true ($ctrls[0] + "." + $attr);
    connectAttr ($ctrls[0] + ".Jiggle") ($jiggle + ".enable");
    connectAttr ($ctrls[0] + ".JiggleWeight") ($jiggle + ".jiggleWeight");
    connectAttr ($ctrls[0] + ".JiggleDamping") ($jiggle + ".damping");
    connectAttr ($ctrls[0] + ".JiggleStiffness") ($jiggle + ".stiffness");
    
    //create aim loc and point and aim constrain end joint
    $array = `spaceLocator -n ($name + "Aim_Loc")`;
    $aimLoc = $array[0];
    $array = `nas_group 0 "Group"`;
    $aimLocGroup = $array[0];
    parentConstraint $ctrls[0] $aimLocGroup;
    scaleConstraint $ctrls[0] $aimLocGroup;
    
    pointConstraint $rivetLoc $endJnt;
    aimConstraint -offset 0 0 0 -weight 1 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $ctrls[0] $aimLoc $endJnt;
    nas_breakConnection ($endJnt + ".tx");
    
    //create ik spline system
    $array = `ikHandle -sol ikSplineSolver -pcv false -ns 4 -sj $ikJoints[0] -ee $ikJoints[size($ikJoints)-1]`;
    $ikHandle = `rename $array[0] ($name + "Jiggle_Handle")`;
    $ikCurve = `rename $array[2] ($name + "Jiggle_Curve")`;
    select -r $startJnt $endJnt $ikCurve;
    nas_skinCluster;
    setAttr ($ikHandle + ".dTwistControlEnable") 1;
    setAttr ($ikHandle + ".dWorldUpType") 4;
    connectAttr ($startJnt + ".worldMatrix[0]") ($ikHandle + ".dWorldUpMatrix");
    connectAttr ($endJnt + ".worldMatrix[0]") ($ikHandle + ".dWorldUpMatrixEnd");
    
    //create jiggle loc groups and constrain jiggle locs and groups to ikspline joints
    for ($i = 1; $i < size($locs)-1; $i++) {
        parentConstraint -mo $ikJoints[$i-1] $locGroups[$i];
        scaleConstraint -mo $ikJoints[$i-1] $locGroups[$i];
        parentConstraint -mo $ikJoints[$i] $locs[$i];
        scaleConstraint -mo $ikJoints[$i] $locs[$i];
        connectAttr ($locs[$i] + ".tx") ($jiggleGroups[$i] + ".tx");
        connectAttr ($locs[$i] + ".ty") ($jiggleGroups[$i] + ".ty");
        connectAttr ($locs[$i] + ".tz") ($jiggleGroups[$i] + ".tz");
        connectAttr ($locs[$i] + ".rx") ($jiggleGroups[$i] + ".rx");
        connectAttr ($locs[$i] + ".ry") ($jiggleGroups[$i] + ".ry");
        connectAttr ($locs[$i] + ".rz") ($jiggleGroups[$i] + ".rz");
        connectAttr ($locs[$i] + ".sx") ($jiggleGroups[$i] + ".sx");
        connectAttr ($locs[$i] + ".sy") ($jiggleGroups[$i] + ".sy");
        connectAttr ($locs[$i] + ".sz") ($jiggleGroups[$i] + ".sz");
    }
    
    $locGroups = stringArrayRemove({$locGroups[0], $locGroups[size($locs)-1]}, $locGroups);
    select -r $locGroups;
    $mainLocGroup = `nas_groupGroups`;
    if (!`objExists ($name + "Jiggle_Group")`) group -n ($name + "Jiggle_Group") -em;
    parent $geo $rivetLoc $ikCurve $ikHandle $aimLocGroup $mainLocGroup ($name + "Jiggle_Group");
}

//-------------------------------------------------------------nas_correctiveShape---------------------------------------------------------------------
global proc string nas_correctiveShape() {
    float $iterations = 10;
    float $minDistance = .001;
    float $times = 20;
    
    string $sourceVerts[], $blendVerts[], $modeledVerts[], $sourceGeo, $modeledGeo, $array[], $hists[], $loc1, $loc2, $connects[];
    string $blendShape = "";
    float $blendWS[], $envelopes[], $bb[], $wp[], $percent, $floatArray[];
    
    // run check
    string $result = `confirmDialog -title "Are you sure?" -message "Did you select the modeled corrective followed by the original geo?" 
            -button "Yes!" -button "No..." -defaultButton "Yes!" 
            -cancelButton "No..." -dismissString "No..."`;
    if ($result == "No...") return "";
    
    //store selections
    $array = `ls -sl -type transform`;
    $modeledGeo = $array[0];
    $sourceGeo = $array[1];
    if (size($array) != 2) error "Please select modeled corrective geo followed by the original geo";    
    
    //histories off
    $hists = `listHistory -il 1 -pdo 1 $sourceGeo`;
    for ($i = 0; $i < size($hists); $i++) {
        if (`objExists ($hists[$i] + ".envelope")`) {
            $connects[$i] = `connectionInfo -sfd ($hists[$i] + ".envelope")`;
            if (size($connects[$i])) disconnectAttr $connects[$i] ($hists[$i] + ".envelope");
            $envelopes[$i] = `getAttr ($hists[$i] + ".envelope")`;
            setAttr ($hists[$i] + ".envelope") 0;
        }
    }
    
    //create blend
    $array = `duplicate $sourceGeo`;
    $blendGeo = $array[0];
    $blendGeo = `rename $blendGeo ($modeledGeo + "_Blendshape")`;

    //Add to or create a blendshape.
    $hists = `listHistory -pdo 1 -il 2 $sourceGeo`;
    for ($hist in $hists) {
        if (`nodeType $hist` == "blendShape") {
            $blendShape = $hist;
            break;
        }
    }
    if ($blendShape == "") {
        $array = `blendShape -frontOfChain -n ($modeledGeo + "_Blends") $blendGeo $sourceGeo`;
        $blendShape = $array[0];
    } else {
        blendShape -e  -t $sourceGeo 1 $blendGeo 1 $blendShape;
    }

    setAttr ($blendShape + "." + $blendGeo) 1;
    dkCheckFlagAttr $blendGeo {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"} {"lock"} {0.0};
    $bb = `nas_boundingBox {$blendGeo}`;
    move -r (3.0 * ($bb[3]-$bb[0])) 0 0 $blendGeo;
    
    //histories back on
    for ($i = 0; $i < size($hists); $i++) {
        if (`objExists ($hists[$i] + ".envelope")`) {
            setAttr ($hists[$i] + ".envelope") $envelopes[$i];
            if (size($connects[$i])) connectAttr -f $connects[$i] ($hists[$i] + ".envelope");
        }
    }
        
        $array = `spaceLocator -p 0 0 0`;
        $loc1 = $array[0];
        $array = `spaceLocator -p 0 0 0`;
        $loc2 = $array[0];
        $sourceVerts = `nas_alteredVerts $modeledGeo $sourceGeo`;
        
    nas_progress (size($sourceVerts)*3) "start";
    for ($i = 0; $i < size($sourceVerts); $i++) {
        $array = stringToStringArray($sourceVerts[$i], ".");
        $blendVerts[$i] = ($blendGeo + "." + $array[1]);
        $modeledVerts[$i] = ($modeledGeo + "." + $array[1]);
        $maxDistance = `nas_distance {$sourceVerts[$i], $modeledVerts[$i]}`;
        for ($j = 0; $j < 3; $j++) {
            $blendWS = `xform -q -translation -ws $blendVerts[$i]`;
            
            $blendWS[$j] -= 1000*$maxDistance;
            move -ws $blendWS[0] $blendWS[1] $blendWS[2] $blendVerts[$i];
            $wp = `xform -ws -q -translation $sourceVerts[$i]`;
            move -ws $wp[0] $wp[1] $wp[2] $loc1;
            
            $blendWS[$j] += 2000*$maxDistance;
            move -ws $blendWS[0] $blendWS[1] $blendWS[2] $blendVerts[$i];
            $wp = `xform -ws -q -translation $sourceVerts[$i]`;
            move -ws $wp[0] $wp[1] $wp[2] $loc2;
            
            $blendWS[$j] -= 1000*$maxDistance;
            
            $floatArray = `nas_distanceBetween $modeledVerts[$i] $loc1 $loc2`;
            $percent = $floatArray[0];
            $blendWS[$j] = ($blendWS[$j] - 1000*$maxDistance) + (2000*$maxDistance*(1.0-$percent));
            move -ws $blendWS[0] $blendWS[1] $blendWS[2] $blendVerts[$i];
            if (`nas_progress 0 ("Working on " + $sourceVerts[$i])`) return "";
        }
    }
    nas_progress 0 "end";
    
    delete $loc1 $loc2;
    select -r $sourceVerts;
    return $sourceGeo;
}

//-------------------------------------------------------------nas_killWindows---------------------------------------------------------------------
global proc nas_killWindows() {    
    string $windows[], $array[];
    //close common maya windows
    $array = `lsUI -wnd`;
    for ($item in $array) if (`gmatch $item "nas*"` == 0 && `gmatch $item "dk*"` == 0 && `gmatch $item "nmp*"` == 0 && `gmatch $item "asset*"` == 0 && `gmatch $item "MayaWindow"` == 0) $windows[size($windows)] = $item;
    for ($window in $windows) if (`window -q -vis $window`) deleteUI $window;
}

//-------------------------------------------------------------nas_mimicDeformerWeightsSource---------------------------------------------------------------------
global proc nas_mimicDeformerWeightsSource() {
    global string $nas_mimicDeformerWeightsSourceVerts[];
    $nas_mimicDeformerWeightsSourceVerts = `ls -sl -flatten`;
}

//-------------------------------------------------------------nas_mimicDeformerWeights---------------------------------------------------------------------
global proc nas_mimicDeformerWeights(string $deformer) {
    global string $nas_mimicDeformerWeightsSourceVerts[];
    string $sourceVerts[], $targetVerts[], $closeVerts[];
    float $sourceWeights[], $floatArray[], $dist, $lowestDist, $targetWeights[];
    int $targetInd;
    
    $sourceVerts = $nas_mimicDeformerWeightsSourceVerts;
    $targetVerts = `ls -sl -flatten`;
    
    for ($i = 0; $i < size($sourceVerts); $i++) {
        $floatArray = `percent -q -v $deformer $sourceVerts[$i]`;
        $sourceWeights[$i] = $floatArray[0];
    }
    
    nas_progress (size($targetVerts)) "start";
    for ($i = 0; $i < size($targetVerts); $i++) {
        $lowestDist = `nas_distance{$targetVerts[$i], $sourceVerts[0]}`;
        $targetInd = 0;
        for ($j = 0; $j < size($sourceVerts); $j++) {
            $dist = `nas_distance{$targetVerts[$i], $sourceVerts[$j]}`;
            if ($dist < $lowestDist) {
                $lowestDist = $dist;
                $targetInd = $j;
            }
        }
        $targetWeights[$i] = $sourceWeights[$targetInd];
        $closeVerts[$i] = $sourceVerts[$targetInd];
        percent -v $targetWeights[$i] $deformer $targetVerts[$i];
        if (`nas_progress 0 ("Weighting: " + $targetVerts[$i])`) return;
    }
    nas_progress 0 "end";
}

//-------------------------------------------------------------nas_selectionMask---------------------------------------------------------------------
//changes your selection mask based on what you have selected when run
global proc nas_selectionMask() {
    global string $nasQuickSelectionMaskButton;
    global int $nasSelectionMaskToggle, $nasScriptJobOn, $nasSelectionMaskSceneOpenedJobNum, $dkSelectionMaskSceneOpenedJobNum;
    string $sels[], $shapes[], $types[];
    
    if (!$nasScriptJobOn) {
        $nasSelectionMaskSceneOpenedJobNum = `scriptJob -event SceneOpened "if (`button -exists $nasQuickSelectionMaskButton`) button -e -bgc .831 .816 .784 $nasQuickSelectionMaskButton;"`;
        $nasScriptJobOn = 1;
    }
    if ($dkSelectionMaskSceneOpenedJobNum > 0) scriptJob -kill $dkSelectionMaskSceneOpenedJobNum;
    
    $sels = `ls -sl`;
    $shapes = `listRelatives -fullPath -shapes`;
    $types = {
    "ikHandle", "-ikHandle", 
    "joint", "-joint", 
    "nurbsCurve", "-nurbsCurve", 
    "nurbsSurface", "-nurbsSurface", 
    "mesh", "-polymesh", 
    "subdiv", "-subdiv", 
    "clusterHandle", "-cluster", 
    "lattice", "-lattice", 
    "deformBend", "-nonlinear", 
    "deformFlare", "-nonelinear", 
    "deformSine", "-nonlinear", 
    "deformSquash", "-nonlinear", 
    "deformTwist", "-nonlinear", 
    "deformWave", "-nonlinear",  
    "light", "-light", 
    "ambientLight", "-light", 
    "directionalLight", "-light", 
    "pointLight", "-light", 
    "spotLight", "-light", 
    "areaLight", "-light", 
    "locator", "-locator", 
    "place3dTexture", "-texture"
    };
    
    if (!$nasSelectionMaskToggle) {
        selectType -allObjects 0;
        if (size($shapes) > 0) {
            for ($shape in $shapes) for ($i = 0; $i < size($types); $i+=2) {
                if (`objectType -isType $types[$i] $shape`) selectType $types[$i+1] 1;
            }
            for ($sel in $sels) for ($i = 0; $i < size($types); $i+=2) {
                if (`objectType -isType $types[$i] $sel`) selectType $types[$i+1] 1;
            }
        } else {
            $nasSelectionMaskToggle = 0;
            selectType -allObjects 1;
        }
        $nasSelectionMaskToggle = 1;
        if (`button -exists $nasQuickSelectionMaskButton`) button -e -bgc .4 .8 .4 $nasQuickSelectionMaskButton;
        print "Mask On";
    } else {
        $nasSelectionMaskToggle = 0;
        setObjectPickMask "All" 1;
        if (`button -exists $nasQuickSelectionMaskButton`) button -e -bgc .925 .913 .846 $nasQuickSelectionMaskButton;
        print "Mask Off";
    }
}

//-------------------------------------------------------------nas_weightPinch---------------------------------------------------------------------
//select a target vert followed by verts that should try to get as close to it as possible
//dkWeightPinch will alter the weighting of two influences and settle on the one that results in the closest distance to target vert
global proc nas_weightPinch(string $joints[]) {
    global string $nasWeightPinchTargetVerts[];
    string $verts[], $skinCluster, $histories[], $object, $array[], $loc, $targetVert, $undoCmd;
    float $lowestDist, $lowestWeight, $totalWeight, $finalTerm, $distance;
    vector $wp, $pos1, $pos2;

    if (size($joints) != 2) error "please input only two influences";
    for ($joint in $joints) if (!`objExists $joint`) error ($joint + " does not exist.");
    
    $verts = `ls -sl -flatten`;
    if (size($verts) < 2) error "sorry, please select two or more verts in order, separately";
    $undoCmd = `undoInfo -q -undoName`;
    $array = stringToStringArray($undoCmd, " ");
    $targetVert = $array[2];
    $verts = stringArrayRemove({$targetVert}, $verts);
    print ("target vert is " + $targetVert);
    $array = `ls -flatten $targetVert`;
    if (size($array) > 1) error "please make first selection a single vert";
    $array = stringToStringArray($targetVert, ".");
    $object = $array[0];
    $histories = `listHistory -pdo 1 -il 2`;
    for ($history in $histories) if (nodeType($history) == "skinCluster") {
            $skinCluster = $history;
            break;
    }
    if ($skinCluster == "") error "no skin cluster associated with selected verts";
    
    $pos1 = `xform -query -translation -worldSpace $targetVert`;
    
    for ($i = 0; $i < size($verts); $i++) {
        $totalWeight = 0;
        for ($joint in $joints) $totalWeight += `skinPercent -transform $joint -query $skinCluster $verts[$i]`;
        
        select -r $verts[$i];
        $array = `nas_locator 0`;
        $loc = $array[0];
        skinPercent -pruneWeights 100 -normalize off $skinCluster $verts[$i];
        skinPercent -normalize off -tv $joints[0] 0 $skinCluster $verts[$i];
        skinPercent -normalize off -tv $joints[1] $totalWeight $skinCluster $verts[$i];
        $wp = `xform -q -translation -ws $verts[$i]`;
        setKeyframe -t 0 -v ($wp.x) ($loc + ".tx");
        setKeyframe -t 0 -v ($wp.y) ($loc + ".ty");
        setKeyframe -t 0 -v ($wp.z) ($loc + ".tz");
        skinPercent -normalize off -tv $joints[0] $totalWeight $skinCluster $verts[$i];
        skinPercent -normalize off -tv $joints[1] 0 $skinCluster $verts[$i];
        $wp = `xform -q -translation -ws $verts[$i]`;
        setKeyframe -t 100 -v ($wp.x) ($loc + ".tx");
        setKeyframe -t 100 -v ($wp.y) ($loc + ".ty");
        setKeyframe -t 100 -v ($wp.z) ($loc + ".tz");
        
        $pos2 = `getAttr -t 0 ($loc + ".translate")`;
        $finalTerm = (pow(($pos2.x - $pos1.x), 2)) + (pow(($pos2.y - $pos1.y), 2)) + (pow(($pos2.z - $pos1.z), 2));
        $lowestDist = `sqrt $finalTerm`;
        for ($j = 0; $j <= 100; $j++) {
            $pos2 = `getAttr -t $j ($loc + ".translate")`;
            $finalTerm = (pow(($pos2.x - $pos1.x), 2)) + (pow(($pos2.y - $pos1.y), 2)) + (pow(($pos2.z - $pos1.z), 2));
            $distance = `sqrt $finalTerm`;

            if ($distance < $lowestDist) {
                $lowestDist = $distance;
                $lowestWeight = (.01*$j*$totalWeight);
            }
        }
        skinPercent -normalize off -tv $joints[0] $lowestWeight $skinCluster $verts[$i];
        skinPercent -normalize off -tv $joints[1] ($totalWeight-$lowestWeight) $skinCluster $verts[$i];
        delete $loc;
    }
    
    select -r $verts;
    setSelectMode components Components;
    selectType -v 1 -smp 0 -sme 0 -smf 0 -smu 0 -pv 1 -pe 0 -pf 0 -puv 0;
    hilite -r $object;
    $message = "Pinch painted!";
}

//-------------------------------------------------------------nas_nurbsDefaultDisplay---------------------------------------------------------------------
global proc nas_nurbsDefaultDisplay() {
    string $sels[], $shapes[], $array[];
    $sels = `ls -sl -long`;
    for ($sel in $sels) {
        $shapes = `listRelatives -fullPath -s $sel`;
        for ($shape in $shapes) {
            if (`objExists ($shape + ".curvePrecision")`) setAttr ($shape + ".curvePrecision") 4;
            if (`objExists ($shape + ".curvePrecisionShaded")`) setAttr ($shape + ".curvePrecisionShaded") 4;
            if (`objExists ($shape + ".simplifyMode")`) setAttr ($shape + ".simplifyMode") 0;
            if (`objExists ($shape + ".simplifyU")`) setAttr ($shape + ".simplifyU") 1;
            if (`objExists ($shape + ".simplifyV")`) setAttr ($shape + ".simplifyV") 1;
            if (`objExists ($shape + ".divisionsU")`) setAttr ($shape + ".divisionsU") 0;
            if (`objExists ($shape + ".divisionsV")`) setAttr ($shape + ".divisionsV") 0;
        }
    }
}

//-------------------------------------------------------------nas_setHiresToRenderable---------------------------------------------------------------------
global proc nas_setHiresToRenderable() {
    string $array[], $geos[], $attrs[];
    float $values[];
    
    $attrs = {"castsShadows", "receiveShadows", "motionBlur", "primaryVisibility", "smoothShading", "visibleInReflections", "visibleInRefractions", "doubleSided"};
    $values = {1, 1, 1, 1, 1, 1, 1, 1};
    
    $array = `ls "*HiRes*"`;
    $array = stringArrayCatenate($array, `ls "*Hires*"`);
    $array = stringArrayCatenate($array, `ls "*hires*"`);
    $array = stringArrayCatenate($array, `ls "*hiRes*"`);
    $array = stringArrayCatenate($array, `ls "*EyesTongueTeeth*"`);
    
    for ($item in $array) {
        $geos = `listRelatives -fullPath -allDescendents -type mesh $item`;
        for ($geo in $geos) dkCheckAttr $geo $attrs $values;
    }
}

//-------------------------------------------------------------nas_makeNonRenderable---------------------------------------------------------------------
global proc nas_makeNonRenderable() {
    string $array[], $geos[], $attrs[];
    float $values[];
    
    $array = `ls -sl`;
    
    $attrs = {"castsShadows", "receiveShadows", "motionBlur", "primaryVisibility", "smoothShading", "visibleInReflections", "visibleInRefractions", "doubleSided", 
    "miTransparencyCast", "miTransparencyReceive", "miReflectionReceive", "miRefractionReceive", "miFinalGatherCast", "miFinalGatherReceive", 
    "miDeriveFromMaya", "miHide", "miVisible", "miTrace", "miShadow", "miCaustic", "miGlobillum"};
    $values = {0, 0, 0, 0, 0, 0, 0, 1, 
    0, 0, 0, 0, 0, 0, 
    0, 0, 2, 2, 2, 0, 0};
    
    for ($item in $array) {
        dkCheckAttr $item $attrs $values;
        $geos = `listRelatives -fullPath -allDescendents -type nurbsSurface $item`;
        for ($geo in $geos) dkCheckAttr $geo $attrs $values;
    }
}

//-------------------------------------------------------------nas_rigProp---------------------------------------------------------------------
//select geos and run
global proc nas_rigProp(string $niceName, string $deformers[], string $axis) {
    string $array[], $loc, $sels[], $ctrl, $name, $cog, $groups[], $cogNull, $ctrlGroup;
    float $bb[], $wp[];
    vector $axisVec;
    
    $axisVec = `nas_axisToVector $axis`;
    $sels = `ls -sl`;
    $name = `nas_charNameFromFile`;
    if (!size($name)) {
        $array = stringToStringArray($sels[0], "_");
        if (size($array) == 1) {
            $name = $sels[0];
        } else {
            stringArrayRemoveAtIndex($array[size($array)-1], $array);
            $name = stringArrayToString($array, "_");
        }
    }
    
    $bb = `nas_boundingBox $sels`;
    $array = `ls "*_COG"`;
    $cog = $array[0];
    $array = `ls "*_COG_Null"`;
    $cogNull = $array[0];
    if ($cog == "") {
        $array = `nas_locator 0`;
        $loc = $array[0];
        select -r $loc; 
        $array = `dkControls curveCircle ($bb[3] + 1)`;
        $cog = `rename $array[0] ($name + "_COG")`;
        select -r $cog; nas_colorControls "yellow" 0;
        makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $cog;
        delete -ch $cog;
        delete $loc;
        if (`objExists ($name + "_Transform")`) parent $cog ($name + "_Transform");
    }
    for ($deformer in $deformers) {
        switch ($deformer) {
            case "squash":
                select -r $cogNull;
                $array = `nas_controls curveSquare`;
                $ctrl = `rename $array[0] ($niceName + "_Deformer_Squash_Ctrl")`;
                if ($axis == "x") rotate -r -os 0 0 -90 ($ctrl + ".cv[0:4]");
                else if ($axis == "z") rotate -r -os 90 0 0 ($ctrl + ".cv[0:4]");
                
                select -r $ctrl;
                nas_addAttr "float" 0 0 "" {"Squash"};
                nas_addAttr "float" -10 0 "" {"SquashLowBound"};
                nas_addAttr "float" 0 10 "" {"SquashHighBound"};
                nas_showAttrs 1 1 1 1 1 1 1 1 1 0;
                
                $array = `nonLinear -type squash -lowBound 0 -highBound 2 $sels`;
                $array[0] = `rename $array[0] ($niceName + "_Squash")`;
                $array[1] = `rename $array[1] ($niceName + "_Deformer_Squash_Handle")`;
                connectAttr ($ctrl + ".Squash") ($array[0] + ".factor");

                if ($axis == "x") setAttr ($array[1] + ".rz") -90;
                else if ($axis == "z") setAttr ($array[1] + ".rx") 90;
                select -r $array[1]; $groups = `nas_group 0 "Group"`;
                makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $groups[0];
                connectAttr ($ctrl + ".SquashLowBound") ($array[0] + ".lowBound");
                setAttr ($ctrl + ".SquashLowBound") -10;
                connectAttr ($ctrl + ".SquashHighBound") ($array[0] + ".highBound");
                setAttr ($ctrl + ".SquashHighBound") 10;
                
                select -r $ctrl;
                $array = `nas_group 0 "Group"`;
                $ctrlGroup = $array[0];
                connectAttr ($cog + ".SquashCtrlVis") ($ctrlGroup + ".v");
                
                break;
            case "bend":
                select -r $cogNull;
                $array = `nas_controls curveBend`;
                $ctrl = `rename $array[0] ($niceName + "_Deformer_Bend_Ctrl")`;
                $wp = `xform -ws -q -rp $cogNull`;
                select -r ($ctrl + "Shape.cv[0:7]") ($ctrl + "Shape1.cv[0:25]");
                if ($axis == "x") rotate -r -p $wp[0] $wp[1] $wp[2] -os 0 0 -90 ;
                else if ($axis == "z") rotate -r -p $wp[0] $wp[1] $wp[2] -os 90 0 0 ;
                
                select -r $ctrl;
                nas_addAttr "float" 0 0 "" {"Bend"};
                nas_addAttr "float" -10 0 "" {"BendLowBound"};
                nas_addAttr "float" 0 10 "" {"BendHighBound"};
                nas_showAttrs 1 1 1 1 1 1 1 1 1 0;
                
                $array = `nonLinear -type bend -lowBound 0 -highBound 2 -curvature 0 $sels`;
                $array[0] = `rename $array[0] ($niceName + "_Bend")`;
                $array[1] = `rename $array[1] ($niceName + "_Deformer_Bend_Handle")`;
                connectAttr ($ctrl + ".Bend") ($array[0] + ".curvature");

                if ($axis == "x") setAttr ($array[1] + ".rz") -90;
                else if ($axis == "z") setAttr ($array[1] + ".rx") 90;
                select -r $array[1]; $groups = `nas_group 0 "Group"`;
                makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $groups[0];
                connectAttr ($ctrl + ".BendLowBound") ($array[0] + ".lowBound");
                setAttr ($ctrl + ".BendLowBound") -10;
                connectAttr ($ctrl + ".BendHighBound") ($array[0] + ".highBound");
                setAttr ($ctrl + ".BendHighBound") 10;
                
                select -r $ctrl;
                $array = `nas_group 0 "Group"`;
                $ctrlGroup = $array[0];
                connectAttr ($cog + ".BendCtrlVis") ($ctrlGroup + ".v");
                
                break;
        }
        if (`objExists "Offset"`) parent $ctrlGroup "Offset";
        parentConstraint -mo $cogNull $ctrlGroup;
        scaleConstraint -mo $cogNull $ctrlGroup;
        
        parentConstraint -mo $ctrl $groups[0];
        scaleConstraint -mo $ctrl $groups[0];
        if (`objExists "Deformers"`) parent $groups[0] "Deformers";
    }
    if (`objExists "Deformers"`) hide "Deformers";
    select -r $sels;
}

//-------------------------------------------------------------nas_paintValueExplicit---------------------------------------------------------------------
global proc nas_paintValueExplicit(float $value) {
    string $verts[], $joints[], $uJoints[], $array[], $skinCluster;
    float $weight, $uWeight;
    
    $verts = `ls -sl -fl`;
    for ($vert in $verts) if (`nodeType $vert` != "mesh") error "Please select verts and verts only";
    $skinCluster = `nas_getSkinCluster $verts[0]`;
    $joints = `skinCluster -q -inf $skinCluster`;
    clear $uJoints;
    $uWeight = 0.0;
    for ($joint in $joints) if (`getAttr ($joint + ".liw")` == 0) $uJoints[size($uJoints)] = $joint;
    for ($uJoint in $uJoints) $uWeight += `skinPercent -transform $uJoint -q $skinCluster $verts[0]`;
          skinPercent -tv $uJoints[0] ($uWeight * $value) $skinCluster $verts[0];
}

//-------------------------------------------------------------nas_findAngle---------------------------------------------------------------------
global proc float nas_findAngle(string $nodes[]) {
    vector $vecs[], $point1, $point2, $point3;
    float $deg;
    
    for ($i = 0; $i < 3; $i++) {
        if (`nodeType $nodes[$i]` == "transform") $vecs[$i] = `xform -ws -q -rp $nodes[$i]`;
        else $vecs[$i] = `xform -ws -q -translation $nodes[$i]`;
    }

    $point1 = $vecs[0];
    $point2 = $vecs[1];
    $point3 = $vecs[2];
    
    $point3 = <<(($point3.x)-($point2.x)), (($point3.y)-($point2.y)), (($point3.z)-($point2.z))>>;
    $point2 = <<(($point2.x)-($point1.x)), (($point2.y)-($point1.y)), (($point2.z)-($point1.z))>>;
    
    $deg = rad_to_deg(`angle $point2 $point3`);
    return $deg;
}

//-------------------------------------------------------------nas_traverse---------------------------------------------------------------------
global proc string nas_traverse() {
    global string $nasTraverseAnchor, $nasTraverseRecords[], $nasTraverseLastAnchor;
    string $sels[], $verts[], $anchor, $target, $nonVerts[], $neighbors[], $skinCluster;
    float $angles[], $sorts[], $lowestAngle;
    int $envelope, $targetFound;
    
    if (`gmatch $nasTraverseAnchor "*.vtx*"` == 0) $nasTraverseAnchor = "";
    if (!`objExists $nasTraverseAnchor`) error "Could not find anchor, please determine direction.";
    $anchor = $nasTraverseAnchor;
    
    //find out which of the selection is a vert and which are not verts for selection later
    $sels = `ls -sl -fl -long`;
    for ($i = 0; $i < size($sels); $i++) {
        if (`gmatch $sels[$i] "*.vtx*"` == 0) $nonVerts[size($nonVerts)] = $sels[$i];
        else $verts[size($verts)] = $sels[$i];
    }
    
    //turn off skincluster before finding out where to go
    $skinCluster = `nas_getSkinCluster $sels[0]`;
    if (`objExists ($skinCluster + ".envelope")`) {
        $envelope = `getAttr ($skinCluster + ".envelope")`;
        setAttr ($skinCluster + ".envelope") 0;
    }
    
    if (size($verts) == 0) error "Please select a vert before scroll selecting.";
    select -r $verts[0];
    ConvertSelectionToEdges;
    ConvertSelectionToVertices;
    $neighbors = `ls -sl -fl -long`;
    $neighbors = stringArrayRemove({$verts[0], $anchor}, $neighbors);
    
    for ($i = 0; $i < size($nasTraverseRecords); $i++) {
        if ($i%3 == 0 && $nasTraverseRecords[$i] == $verts[0]) {
            if ($nasTraverseRecords[$i+1] == $anchor) {
                if (size($nasTraverseRecords[$i+2])) {
                    $target = $nasTraverseRecords[$i+2];
                    $targetFound = 1;
                    break;
                }
            } else if ($nasTraverseRecords[$i+2] == $anchor) {
                if (size($nasTraverseRecords[$i+1])) {
                    $target = $nasTraverseRecords[$i+1];
                    $targetFound = 1;
                    break;
                }
            } else if (size($nasTraverseRecords[$i+1])) {
                    $target = $nasTraverseRecords[$i+1];
                    $targetFound = 1;
                    break;
            } else if (size($nasTraverseRecords[$i+2])) {
                    $target = $nasTraverseRecords[$i+2];
                    $targetFound = 1;
                    break;
            }
        }
    }
    
    if ($targetFound == 0) {
        $lowestAngle = 1000000000;
        for ($i = 0; $i < size($neighbors); $i++) {
            $angles[$i] = `nas_findAngle {$anchor, $verts[0], $neighbors[$i]}`;    
            if ($angles[$i] < $lowestAngle) {
                $lowestAngle = $angles[$i];
                $target = $neighbors[$i];
            }
        }
    }
        
    if (`objExists ($skinCluster + ".envelope")`) setAttr ($skinCluster + ".envelope") $envelope; 
    select -r $target $nonVerts;
    $nasTraverseLastAnchor = $anchor;
    $nasTraverseAnchor = $verts[0];
    return $target;
}

global proc nas_traverseStoreNeighbors() {
    global string $nasTraverseNeighbors[], $nasTraverseAnchor, $nasTraverseRecords[], $nasTraverseLastAnchor;
    global int $nasTraverseSearch, $nasTraverseDir, $nasTraverseNeighborsIndex;
    string $array[], $verts[], $sels[], $matchFound, $neighbors[], $vert, $nonVerts[];
    float $lowestAngle, $angles[], $sorts[];
    
    $sels = `ls -sl -fl -long`;
    for ($i = 0; $i < size($sels); $i++) {
        if (`gmatch $sels[$i] "*.vtx*"` == 0) $nonVerts[size($nonVerts)] = $sels[$i];
        else $verts[size($verts)] = $sels[$i];
    }
    $vert = $verts[0];
    if (`objExists $vert` == 0) error "Please make a single vert selection before beginning.";
    select -r $vert;
    ConvertSelectionToEdges;
    ConvertSelectionToVertices;
    $verts = `ls -sl -fl -long`;
    $nasTraverseNeighbors = stringArrayRemove({$vert}, $verts);
    
    $nasTraverseLastAnchor = $nasTraverseAnchor;
    $nasTraverseAnchor = $vert;
    $nasTraverseDir = 0;
    $nasTraverseSearch = 1;
    
    //store the original vert in records since we are making an explicit decision
    for ($i = 0; $i < size($nasTraverseRecords); $i++) if ($nasTraverseRecords[$i] == $vert) {$matchFound = 1;break;}
    if ($matchFound == 0) {
        for ($i = 0; $i < size($nasTraverseRecords)+3; $i++) {
            if ($i%3 == 0 && size($nasTraverseRecords[$i]) == 0) $nasTraverseRecords[$i] = $vert;
        }
    }
    
    $neighbors = $nasTraverseNeighbors;
    clear $verts;
    if (`objExists $nasTraverseLastAnchor`) {
        $anchor = $nasTraverseLastAnchor;
        for ($i = 0; $i < size($neighbors); $i++) $angles[$i] = `nas_findAngle {$anchor, $vert, $neighbors[$i]}`;
        $sorts = sort($angles);
        for ($i = 0; $i < size($sorts); $i++) {
            for ($j = 0; $j < size($angles); $j++) {
                if ($sorts[$i] == $angles[$j]) {
                    $verts[$i] = $neighbors[$j];
                    $angles[$j] = 999999999;
                    break;
                }
            }
        }
        $nasTraverseNeighbors = stringArrayRemove({$nasTraverseLastAnchor}, $verts);
        $nasTraverseNeighborsIndex = 1;
    } else {
        $verts = $neighbors;
        for ($i = 0; $i < size($neighbors); $i++) {
            $nasTraverseNeighbors[$i] = `nas_findClosest $vert $verts`;
            $verts = stringArrayRemove({$nasTraverseNeighbors[$i]}, $verts);
        }
        $nasTraverseNeighborsIndex = 0;
    }
    
    select -r $nonVerts $nasTraverseNeighbors[$nasTraverseNeighborsIndex];
}

global proc nas_traverseCycleNeighbors(int $dir) {
    global string $nasTraverseNeighbors[];
    global int $nasTraverseNeighborsIndex;
    string $verts[], $nonVerts[], $neighbors[], $sels[];
    int $index;
    
    $neighbors = $nasTraverseNeighbors;
    $index = $nasTraverseNeighborsIndex;
    if (size($neighbors) == 0) error "No neighbors found, cannot cycle neighbors.";
    
    $sels = `ls -sl -fl -long`;
    for ($sel in $sels) if (`gmatch $sel "*.vtx*"` == 0) $nonVerts[size($nonVerts)] = $sel;

    $index += $dir;
    if ($index >= size($neighbors)) $index = 0;
    else if ($index < 0) $index = size($neighbors) - 1;
    select -r $nonVerts $neighbors[$index];
    $nasTraverseNeighborsIndex = $index;
}

global proc nas_traverseGo() {
    global string $nasTraverseRecords[], $nasTraverseAnchor, $nasTraverseLastAnchor;
    global int $nasTraverseSearch;
    string $sels[], $vert;
    int $vertFound, $anchorFound;
    
    $nasTraverseSearch = 0;
    $sels = `ls -sl -fl -long`;
    for ($sel in $sels) if (`gmatch $sel "*.vtx*"`) {$vert = $sel;break;}
    for ($i = 0; $i < size($nasTraverseRecords); $i++) {
        if ($i%3 == 0 && $nasTraverseRecords[$i] == $nasTraverseAnchor) {
            for ($j = 1; $j < 3; $j++) if ($nasTraverseRecords[$i+$j] == $vert) $vertFound = 1;
            if ($vertFound == 0) {
                if (size($nasTraverseRecords[$i+1]) == 0) {
                    $nasTraverseRecords[$i+1] = $vert;
                } else if (size($nasTraverseRecords[$i+2]) == 0) {
                    $nasTraverseRecords[$i+2] = $vert;
                } else {
                    $nasTraverseRecords[$i+1] = $nasTraverseRecords[$i+2];
                    $nasTraverseRecords[$i+2] = $vert;
                }
            }
            $anchorFound = 1;
            break;
        }
    }
    if ($anchorFound == 0) {
        $nasTraverseRecords[size($nasTraverseRecords)] = $nasTraverseAnchor;
        $nasTraverseRecords[size($nasTraverseRecords)] = $vert;
        //if (size($nasTraverseLastAnchor)) $nasTraverseRecords[size($nasTraverseRecords)] = $nasTraverseLastAnchor;
        $nasTraverseRecords[size($nasTraverseRecords)] = "";
    }
            
    select -r $sels;
}

global proc nas_traverseMode(string $mode) {
    if ($mode == "default") {
        polyOptions -activeObjects -sizeVertex 3.0;
        selectPref -clickBoxSize 4;
    } else if ($mode == "pro") {
        polyOptions -activeObjects -sizeVertex 5.0;
        selectPref -clickBoxSize 100;
    }
}

//-------------------------------------------------------------nas_paintValue---------------------------------------------------------------------
global proc nas_paintValue(float $value, int $absolute) {
    string $verts[], $joints[], $uJoints[], $array[], $skinCluster, $sels[];
    float $weight, $uWeight;
    
    $sels = `ls -sl -fl -long`;
    for ($sel in $sels) {
        if (`gmatch $sel "*.vtx*"` || `gmatch $sel "*.pt*"` || `gmatch $sel "*.cv*"` ) {
            $verts[size($verts)] = $sel;
        } else if (`gmatch $sel "*.e*"` || `gmatch $sel "*.f*"`) {
            select $sel;
            ConvertSelectionToVertices;
            $array = `ls -sl -fl -long`;
            for ($vertex in $array) {
                $verts[size($verts)] = $vertex;
            }
        }
    }
    $verts = `stringArrayRemoveDuplicates $verts`;
    $skinCluster = `nas_getSkinCluster $verts[0]`;
    $joints = sort(`skinCluster -q -inf $skinCluster`);
    clear $uJoints;
    $uWeight = 0.0;
    for ($joint in $joints) if (`getAttr ($joint + ".liw")` == 0) $uJoints[size($uJoints)] = $joint;
    
    $weight = `skinPercent -transform $uJoints[0] -q $skinCluster $verts[0]`;
    for ($i = 0; $i < size($verts); $i++) {
        $uWeight = 0.0;
        for ($uJoint in $uJoints) $uWeight += `skinPercent -transform $uJoint -q $skinCluster $verts[$i]`;
        if ($absolute == 0) $weight = `skinPercent -transform $uJoints[0] -q $skinCluster $verts[$i]`;
        if (($weight + $value) < $uWeight && ($weight + $value) > 0.0) {
            skinPercent -tv $uJoints[0] ($weight + $value) $skinCluster $verts[$i];
        } else if (($weight + $value) >= $uWeight) {
            skinPercent -tv $uJoints[0] $uWeight $skinCluster $verts[$i];
        } else {
            skinPercent -tv $uJoints[0] 0 $skinCluster $verts[$i];
        }
    }
    select $sels;
    if (`gmatch $sels[0] "*.e*"`) {
        setComponentPickMask "Point" false;
        setComponentPickMask "Line" true;
    } else {
        setComponentPickMask "Line" false;
        setComponentPickMask "Point" true;
    }
}

global proc nas_paintValueFuncs(string $mode) {
    global string $nasPaintValueWeightScroll, $nasPaintValueSelectScroll, 
    $nasTraverseAnchor, $nasTraverseLastAnchor, 
    $nasPaintValueCheckBox, $nasPaintValueSelectMax;
    global float $nasScrollStartTime, $nasLastPaintScrollValue, $nasLastSelectScrollValue;
    global int $nasTraverseSearch, $nasTraverseDir;
    string $sels[], $vert, $verts[], $nonVerts[], $parts[];
    float $timing, $increment, $max, $currentScrollValue;
    int $dir, $twoVertsFound;
    
    if ($mode == "paint") {
        $max = `floatField -q -v $nasPaintValueSelectMax`;
        $timing = `timerX -st $nasScrollStartTime`;
                $currentScrollValue = `floatScrollBar -q -v $nasPaintValueWeightScroll`;
        if ($currentScrollValue < $nasLastPaintScrollValue) $dir = -1.0;
        else $dir = 1.0;
        if ($timing > .01) {
                    $increment = .01 / $timing;
                    $increment = $increment * $max * $dir;
                } else {
                    $increment = $max * $dir;
                }
                print($dir + ", " + $max + ", " + $increment + "\n");
        nas_paintValue $increment `checkBox -q -v $nasPaintValueCheckBox`;
                $nasLastPaintScrollValue = $currentScrollValue;
    } else if ($mode == "select") {
        $sels = `ls -sl -fl -long`;
        for ($i = 0; $i < size($sels); $i++) {
            if (`gmatch $sels[$i] "*.vtx*"` == 0) $nonVerts[size($nonVerts)] = $sels[$i];
            else $verts[size($verts)] = $sels[$i];
        }
        if (size($verts) > 1) {
            undo;
            $array = stringToStringArray(`undoInfo -q -undoName`, " ");
            catchQuiet(`redo`);
            if (`gmatch $array[size($array)-1] "*.vtx*"`) {
                for ($i = 0; $i < size($verts); $i++) {
                    $parts = stringToStringArray($verts[$i], "|");
                    if ($parts[size($parts)-1] == $array[size($array)-1]) {
                        $nasTraverseAnchor = $verts[$i];
                        break;
                    }
                }
                $verts = stringArrayRemove({$nasTraverseAnchor}, $verts);
                $twoVertsFound = 1;
            } else {
                error "Please make sure you use the select tool to select verts instead of a tool or undo.";
            }
        }
        $vert = $verts[0];
                $currentScrollValue = `floatScrollBar -q -v $nasPaintValueSelectScroll`;
        if ( $currentScrollValue < $nasLastSelectScrollValue) $dir = -1.0;
        else $dir = 1.0;
                $nasLastSelectScrollValue = $currentScrollValue;
        
        if ($nasTraverseSearch) {
            nas_traverseCycleNeighbors $dir;
        } else {
            if ($twoVertsFound) {
                if ($dir == -1) {
                    select -r $vert $nonVerts;
                    $nasTraverseAnchor = `nas_traverse`;
                    select -r $vert $nonVerts;
                    nas_traverse;
                } else if ($dir == 1) {
                    select -r $vert $nonVerts;
                }
            } else {
                if ($dir != $nasTraverseDir) {
                    select -r $vert $nonVerts;
                    $nasTraverseAnchor = `nas_traverse`;
                }
                select -r $vert $nonVerts;
                nas_traverse;
            }
            $nasTraverseDir = $dir;
        }
    }
    $nasScrollStartTime = `timerX`;
}


global proc nas_traverseSelection(string $type) {
    global string $nasTraverseSelectionNonVerts[];
    string $sels[], $verts[], $nonVerts[];
    
    $sels = `ls -sl -long -fl`;
    for ($i = 0; $i < size($sels); $i++) if (`gmatch $sels[$i] "*.vtx*"`) $verts[size($verts)] = $sels[$i];
    
    if ($type == "store") {
        $nasTraverseSelectionNonVerts = stringArrayRemove ($verts, $sels);
        print "Non-verts stored.";
    } else if ($type == "select") {
        select -r $nasTraverseSelectionNonVerts;
    } else if ($type == "paint") {
        select -r $nasTraverseSelectionNonVerts;
        ConvertSelectionToVertices;
        $nonVerts = `ls -sl -fl -long`;
        for ($i = 0; $i < 5; $i++) GrowPolygonSelectionRegion;
        select -d $nonVerts;
    }
}

global proc nas_paintValueUI() {
    global string $nasPaintValueWeightScroll, $nasPaintValueCheckBox, $nasPaintValueSelectScroll, $nasPaintValueSelectMax, $nasTraverseRecords[], $nasTraverseSelectionNonVerts[];
    global int $nasNeighborsStartTime = 0;
        global float $nasLastPaintScrollValue, $nasLastSelectScrollValue;
    string $window, $form, $checkBox, $edgeButton, $weightScroll, $selectScroll, $maxText, $maxField, $selectButton, $buttonForm;
    
    $window = `nas_window "nas_paintValue" 0 0 1`;
    $form = `formLayout`;
    $checkBox = `checkBox -h 20 -v 0 -l "Absolute"`;
    $maxText = `text -h 20 -label "Max Value"`;
    $maxField = `floatField -h 18 -w 38 -min .001 -max 1.0 -value 0.1 -step 0.01 -precision 3`;
    //$edgeButton = `button -label "Select Edges" -c "select -cl; SelectEdgeLoopTool"`;
    $buttonForm = `formLayout`;
        $selectButton = `button -label "Select" -c "nas_traverseSelection \"select\";" -ann "Selects non-verts that were stored by right clicking and going to \"Store\" on this button."`;
        nas_markingMenu 3 "" {
            "Store", "nas_traverseSelection \"store\";", "W", "0", "Stores non-vert selections.",
            "Non-Verts", "nas_traverseSelection \"select\";", "N", "0", "Stores non-vert selections.",
            "Paint Verts", "nas_traverseSelection \"paint\";", "E", "0", "Stores non-vert selections."};
        setParent..;
    string $scrollForm = `formLayout`;
    $array[0] = `about -v`;
    $array = stringToStringArray($array[0], " ");
    if ($array[0] == "2012-2.2.Nickelodeon") {
        $selectScroll = `floatScrollBar -height 50 -min 0 -max 1 -value 0 -step .6 -largeStep .6 -changeCommand "nas_paintValueFuncs \"select\""`;
    } else {
        $selectScroll = `floatScrollBar -min -100 -max 100 -value 0 -step .001 -largeStep .001 -changeCommand "nas_paintValueFuncs \"select\""`;
    }
    nas_markingMenu 2 "" {
        "Default", "nas_traverseMode \"default\"", "W", "0", "Changes vertex size and selection box size to default.", 
        "Pro", "nas_traverseMode \"pro\"", "E", "0", "Changes vertex size and selection box size to so that they are bigger."};
    nas_markingMenu 3 "" {
        "Direction", "nas_traverseStoreNeighbors;", "W", "0", "Switches select scroll to find neighbor mode.", 
        "Go", "nas_traverseGo", "E", "0", "Switches select scroll to find traverse mode.", 
        "Clear Memory", "clear $nasTraverseRecords", "N", "0", "Clears chosen directions for traversing."};
    if ($array[0] == "2012-2.2.Nickelodeon") {
        $weightScroll = `floatScrollBar -height 50 -backgroundColor .15 .8 0 -min 0 -max 1 -value 0 -step .6 -largeStep .6 -changeCommand "nas_paintValueFuncs \"paint\""`;
    } else {
        $weightScroll = `floatScrollBar -backgroundColor .15 .8 0 -min -100 -max 100 -value 0 -step .001 -largeStep .001 -changeCommand "nas_paintValueFuncs \"paint\""`;
    }
    $nasLastSelectScrollValue = 0.0;
    $nasLastPaintScrollValue = 0.0;
    
    formLayout -e 
        -af $selectScroll "top" 0
        -af $selectScroll "left" 0
        -af $selectScroll "right" 0
        -ap $selectScroll "bottom" 0 50

        -ap $weightScroll "top" 0 50
        -af $weightScroll "left" 0
        -af $weightScroll "right" 0
        -af $weightScroll "bottom" 0
        $scrollForm;

    formLayout -e
        -af $selectButton "top" 5
        -af $selectButton "left" 5
        -ap $selectButton "right" 5 100
        -af $selectButton "bottom" 5
        $buttonForm;
    
    formLayout -e 
        -af $checkBox "top" 5
        -af $checkBox "left" 5

        -af $maxField "top" 5
        -ac $maxField "left" 10 $checkBox

        -af $maxText "top" 5
        -ac $maxText "left" 5 $maxField

        -af $buttonForm "top" 0
        -ac $buttonForm "left" 15 $maxText
        -af $buttonForm "right" 0

        -ac $scrollForm "top" 0 $buttonForm
        -af $scrollForm "left" 0
        -af $scrollForm "right" 0
        -af $scrollForm "bottom" 0
        $form;
    
    $nasPaintValueCheckBox = $checkBox;
    $nasPaintValueSelectMax = $maxField;
    $nasPaintValueSelectScroll = $selectScroll;
    $nasPaintValueWeightScroll = $weightScroll;
    window -e -h 127 $window;
    showWindow $window;
}

//-------------------------------------------------------------nas_switchInfluence---------------------------------------------------------------------
global proc nas_switchInfluence() {
    global string $artSkinLastSelectedInfluence, $nas_switchInfluenceLastInf;
    string $skinCluster, $array[], $infs[], $currentInf, $unheldInfs[];
    
    $array = `ls -sl -long`;
    $skinCluster = `nas_getSkinCluster $array[0]`;
    if (size($skinCluster) == 0) error "Could not find skin cluster, please make sure that geo is selected";
    $infs = `skinCluster -q -inf $skinCluster`;
    for ($inf in $infs) {
        artSkinInflListChanging $inf 0;
        if (`getAttr ($inf + ".liw")` == 0) $unheldInfs[size($unheldInfs)] = $inf;
    }
    if (size($unheldInfs) < 2) error "unable to switch influences because either one or no joints were unheld";
    
    if (size($nas_switchInfluenceLastInf)) {
        for ($i = 0; $i < size($unheldInfs); $i++) {
            if ($unheldInfs[$i] == $nas_switchInfluenceLastInf) {
                if ($i == size($unheldInfs)-1) $currentInf = $unheldInfs[0];
                else $currentInf = $unheldInfs[$i+1];
                $nas_switchInfluenceLastInf = $currentInf;
                break;
            }
        }
    }
    
    if ($nas_switchInfluenceLastInf == "" || $currentInf == "") {
        $currentInf = $unheldInfs[0];
        $nas_switchInfluenceLastInf = $currentInf;
    }
    
    artSkinInflListChanging $currentInf 1;
    artSkinSelectInfluence("artAttrSkinPaintCtx", $currentInf);
    artSkinInflListChanged artAttrSkinPaintCtx;
    
    print ("Current Paint Influence = " + $currentInf);
}

//-------------------------------------------------------------nas_scrollModel---------------------------------------------------------------------
global proc nas_scrollModel(string $axis, float $value, int $absolute) {
    string $verts[], $joints[], $uJoints[], $array[], $skinCluster, $sels[];
    float $wp[], $vertWp[], $finalWp[];
    
    $sels = `ls -sl -fl`;
    for ($sel in $sels) if (`gmatch $sel "*.vtx*"`) $verts[size($verts)] = $sel;
    $wp = `xform -ws -q -translation $verts[size($verts)-1]`;
    
    for ($i = 0; $i < size($verts); $i++) {
        $vertWp = `xform -ws -q -translation $verts[$i]`;
        if ($absolute) {
            for ($j = 0; $j < 3; $j++) {
                if ($axis == "x" && $j == 0) $finalWp[$j] = $wp[$j] + $value;
                else if ($axis == "y" && $j == 1) $finalWp[$j] = $wp[$j] + $value;
                else if ($axis == "z" && $j == 2) $finalWp[$j] = $wp[$j] + $value;
                else $finalWp[$j] = $vertWp[$j];
            }
        } else {
            for ($j = 0; $j < 3; $j++) {
                if ($axis == "x" && $j == 0) $finalWp[$j] = $vertWp[$j] + $value;
                else if ($axis == "y" && $j == 1) $finalWp[$j] = $vertWp[$j] + $value;
                else if ($axis == "z" && $j == 2) $finalWp[$j] = $vertWp[$j] + $value;
                else $finalWp[$j] = $vertWp[$j];
            }
        }
        move -ws $finalWp[0] $finalWp[1] $finalWp[2] $verts[$i];
    }
}

global proc nas_scrollModelCmd(int $mode) {
    global string $nasScrollModelAbsolute, $nasScrollModelScroll, $nasScrollModelScroll2, $nasScrollModelScroll3, $nasScrollModelMax;
    global float $nasScrollStartTime;
    global int $nasScrollModelSelectForce;
    string $axis, $scroll;
    float $timing, $increment, $colors[], $max;
    
    $max = `floatField -q -v $nasScrollModelMax`/100.0;
    
    if ($mode == 1) $scroll = $nasScrollModelScroll;
    else if ($mode == 2) $scroll = $nasScrollModelScroll2;
    else if ($mode == 3) $scroll = $nasScrollModelScroll3;
    
        $colors = `floatScrollBar -q -backgroundColor $scroll`;
        if ($colors[0]) $axis = "x";
        if ($colors[1]) $axis = "y";
        if ($colors[2]) $axis = "z";
    
    $timing = `timerX -st $nasScrollStartTime`;
    //print ("\n" + $timing);
    if ($timing > .01) $increment = .01 / ($timing/$max);
    else $increment = $max;
    if (`floatScrollBar -q -v $scroll ` > .5) $increment *= -1.0;
    
    nas_scrollModel $axis $increment `checkBox -q -v $nasScrollModelAbsolute`;
    $nasScrollStartTime = `timerX`;
}

global proc nas_scrollModelSelectCmd() {
    global string $nasScrollModelSelectScroll, $nasTraverseAnchor, $nasTraverseLastAnchor;
    global float $nasScrollStartTime;
    global int $nasTraverseSearch, $nasTraverseDir;
    string $sels[], $vert, $verts[], $nonVerts[], $parts[];
    float $timing, $increment, $max;
    int $dir, $twoVertsFound;
    
    $sels = `ls -sl -fl -long`;
    for ($i = 0; $i < size($sels); $i++) {
        if (`gmatch $sels[$i] "*.vtx*"` == 0) $nonVerts[size($nonVerts)] = $sels[$i];
        else $verts[size($verts)] = $sels[$i];
    }
    if (size($verts) > 1) {
        undo;
        $array = stringToStringArray(`undoInfo -q -undoName`, " ");
        catchQuiet(`redo`);
        if (`gmatch $array[size($array)-1] "*vtx*"`) {
            for ($i = 0; $i < size($verts); $i++) {
                $parts = stringToStringArray($verts[$i], "|");
                if ($parts[size($parts)-1] == $array[size($array)-1]) {
                    $nasTraverseAnchor = $verts[$i];
                    break;
                }
            }
            $verts = stringArrayRemove({$nasTraverseAnchor}, $verts);
            $twoVertsFound = 1;
        } else {
            error "Please make sure you use the select tool to select verts instead of a tool or undo.";
        }
    }
    $vert = $verts[0];
    if (`floatScrollBar -q -v $nasScrollModelSelectScroll` < .5) $dir = -1.0;
    else $dir = 1.0;
    
    if ($nasTraverseSearch) {
        nas_traverseCycleNeighbors $dir;
    } else {
        if ($twoVertsFound) {
            if ($dir == -1) {
                select -r $vert $nonVerts;
                $nasTraverseAnchor = `nas_traverse`;
                select -r $vert $nonVerts;
                nas_traverse;
            } else if ($dir == 1) {
                select -r $vert $nonVerts;
            }
        } else {
            if ($dir != $nasTraverseDir) {
                select -r $vert $nonVerts;
                $nasTraverseAnchor = `nas_traverse`;
            }
            select -r $vert $nonVerts;
            nas_traverse;
        }
        $nasTraverseDir = $dir;
    }
    $nasScrollStartTime = `timerX`;
}

global proc nas_scrollModelSwitchAxis(string $axis) {
    global string $nasScrollModelScroll, $nasScrollModelScroll2, $nasScrollModelScroll3, $nasScrollModelLastAxis[];
    float $axes[], $colors1[], $colors2[], $colors3[];
    
    $axes = `nas_axisToVector $axis`;
    floatScrollBar -e -backgroundColor $axes[0] $axes[1] $axes[2] $nasScrollModelScroll;
    
    if ($nasScrollModelLastAxis[0] != $axis) {
        $axes = `nas_axisToVector $nasScrollModelLastAxis[0]`;
        floatScrollBar -e -backgroundColor $axes[0] $axes[1] $axes[2] $nasScrollModelScroll2;
    }
    
    $colors1 = `floatScrollBar -q -backgroundColor $nasScrollModelScroll`;
    $colors2 = `floatScrollBar -q -backgroundColor $nasScrollModelScroll2`;
    for ($i = 0; $i < 3; $i++) $colors3[$i] = 1 - ($colors1[$i] + $colors2[$i]);
    floatScrollBar -e -backgroundColor $colors3[0] $colors3[1] $colors3[2] $nasScrollModelScroll3;
    
    $nasScrollModelLastAxis[1] = $nasScrollModelLastAxis[0];
    $nasScrollModelLastAxis[0] = $axis;
}

global proc nas_scrollModelSnapshot(int $mode) {
    global string $nasScrollModelSnapshotScroll, $nasScrollModelSnapshotBaseVerts[], $nasScrollModelSnapshotTargetVerts[], $nasScrollModelSnapshotTargetGeo, $nasScrollModelSnapshotBaseGeo, 
    $nasScrollModelSnapshotWorkVerts[];
    global int $nasScrollModelNew;
    global float $nasScrollModelSnapshotBaseWp[], $nasScrollModelSnapshotTargetWp[], $nasScrollModelSnapshotWorkWp[];
    string $sels[], $verts[], $xforms[], $array[], $baseVerts[], $targetVerts[], $workVerts[];
    float $multiple, $baseWp[], $targetWp[], $wp[], $workWp[];
    
    $baseVerts = $nasScrollModelSnapshotBaseVerts;
    $targetVerts = $nasScrollModelSnapshotTargetVerts;
    $workVerts = $nasScrollModelSnapshotWorkVerts;
    $baseWp = $nasScrollModelSnapshotBaseWp;
    $targetWp = $nasScrollModelSnapshotTargetWp;
    $workWp = $nasScrollModelSnapshotWorkWp;
    
    if ($mode == 0) {
        clear $nasScrollModelSnapshotBaseVerts;
        clear $nasScrollModelSnapshotBaseWp;
        $sels = `ls -sl -long -fl`;
        $array = stringToStringArray($sels[0], ".");
        $nasScrollModelSnapshotBaseGeo = $array[0];
        
        $verts = `ls -long -fl ($array[0] + ".vtx[*]")`;
        $nasScrollModelSnapshotBaseWp = `xform -ws -q -translation $verts`;
        for ($i = 0; $i < size($verts); $i++) {
            $array = stringToStringArray($verts[$i], ".");
            $nasScrollModelSnapshotBaseVerts[$i] = $array[1];
        }
        $array = stringToStringArray($sels[0], "|");
        print ("Snapshot of \"" + $array[size($array)-1] + "\" taken. Model away!");
    } else if ($mode == 1) {
        clear $nasScrollModelSnapshotTargetVerts;
        clear $nasScrollModelSnapshotTargetWp;
        $sels = `ls -sl -long -fl`;
        $array = stringToStringArray($sels[0], ".");
        $nasScrollModelSnapshotTargetGeo = $array[0];
        
        if (!`objExists $nasScrollModelSnapshotBaseGeo`) error "Please make a snapshot of your base geo first.";
        $verts = `nas_alteredVerts $nasScrollModelSnapshotBaseGeo $nasScrollModelSnapshotTargetGeo`;
        $nasScrollModelSnapshotTargetWp = `xform -ws -q -translation $verts`;
        $baseVerts = $nasScrollModelSnapshotBaseVerts;
        $wp = $nasScrollModelSnapshotBaseWp;
        clear $nasScrollModelSnapshotWorkVerts;
        clear $nasScrollModelSnapshotWorkWp;
        
        for ($i = 0; $i < size($verts); $i++) {
            $array = stringToStringArray($verts[$i], ".");
            $nasScrollModelSnapshotTargetVerts[$i] = $array[1];
            for ($j = 0; $j < size($baseVerts); $j++) {
                if ($nasScrollModelSnapshotTargetVerts[$i] == $baseVerts[$j]) {
                    $nasScrollModelSnapshotWorkVerts[size($nasScrollModelSnapshotWorkVerts)] = $baseVerts[$j];
                    for ($k = 0; $k < 3; $k++) $nasScrollModelSnapshotWorkWp[size($nasScrollModelSnapshotWorkWp)] = $wp[$j*3+$k];
                    stringArrayRemove({$baseVerts[$j]}, $baseVerts);
                    break;
                }
            }
        }
        
        $array = stringToStringArray($nasScrollModelSnapshotTargetGeo, "|");
        if (size($nasScrollModelSnapshotWorkVerts) == size($nasScrollModelSnapshotTargetVerts)) print ("Modeled verts for \"" + $array[size($array)-1] + "\" acquired. Slider ready!");
        else print ("Modeled verts for \"" + $array[size($array)-1] + "\" acquired. Please take a snapshot of base geo before using slider.");
    } else if ($mode == 2) {
        if (size($nasScrollModelSnapshotWorkVerts) != size($nasScrollModelSnapshotTargetVerts)) error "Please make sure that your base geo and your target geo have the same number of verts.";
        $multiple = `floatScrollBar -q -value $nasScrollModelSnapshotScroll`;
        for ($i = 0; $i < size($targetVerts); $i++) {
            for ($j = 0; $j < 3; $j++) $wp[$j] = $workWp[$i*3+$j] + ($multiple * ($targetWp[$i*3+$j] - $workWp[$i*3+$j]));
            move -ws $wp[0] $wp[1] $wp[2] ($nasScrollModelSnapshotTargetGeo + "." + $targetVerts[$i]);
        }
    }
}

global proc nas_scrollModelUI() {
    global string $nasScrollModelAbsolute, $nasScrollModelSelectScroll, $nasScrollModelScroll, $nasScrollModelScroll2, $nasScrollModelScroll3, $nasScrollModelMax, $nasScrollModelSnapshotScroll;
    global int $nasNeighborsStartTime = 0;
    string $window, $form, $checkBox, $edgeButton, $selectScroll, $modelScroll, $modelScroll2, $modelScroll3, $maxField, $maxText, $snapshotButton, $snapshotScroll;
    
    $window = `nas_window "nas_scrollModel" 0 0 1`;
    $form = `formLayout`;
    $checkBox = `checkBox -h 24 -v 0 -l "Absolute"`;
    $maxText = `text -h 20 -label "Sensitivity"`;
    $maxField = `floatField -h 20 -min .0000000001 -value 1`; 
    //$edgeButton = `button -label "Select Edges" -c "select -cl; SelectEdgeLoopTool"`;
    $buttonForm = `formLayout`;
        $selectButton = `button -label "Select" -c "nas_traverseSelection \"select\";" -ann "Selects non-verts that were stored by right clicking and going to \"Store\" on this button."`;
        nas_markingMenu 3 "" {
            "Store", "nas_traverseSelection \"store\";", "W", "0", "Stores non-vert selections.",
            "Non-Verts", "nas_traverseSelection \"select\";", "N", "0", "Stores non-vert selections.",
            "Paint Verts", "nas_traverseSelection \"paint\";", "E", "0", "Stores non-vert selections."};
        setParent..;
    $snapshotBase = `button -w 60 -h 30 -label "Snapshot" -c "nas_scrollModelSnapshot 0"`;
    $snapshotScroll = `floatScrollBar -h 30 -min 0 -max 1 -value 1 -step .01 -largeStep .1 -changeCommand "nas_scrollModelSnapshot 2"`;
    $snapshotTarget = `button -w 60 -h 30 -label "Model" -c "nas_scrollModelSnapshot 1"`;
    $selectScroll = `floatScrollBar -h 70 -min 0 -max 1 -value 0 -step .6 -largeStep .6 -changeCommand "nas_scrollModelSelectCmd"`;
    nas_markingMenu 3 "" {
        "Replace", "", "N", "0", "Switches selection mode to replace.", 
        "Add", "", "S", "0", "Switches selection mode to additive.", 
        "Direction", "nas_traverseStoreNeighbors;", "W", "0", "Switches select scroll to find neighbor mode.", 
        "Go", "global int $nasTraverseSearch = 0;", "E", "0", "Switches select scroll to find traverse mode."};
    $modelScroll = `floatScrollBar -backgroundColor 1 0 0 -h 50 -min 0 -max 1 -value 0 -step .6 -largeStep .6 -changeCommand "nas_scrollModelCmd 1"`;
    nas_markingMenu 3 "" {
        "X", "nas_scrollModelSwitchAxis x", "W", "0", "Switches scroll model mode to x axis.", 
        "Y", "nas_scrollModelSwitchAxis y", "N", "0", "Switches scroll model mode to y axis.", 
        "Z", "nas_scrollModelSwitchAxis z", "E", "0", "Switches scroll model mode to z axis."};
    $modelScroll2 = `floatScrollBar -backgroundColor 0 1 0 -h 50 -min 0 -max 1 -value 0 -step .6 -largeStep .6 -changeCommand "nas_scrollModelCmd 2"`;
    $modelScroll3 = `floatScrollBar -backgroundColor 0 0 1 -h 50 -min 0 -max 1 -value 0 -step .6 -largeStep .6 -changeCommand "nas_scrollModelCmd 3"`;
    
    formLayout -e 
        -af $checkBox "top" 5
        -af $checkBox "left" 5
        
        -af $maxField "top" 5
        -ac $maxField "left" 20 $checkBox
        -ap $maxField "right" 0 50
        
        -af $maxText "top" 5
        -ac $maxText "left" 5 $maxField
        
        -af $buttonForm "top" 5
        -ac $buttonForm "left" 20 $maxText
        -af $buttonForm "right" 5
        
        -ac $selectScroll "top" 5 $buttonForm
        -af $selectScroll "left" 5
        -af $selectScroll "right" 5
        
        -ac $modelScroll "top" 5 $selectScroll
        -af $modelScroll "left" 5
        -af $modelScroll "right" 5
        
        -ac $modelScroll2 "top" 5 $modelScroll
        -af $modelScroll2 "left" 5
        -af $modelScroll2 "right" 5
        
        -ac $modelScroll3 "top" 5 $modelScroll2
        -af $modelScroll3 "left" 5
        -af $modelScroll3 "right" 5
        
        -ac $snapshotBase "top" 5 $modelScroll3
        -af $snapshotBase "left" 5
        
        -ac $snapshotTarget "top" 5 $modelScroll3
        -af $snapshotTarget "right" 5
        
        -ac $snapshotScroll "top" 5 $modelScroll3
        -ac $snapshotScroll "left" 5 $snapshotBase
        -ac $snapshotScroll "right" 5 $snapshotTarget
        $form;
    
    $nasScrollModelAbsolute = $checkBox;
    $nasScrollModelSelectScroll = $selectScroll;
    $nasScrollModelScroll = $modelScroll;
    $nasScrollModelScroll2 = $modelScroll2;
    $nasScrollModelScroll3 = $modelScroll3;
    $nasScrollModelMax = $maxField;
    $nasScrollModelSnapshotScroll = $snapshotScroll;
    
    showWindow $window;
}

//-------------------------------------------------------------nas_alteredVerts---------------------------------------------------------------------
global proc string[] nas_alteredVerts(string $geo1, string $geo2) {
    float $buffer = .001;
    string $sourceVerts[], $targetVerts[], $alteredVerts[];
    float $geo1Rp[], $geo2Rp[], $offset[], $sourceWp[], $targetWp[];
    
    $geo1Rp = `xform -q -ws -rp $geo1`;
    $geo2Rp = `xform -q -ws -rp $geo2`;
    $offset[0] = $geo2Rp[0] - $geo1Rp[0];
    $offset[1] = $geo2Rp[1] - $geo1Rp[1];
    $offset[2] = $geo2Rp[2] - $geo1Rp[2];

    $sourceVerts = `ls -fl ($geo1 + ".vtx[*]")`;
    $targetVerts = `ls -fl ($geo2 + ".vtx[*]")`;
    
    if (size($sourceVerts) != size($targetVerts)) error "Cannot find altered verts because point order is not the same on both geos.";

    $sourceWp = `xform -q -ws -translation $sourceVerts`;
    $targetWp = `xform -q -ws -translation $targetVerts`;
    
    for ($i = 0; $i < size($sourceVerts); $i++) {
        for ($j = 0; $j < 3; $j++) {
            $targetWp[$i*3+$j] -= $offset[$j];
            if (abs($sourceWp[$i*3+$j]-$targetWp[$i*3+$j]) > $buffer) {
                $alteredVerts[size($alteredVerts)] = $targetVerts[$i];
                break;
            }
        }
    }
    return $alteredVerts;
}

//-------------------------------------------------------------nas_createSmoothProxyShaders---------------------------------------------------------------------
global proc nas_createSmoothProxyShaders() {
    string $shaders[], $proxyShaders[], $array[], $meshes[], $smoothproxies[];
    float $colors[];
    
    $shaders = `ls -sl`;
    for ($i = 0; $i < size($shaders); $i++) {
        $array = stringToStringArray($shaders[$i], "_");
        $array[0] = "SmoothProxy";
        $proxyShaders[$i] = `shadingNode -asShader lambert`;
        $proxyShaders[$i] = `rename $proxyShaders[$i] (stringArrayToString($array, "_"))`;
        if (`objExists ($shaders[$i] + ".color")`) $colors = `getAttr ($shaders[$i] + ".color")`;
        else if (`objExists ($shaders[$i] + ".diffuse")`) $colors = `getAttr ($shaders[$i] + ".diffuse")`;
        setAttr ($proxyShaders[$i] + ".color") $colors[0] $colors[1] $colors[2];
        hyperShade -objects $shaders[$i];
        $meshes = `ls -sl -fl`;    
        clear $smoothproxies;
        for ($mesh in $meshes) {
        $array = stringToStringArray($mesh, "_");
        for ($item in $array) {
            if ($item == "SmoothProxy") {
            $smoothproxies[size($smoothproxies)] = $mesh;
            break;
            }
        }
        }
        select -r $smoothproxies;
        hyperShade -assign $proxyShaders[$i];
    }
}

//-------------------------------------------------------------nas_duplicate---------------------------------------------------------------------
global proc nas_duplicate() {
    string $sels[], $names[], $array[], $dupes[], $group, $childs[], $attrs[];
    
    $attrs = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"};
    
    $sels = `ls -sl -long`;
    select -r $sels;
    performDuplicate false;
    $dupes = `ls -sl -long`;
    
    for ($i = 0; $i < size($sels); $i++) {
        for ($attr in $attrs) setAttr -lock 0 ($dupes[$i] + "." + $attr);
        if (`nodeType $dupes[$i]` == "transform") {
            $array = stringToStringArray($dupes[$i], "|");
            catchQuiet(`parent -w $dupes[$i]`);
            $dupes[$i] = $array[size($array)-1]; 
            $group = `group -em`;
            parent $dupes[$i] $group;
            setAttr ($group + ".sx") -1;
            catchQuiet(`parent -w $dupes[$i]`);
            $childs = `listRelatives -type transform -ad -fullPath $dupes[$i]`;
            for ($child in $childs) for ($attr in $attrs) setAttr -lock 0 ($child + "." + $attr);
            catchQuiet(`makeIdentity -apply true -t 0 -r 0 -s 1 $dupes[$i]`);
            delete $group;
        }
        $array = stringToStringArray($sels[$i], "|");
        $dupes[$i] = `rename $dupes[$i] (substitute("LT", $array[size($array)-1], "RT"))`;
    }
    select -r $dupes;
    print "\n";
    print "Duplicated to other side and renaming LT to RT.";
}

//-------------------------------------------------------------nas_slideAttrsUI---------------------------------------------------------------------
global proc nas_slideAttrsUI() {
    global string $nasSlideAttrsSlider, $nasSlideAttrsAbsolute, $nasSlideAttrsTextScroll, $nasSlideAttrsWindow, $nasSlideAttrsShortNames[], $nasSlideAttrsSliderMin, $nasSlideAttrsSliderMax;
    global float $nasSlideAttrsSensitivity;
    global int $nasSlideAttrsScriptJob;
    string $window, $slider, $form, $checkbox, $buttonForm, $plusButton, $minusButton, $minText, 
    $maxText, $textScroll, $cmd, $sels[], $frame;
    $nasSlideAttrsSensitivity = 1;

    $sels = `ls -sl -long -type transform`;
    
    $window = `nas_window "nas_slideAttrs" 0 0 1`;
    $form = `formLayout`;
        $checkbox = `checkBox -h 24 -label "Absolute" -v 0`;
        $buttonForm = `formLayout`;
            //$undoButton = `button -label "Undo" -c "nas_slideAttrsFuncs \"undo\""`;
            $minusButton = `button -label "-" -c "nas_slideAttrsFuncs \"minus\""`;
            $plusButton = `button -label "+" -c "nas_slideAttrsFuncs \"plus\""`;
            setParent..;
        $frame = `frameLayout -labelVisible false -borderStyle "etchedIn" -collapsable false`;
            $slider = `floatSlider -bgc 0 .8 0 -min -1 -max 1 -cc "nas_slideAttrsFuncs \"change\"" -dc "nas_slideAttrsFuncs \"drag\"" -parent $frame`;
            setParent..;
        $minText = `floatField -precision 1 -max -.001 -w 45 -h 26 -v -1.0 -cc "nas_slideAttrsFuncs \"updateMin\""`;
        $maxText = `floatField -precision 1 -min .001 -w 45 -h 26 -v 1.0 -cc "nas_slideAttrsFuncs \"updateMax\""`;
        $cmd = "textScrollList -fn boldLabelFont -allowMultiSelection true";
        if (size($sels)) {
            for ($attr in `listAttr -u -k -v -sa $sels[size($sels)-1]`) $cmd += (" -append \"" + `attributeName -nice ($sels[size($sels)-1] + "." + $attr)` + "\"");
            $nasSlideAttrsShortNames = `listAttr -u -k -v -sa $sels[size($sels)-1]`;
        }
        $textScroll = eval($cmd);
        nas_markingMenu 3 "" {"Shoot Out", "nas_slideAttrsFuncs \"shoot out\"", "W", "0", "",
                "Default", "nas_slideAttrsFuncs \"default\"", "E", "0", "",
                "Zero", "nas_slideAttrsFuncs \"zero\"", "S", "0", "",
                "One", "nas_slideAttrsFuncs \"one\"", "N", "0", ""};
        
        //if (`scriptJob -exists $nasSlideAttrsScriptJob`) scriptJob -kill $nasSlideAttrsScriptJob;
        nas_killJob "nas_slideAttrsFuncs";
        $nasSlideAttrsScriptJob = `scriptJob -event SelectionChanged "nas_slideAttrsFuncs \"update\""`;
    
    formLayout -e 
        -af $checkbox "top" 5
        -af $checkbox "left" 5
        
        -af $buttonForm "top" 5
        -ac $buttonForm "left" 5 $checkbox
        -af $buttonForm "right" 5

        -ac $minText "top" 5 $buttonForm
        -af $minText "left" 5
        
        -ac $maxText "top" 5 $buttonForm
        -af $maxText "right" 5
        
        -ac $frame "top" 5 $buttonForm
        -ac $frame "left" 0 $minText
        -ac $frame "right" 0 $maxText

        -ac $textScroll "top" 5 $frame
        -af $textScroll "left" 5
        -af $textScroll "right" 5
        -af $textScroll "bottom" 5
        $form;
        
    formLayout -e
        -af $minusButton "top" 0
        -af $minusButton "left" 0
        -ap $minusButton "right" 0 50
        -af $minusButton "bottom" 0
        
        -af $plusButton "top" 0
        -ap $plusButton "left" 0 50
        -af $plusButton "right" 0
        -af $plusButton "bottom" 0
        $buttonForm;
        
    $nasSlideAttrsSlider = $slider;
    $nasSlideAttrsAbsolute = $checkbox;
    $nasSlideAttrsMin = $minText;
    $nasSlideAttrsMax = $maxText;
    $nasSlideAttrsTextScroll = $textScroll;
    $nasSlideAttrsWindow = $window;
    
    $nasSlideAttrsSliderMin = $minText;
    $nasSlideAttrsSliderMax = $maxText;
    
    showWindow $window;
}
    
global proc nas_slideAttrsFuncs(string $mode) {
    global string $nasSlideAttrsSlider, $nasSlideAttrsAbsolute, $nasSlideAttrsPlugs[], 
    $nasSlideAttrsTextScroll, $nasSlideAttrsWindow, $nasSlideAttrsShortNames[], $nasSlideAttrsSliderMin, $nasSlideAttrsSliderMax;
    global float $nasSlideAttrsPlugValues[], $nasSlideAttrsSensitivity;
    global int $nasSlideAttrsStored, $nasSlideAttrsScriptJob, $nasSlideAttrsUndoOff;
    
    string $sels[], $attrs[], $plugs[], $slider, $cmd, $textScroll;
    float $value, $plugValues[], $values[], $sensitivity, $min, $max, $newValue;
    int $absolute, $indexes[], $hasMinMax, $isDefault;
    
    if (!`window -exists $nasSlideAttrsWindow`) return;
    
    
    $slider = $nasSlideAttrsSlider;
    $sensitivity = $nasSlideAttrsSensitivity;
    $textScroll = $nasSlideAttrsTextScroll;
    
    $absolute = `checkBox -q -v $nasSlideAttrsAbsolute`;
    $value = `floatSlider -q -v $slider`;
    $indexes = `textScrollList -q -sii $textScroll`;
    for ($i = 0; $i < size($indexes); $i++) $attrs[$i] = $nasSlideAttrsShortNames[$indexes[$i]-1];
    
    $sels = `ls -sl -type transform -long`;
    
    if ($mode == "store") {
        for ($sel in $sels) {
            for ($attr in $attrs) {
                if (`objExists ($sel + "." + $attr)`) {
                    $plugs[size($plugs)] = ($sel + "." + $attr);
                    $plugValues[size($plugValues)] = `getAttr ($sel + "." + $attr)`;
                }
            }
        }
        $nasSlideAttrsPlugs = $plugs;
        $nasSlideAttrsPlugValues = $plugValues;
        $nasSlideAttrsStored = 1;
    } else if ($mode == "drag" || $mode == "change") {
        if ($mode == "drag") {
            if ($nasSlideAttrsUndoOff == 0) {
                undoInfo -openChunk;
                $nasSlideAttrsUndoOff = 1;
            }
            if ($nasSlideAttrsStored == 0) nas_slideAttrsFuncs "store";
            $plugs = $nasSlideAttrsPlugs;
            $values = $nasSlideAttrsPlugValues;
            for ($i = 0; $i < size($plugs); $i++) {
                $isDefault = 0;
                $array = stringToStringArray($plugs[$i], ".");
                //print ("\n" + $array[1]);
                for ($attr in {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v", "translateX", "translateY", "translateZ", "rotateX", "rotateY", "rotateZ", "scaleX", "scaleY", "scaleZ", "visibility"}) {
                    if ($array[1] == $attr) $isDefault = 1;
                }
                if ($isDefault == 0) {
                    if (`addAttr -q -hasMinValue $plugs[$i]`) $min = `addAttr -q -min $plugs[$i]`;
                    else $min = -1000000000; 
                    if (`addAttr -q -hasMaxValue $plugs[$i]`) $max = `addAttr -q -max $plugs[$i]`;
                    else $max = 1000000000;
                } else {
                    $min = -1000000000;
                    $max = 1000000000;
                }
                if ($absolute) $newValue = ($values[size($values)-1] + $value);
                else $newValue = ($values[$i] + $value);
                
                if ($newValue < $min) $newValue = $min;
                else if ($newValue > $max) $newValue = $max;
                catchQuiet(`setAttr $plugs[$i] $newValue`);
            }
        } else if ($mode == "change") {
            if ($nasSlideAttrsUndoOff == 1) {
                undoInfo -closeChunk;
                $nasSlideAttrsUndoOff = 0;
            }
            $nasSlideAttrsStored = 0;
            floatSlider -e -v 0 $slider;
        }
    } else if ($mode == "minus" || $mode == "plus") {
        if ($mode == "minus") $sensitivity /=2.0;
        else if ($mode == "plus") $sensitivity *=2.0;
        
        floatSlider -e -min (-1*$sensitivity) -max $sensitivity $slider;
        floatField -e -v (-1*$sensitivity) $nasSlideAttrsSliderMin;
        floatField -e -v $sensitivity $nasSlideAttrsSliderMax;
        
        floatSlider -e -vis off $slider;
        if ($sensitivity == 1) floatSlider -e -bgc 0 .8 0 $slider;
        else if ($sensitivity > 1) floatSlider -e -bgc 1 (1-(log($sensitivity)/log(2)/8.0)) 0 $slider;
        else if ($sensitivity < 1) floatSlider -e -bgc 0 (1-(log($sensitivity)/log(2)/-8.0)) 1 $slider;
        floatSlider -e -vis on $slider;
        $nasSlideAttrsSensitivity = $sensitivity;
    } else if ($mode == "update") {
        if (`textScrollList -exists $textScroll`) {
            textScrollList -e -ra $textScroll;
            if (size($sels)) {
                $cmd = "textScrollList -e";
                for ($attr in `listAttr -u -k -v -sa $sels[size($sels)-1]`) $cmd += (" -append \"" + `attributeName -nice ($sels[size($sels)-1] + "." + $attr)` + "\"");
                eval($cmd + " " + $textScroll);
                $nasSlideAttrsShortNames = `listAttr -u -k -v -sa $sels[size($sels)-1]`;
            }
        }
    } else if ($mode == "shoot out" || $mode == "default" || $mode == "one" || $mode == "zero") {
        for ($sel in $sels) {
            if ($mode == "shoot out") {
                for ($attr in {"tx", "ty", "tz", "rx", "ry", "rz"}) catchQuiet(`setAttr ($sel + "." + $attr) 99`);
                for ($attr in {"sx", "sy", "sz"}) catchQuiet(`setAttr ($sel + "." + $attr) .1`);
            } else if ($mode == "default") {
                for ($attr in {"tx", "ty", "tz", "rx", "ry", "rz"}) catchQuiet(`setAttr ($sel + "." + $attr) 0`);
                for ($attr in {"sx", "sy", "sz"}) catchQuiet(`setAttr ($sel + "." + $attr) 1`);
            } else if ($mode == "one") {
                for ($attr in $attrs) catchQuiet(`setAttr ($sel + "." + $attr) 1`);
            } else if ($mode == "zero") {
                for ($attr in $attrs) catchQuiet(`setAttr ($sel + "." + $attr) 0`);
            }
        }   
    } else if ($mode == "updateMin" || $mode == "updateMax") {
        if ($mode == "updateMin") {
            $value = `floatField -q -v $nasSlideAttrsSliderMin`;
            floatSlider -e -min $value -max (-1*$value) $slider;
            floatField -e -v (-1*$value) $nasSlideAttrsSliderMax;
        } else if ($mode == "updateMax") {
            $value = `floatField -q -v $nasSlideAttrsSliderMax`;
            floatSlider -e -min (-1*$value) -max $value $slider;
            floatField -e -v (-1*$value) $nasSlideAttrsSliderMin;
        }
    }
    return;
}

//-------------------------------------------------------------nas_killJob---------------------------------------------------------------------
//kills script jobs that contain input string
//only nas commands will be searched for
global proc nas_killJob(string $cmd) {
    string $array[], $jobs[];
    int $nums[];
    
    if (`gmatch $cmd "*nas*"` == 0) error "\nThis tool only deletes script jobs that run nas commands.";
    $cmd = ("*" + $cmd + "*");
    $jobs = `scriptJob -lj`;
    for ($job in $jobs) {
        if (`gmatch $job $cmd` == 1) {
            $array = stringToStringArray($job, ":");
            $nums[size($nums)] = $array[0];
        }
    }
    if (size($nums) == 0) {
            print ("No jobs that run " + $cmd + " were found.");
    } else {
        for ($num in $nums) {
        scriptJob -kill $num;
        print "\n";
        print ("Killed job number " + $num + " which runs " + $cmd);
        }
    }
}

//-------------------------------------------------------------nas_cycleSelectMode---------------------------------------------------------------------
global proc nas_cycleSelectMode() {
    global float $nasCycleSelectStartTime;
    global int $nasCycleDisplayModeNum;
    float $time;
    int $num;
    
    $time = `timerX -st $nasCycleSelectStartTime`;
    if ($time > 5 && $nasCycleDisplayModeNum != 0) $nasCycleDisplayModeNum = 0;
    $num = $nasCycleDisplayModeNum % 4;
    
    
    if ($num == 0) {
        selectMode -object;
        print "object";
    } else {
        selectMode -component;
        if ($num == 1) {
            selectType -smp 1 -sme 0 -smf 0 -smu 0 -pv 1 -pe 0 -pf 0 -puv 0;
            print "vertices";
        } else if ($num == 2) {
            selectType -smp 0 -sme 1 -smf 0 -smu 0 -pv 0 -pe 1 -pf 0 -puv 0;
            print "edges";
        } else if ($num == 3) { 
            selectType -smp 0 -sme 0 -smf 1 -smu 0 -pv 0 -pe 0 -pf 1 -puv 0;
            print "faces";
        }
        select -cl;
    }
    $nasCycleSelectStartTime = `timerX`;
    $nasCycleDisplayModeNum++;
}

//-------------------------------------------------------------nas_timer---------------------------------------------------------------------
global proc nas_timer(string $action) {
    global string $nasTimerTaskName, $nasQuickTimerButton;
    global float $nasTimerStartTime, $nasTimerElapsedTime;
    string $result;
    float $time;
    
    if ($action == "start") {
        if (size($nasTimerTaskName)) {
            $result = `confirmDialog -title "Task in Progress!" -ma "center" -message ("You are in the middle of task - " + $nasTimerTaskName + ".\nWould you like to start a new task and end the current one?") -button "Start New" -button "Continue Current" -defaultButton "Continue Current"`;
            if ($result == "Start New") nas_timer "end";
            else return;
        }
        $result = `promptDialog -title "Task Name" -ma "center" -message "Please enter the name of the task you are going to perform:" -text "skin_left_wrist" -button "Start Task" -button "Cancel" -defaultButton "Start Task" -cancelButton "Cancel" -dismissString "Cancel"`;
        if ($result == "Start Task") {
            $nasTimerTaskName = `promptDialog -q -text`;
            $nasTimerStartTime = `timerX`;
        }
        button -e -bgc 0 1 0 $nasQuickTimerButton;
    } else if ($action == "end") {
        if ($nasTimerTaskName == "") error "No task has been started. Please start a task before ending.";
        
        if ($nasTimerStartTime == 0) $time = $nasTimerElapsedTime;
        else $time = $nasTimerElapsedTime + `timerX -st $nasTimerStartTime`;
        
        print ("\n" + $nasTimerTaskName + ", " + $time + ", \n");
        print "\n";
        print ("\nFinished " + $nasTimerTaskName + " in " + `nas_timeFormat $time 0` + "\n");
        
        $nasTimerTaskName = "";
        $nasTimerElapsedTime = 0;
        $nasTimerStartTime = 0;
        button -e -bgc .38 .38 .38 $nasQuickTimerButton;
    } else if ($action == "pause") {
        if ($nasTimerStartTime > 0) {
            $nasTimerElapsedTime = `timerX -st $nasTimerStartTime`;
            $nasTimerStartTime = 0.0;
            print ("\nPaused task: " + $nasTimerTaskName + " at " + `nas_timeFormat $nasTimerElapsedTime 0` + ".\n");
        } else {
            error "\nNothing to pause. Please start a task.\n";
        }
        button -e -bgc 1 0 0 $nasQuickTimerButton;
    } else if ($action == "resume") {
        if (size($nasTimerTaskName)) {
            if ($nasTimerElapsedTime > 0 && $nasTimerStartTime == 0) {
                $nasTimerStartTime = `timerX`;
                print ("\nResumed task: " + $nasTimerTaskName + " from " + `nas_timeFormat $nasTimerElapsedTime 0` + ".\n");
            } else {
                error "\nNothing to resume. Please pause the current task.\n";
            }
        } else {
            error "\nNothing to resume. Please start a task.\n";
        }
        button -e -bgc 0 1 0 $nasQuickTimerButton;
    }
    button -e -vis off $nasQuickTimerButton;
    button -e -vis on $nasQuickTimerButton;
}

//-------------------------------------------------------------nas_paintSettings---------------------------------------------------------------------
global proc nas_paintSettings(string $type, float $value) {
    if ($type == "value") {
        artSkinSetSelectionValueIntermediate $value artAttrSkinPaintCtx "artAttrSkin";
        artSkinSetSelectionValue $value false artAttrSkinPaintCtx "artAttrSkin";
    } else if ($type == "opacity") {
        artAttrSkinPaintCtx -e -opacity $value artAttrSkinContext;
    }
}

global float $nasPaintSetValue = 0.1;
global float $nasPaintSetOpacity = 1.0;
global float $nasPaintSetStartTime = 0.0;
//-------------------------------------------------------------nas_paintSet---------------------------------------------------------------------
global proc nas_paintSet(string $type, float $dir) {
    global float $nasPaintSetValue, $nasPaintSetOpacity, $nasPaintSetStartTime;
    float $value, $opacity, $increment, $minTime, $maxTime, $minVal, $maxVal;
    string $incrementString, $opacityString, $valueString;

    $value = $nasPaintSetValue;
    $opacity = $nasPaintSetOpacity;

    $time = `timerX -st $nasPaintSetStartTime`;
    $minTime = .1;
    $maxTime = 2.0;
    $minVal = .001;
    $maxVal = .1;
    if ($time > $maxTime) $increment = $minVal;
    else if ($time > $minTime) $increment = $maxVal - (($time-$minTime)/($maxTime-$minTime) * ($maxVal-$minVal));
    else $increment = $maxVal;
    $increment *= $dir;

    if ($type == "value") {
        $value += $increment;
        if ($value < 0) $value = 0.0;
        else if ($value > 1) $value = 1.0;
        nas_paintSettings "value" $value;
    } else if ($type == "opacity") {
        $opacity += $increment;
        if ($opacity < 0) $opacity = 0.0;
        else if ($opacity > 1) $opacity = 1.0;        
        nas_paintSettings "opacity" $opacity;
    }
        
    $nasPaintSetValue = $value;
    $nasPaintSetOpacity = $opacity;
    $nasPaintSetStartTime = `timerX`;
    $increment = abs($increment);
    $incrementString = python("'%.3f' % (round(" + $increment + ", 3))");
    $opacityString = python("str(" + $opacity + "*100).split('.')[0]+'%'");
    $valueString = python("'%.3f' % (round(" + $value + ", 3))");
    print "\n";
    if ($dir > 0) {
        if ($type == "value") print ($valueString + "\t\t(+" + $incrementString + ")");
        else print ($opacityString + "\t\t(+" + $incrementString + ")");
    } else {
        if ($type == "value") print ($valueString + "\t\t(-" + $incrementString + ")");
        else print ($opacityString + "\t\t(-" + $incrementString + ")");
    }
}

//-------------------------------------------------------------nas_saveReminder---------------------------------------------------------------------
//pops up a window reminding you to save
global proc nas_saveReminder(int $reset) {
    global float $nasSaveReminderStartTime, $nas_saveReminderIncrement;
    string $result;
    float $elapsed;
    int $minutes;
    
    if ($reset) {
        $nasSaveReminderStartTime = `timerX`;
    } else {
        $elapsed = `timerX -st $nasSaveReminderStartTime`;
        $minutes = $elapsed/60;
        if ($elapsed > $nas_saveReminderIncrement) {
            $result = `confirmDialog -title "Save!!!!!" -message ("It's been " + $minutes + " minutes since your last save! Would you like me to save?") -button "Save" -button "Ignore" -defaultButton "Save" -cancelButton "Ignore"`;
            if ($result == "Save") file -force -save -options "v=0";
            $nasSaveReminderStartTime = `timerX`;
        }
    }
}

global proc nas_saveReminderFuncs(string $mode) {
    global float $nasSaveReminderStartTime, $nas_saveReminderIncrement;
    string $result, $amount;
    float $elapsed, $increment;
    int $minute;
    
    if ($mode == "increment") {
        if ($nas_saveReminderIncrement == 0) $nas_saveReminderIncrement = 900;
        $result = `promptDialog -text ($nas_saveReminderIncrement/60) -title "How Often?" -message "How many minutes between save reminders?" -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel"`;
        if ($result == "OK") {
            $amount = `promptDialog -q -text`;
            $minute = $amount;
            $nas_saveReminderIncrement = $minute*60;
            $nasSaveReminderStartTime = `timerX`;
            print ("You will be reminded to save in " + $minute + " minutes.");
        }
    } else if ($mode == "start") {
        nas_killJob "nas_saveReminder";
        nas_killJob "nasSaveReminderStartTime";
        scriptJob -event SelectionChanged "nas_saveReminder 0";
        scriptJob -event NameChanged "nas_saveReminder 0";
        scriptJob -event DagObjectCreated "nas_saveReminder 0";
        scriptJob -event deleteAll "nas_saveReminder 1";
        scriptJob -event NewSceneOpened "nas_saveReminder 1";
        scriptJob -event SceneOpened "nas_saveReminder 1";
        $nasSaveReminderStartTime = `timerX`;
        print "Save reminder tool started.";
    } else if ($mode == "end") {
        nas_killJob "nas_saveReminder";
        nas_killJob "nasSaveReminderStartTime";
        print "Save reminder tool ended.";
    }
}

//-------------------------------------------------------------nas_divideWeights---------------------------------------------------------------------
//select joint with weights followed by joints without weights selecting the farthest joint last followed by the geo and run
//make sure there are no weights on all joints except the first joint
global proc nas_divideWeights() {
    string $sels[], $joints[], $verts[], $skin, $geo, $allverts[], $jnts[], $unholds[];
    float $values[], $farray[], $allvalues[], $percent, $weight;
    int $jntsFound;
    
    $sels = `ls -sl -long`;
    $geo = $sels[size($sels)-1];
    $joints = stringArrayRemove({$geo}, $sels);
    
    select -r $joints $geo;
    nas_skinCluster;
    
    clear $values;
    $skin = `nas_getSkinCluster $geo`;
    $allverts = `ls -fl -long ($geo + ".vtx[*]")`;

    clear $verts;
    clear $values;
    for ($i = 0; $i < size($allverts); $i++) {
        $allvalues[$i] = `skinPercent -transform $joints[0] -query $skin $allverts[$i]`;
        if ($allvalues[$i] > 0) {
            $verts[size($verts)] = $allverts[$i];
            $values[size($values)] = $allvalues[$i];
        }
    }

    nas_progress (size($verts)) "start";
    for ($i = 0; $i < size($verts); $i++) {
        $jntsFound = 0;
        clear $jnts;
        for ($j = 1; $j < size($joints); $j++) {
            $farray = `nas_distanceBetween $verts[$i] $joints[$j-1] $joints[$j]`;
            if ($farray[0] != 0 && $farray[0] != 1) {
                $percent = $farray[0];
                $jnts[0] = $joints[$j-1];
                $jnts[1] = $joints[$j];
                $jntsFound = 1;
                break;
            }
        }
        if ($jntsFound == 0) {
            $farray = `nas_distanceBetween $verts[$i] $joints[0] $joints[size($joints)-1]`;
            $percent = $farray[0];
            $jnts[0] = $joints[0];
            $jnts[1] = $joints[size($joints)-1];
        }
            
        $weight = `skinPercent -t $joints[0] -q -v $skin $verts[$i]`;
        
        $unholds = {$joints[0], $jnts[0], $jnts[1]};
        for ($unhold in $unholds) setAttr ($unhold + ".liw") 0;
        setAttr ($skin + ".normalizeWeights") 0;
        skinPercent -normalize off $skin $verts[$i];
        
        skinPercent -normalize off -tv $joints[0] 0 $skin $verts[$i];
        skinPercent -normalize off -tv $jnts[0] ($percent * $weight) $skin $verts[$i];
        skinPercent -normalize off -tv $jnts[1] ((1-$percent) * $weight) $skin $verts[$i];
        
        for ($unhold in $unholds) setAttr ($unhold + ".liw") 1;
        setAttr ($skin + ".normalizeWeights") 1;
        skinPercent -normalize on $skin $verts[$i];
        if (`nas_progress 0 ("Dividing weights for " + $verts[$i])`) return;
    }
    nas_progress 0 "end";
}

//-------------------------------------------------------------nas_parentGroup---------------------------------------------------------------------
global proc string nas_parentGroup(string $childs[], string $group) {
    if (`objExists $group`) parent $childs $group;
    else group -n $group $childs;
    return $group;
}

//-------------------------------------------------------------nas_rigClustersFromWire---------------------------------------------------------------------
global proc nas_rigClustersFromWire() {
    string $ctrls[], $verts[], $curve, $wire, $sels[], $geo, $cvs[], $array[], 
    $name, $parts[], $basewire, $clusters[], $temp, $group, $groups[], $geos[];
    int $found;
    
    $sels = `ls -sl`;
    if (size($sels) == 0) error "Please select a curve by itself or a curve followed by geo to create clusters for every cv on curve.";

    $curve = $sels[0];
    $geos = stringArrayRemove({$curve}, $sels);
    $parts = stringToStringArray($curve, "_");
    for ($i = 0; $i < size($parts); $i++) {
        if ($parts[$i] != "Deformer") $array[$i] = $parts[$i];
        else break;
    }
    if (size($parts) == size($array)) error "Please name your curve with the word \"Deformer\" in it.";

    $name = stringArrayToString($array, "_");
    $curve = `rename $curve ($name + "_Deformer_01_Wire")`;
    $cvs = `ls -fl ($curve + ".cv[*]")`;

    if (size($sels) > 1) {
        for ($i = 0; $i < size($geos); $i++) $verts = stringArrayCatenate($verts, `ls ($geos[$i] + ".vtx[*]")`);
        $array = `wire -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w $curve -dds 0 500.0 $geos`;
        $wire = `rename $array[0] ($name + "_Wire")`;
        setAttr ($wire + ".rotation") 0;
    } else {
        $verts = `nas_getDeformerVerts $curve`;
        $array = `listHistory -pdo 1 -f 1 -il 1 $curve`;
        $wire = $array[0];
    }
    $basewire = `connectionInfo -sfd ($wire + ".baseWire[0]")`;
    $array = stringToStringArray($basewire, ".");
    $array = `listRelatives -p $array[0]`;
    $basewire = `rename $array[0] ($name + "_Deformer_01_BaseWire")`;
 
    select -r $cvs;
    $array = `cluster $cvs`;
    $ctrls[0] = $array[1];
    select -r $cvs;
    $ctrls = stringArrayCatenate($ctrls, `nas_clusters`);

    for ($i = 0; $i < size($ctrls); $i++) {
        select -r $ctrls[$i] $verts;
        $array = `nas_deformationToClusterInteractive 0`;
        $array[0] = `connectionInfo -sfd ($array[0] + ".matrix")`;
        $array = stringToStringArray($array[0], ".");
        $temp = `nas_framePadding ($name + "_Deformer_##_CL") ($i)`;
        $clusters[$i] = `rename $array[0] $temp`;
    }
    delete $ctrls;
    delete $wire $basewire $curve;
    select -r $clusters;
    $ctrls = `nas_controls curveCircle`;
    makeIdentity -apply true -t 1 -r 1 -s 1 $ctrls;
    for ($i = 0; $i < size($ctrls); $i++) {
        for ($attr in {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"}) {
            connectAttr -f ($ctrls[$i] + "." + $attr) ($clusters[$i] + "." + $attr);
        }
        setAttr -e -lock on -channelBox off -keyable off ($ctrls[$i] + ".v");
    }
    select -r $clusters;
    nas_group 0 "Group";
    nas_groupGroups;
    select -r $ctrls;
    nas_colorControls "yellow" 1;
    $groups = `nas_group 0 "Group"`;
    nas_groupGroups;
    for ($i = 1; $i < size($groups); $i++) {
        parentConstraint -mo $ctrls[0] $groups[$i];
        scaleConstraint -mo $ctrls[0] $groups[$i];
    }
    select -r $ctrls;
}

//-------------------------------------------------------------nas_nurbsRider---------------------------------------------------------------------
//creates a locator that an animator can constrain to if an asset needs to travel along a nurbs surface
global proc nas_nurbsRider() {
    string $sels[], $points[], $plane, $node, $array[], $loc, $aimLoc, $upLoc, $aimpma, $uppma;
    
    $sels = `ls -sl -long`;
    $plane = $sels[0];
    
    $points[0] = `pointOnSurface -ch 1 $plane`;
    $points[1] = `pointOnSurface -ch 1 $plane`;
    $points[2] = `pointOnSurface -ch 1 $plane`;
    $array = `spaceLocator -p 0 0 0`;
    $loc = $array[0];
    $array = `spaceLocator -p 0 0 0`;
    $aimLoc = $array[0];
    $array = `spaceLocator -p 0 0 0`;
    $upLoc = $array[0];
    
    setAttr ($points[0] + ".turnOnPercentage") 1;
    setAttr ($points[1] + ".turnOnPercentage") 1;    
    setAttr ($points[2] + ".turnOnPercentage") 1;
    connectAttr ($points[0] + ".result.position") ($loc + ".translate");
    connectAttr ($points[1] + ".result.position") ($aimLoc + ".translate");
    connectAttr ($points[2] + ".result.position") ($upLoc + ".translate");
    
    addAttr -ln "SideToSide" -at double -min 0 -max 1 -dv 0 $loc;
    setAttr -e -keyable true ($loc + ".SideToSide");
    addAttr -ln "Travel" -at double -min 0 -max 1 -dv 0 $loc;
    setAttr -e -keyable true ($loc + ".Travel");
    connectAttr ($loc + ".SideToSide") ($points[0] + ".parameterU");
    connectAttr ($loc + ".Travel") ($points[0] + ".parameterV");
    
    $aimpma = `createNode plusMinusAverage`;
    $uppma = `createNode plusMinusAverage`;
    
    connectAttr ($loc + ".Travel") ($aimpma + ".input1D[0]");
    setAttr ($aimpma + ".input1D[1]") .001;
    connectAttr ($aimpma + ".output1D") ($points[1] + ".parameterV");
    connectAttr ($loc + ".SideToSide") ($uppma + ".input1D[0]");
    setAttr ($uppma + ".input1D[1]") .01;
    connectAttr ($uppma + ".output1D") ($points[2] + ".parameterU");
    
    aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "object" -worldUpObject $upLoc $aimLoc $loc;
    connectAttr ($points[0] + ".parameterU") ($points[1] + ".parameterU");
    connectAttr ($points[0] + ".parameterV") ($points[2] + ".parameterV");
    hide $aimLoc $upLoc;
}

//======================================================~DK~============================================================
//======================================================================================================================
//======================================================================================================================
//======================================================================================================================
//======================================================================================================================
//======================================================================================================================
//-------------------------------------------------------------dkRigging.mel---------------------------------------------------------------------

//=================================================================================================================================================================================

//-------------------------------------------------------------dkIsolate---------------------------------------------------------------------
//isolates selection and toggles back to showing all, options for adding and removing from isolation available
global proc dkIsolate(int $mode) {
    string $panels[] = `nas_getVisibleModelPanels`;
    if ($mode == 0) {
        for ($panel in $panels) {
            int $state = (1-`isolateSelect -q -state $panel`);
            enableIsolateSelect $panel $state;
            isolateSelect -state $state $panel;
            isoSelectAutoAddNewObjs $panel 1;
        }
    } else if ($mode == 1) {
        for ($panel in $panels) isolateSelect -addSelected $panel;
    } else if ($mode == -1) {
        for ($panel in $panels) isolateSelect -removeSelected $panel;
    }
}

//-------------------------------------------------------------dkEmulateAttrs---------------------------------------------------------------------
global proc dkEmulateAttrs(string $list) {
    string $attrs[], $sels[];
    float $value;
    $attrs = stringToStringArray($list, ", ");
    $sels = `ls -sl`;
    for ($sel in $sels) for ($attr in $attrs) {
        $value = `getAttr ($sels[0] + "." + $attr)`;
        setAttr ($sel + "." + $attr) $value;
    }
}

//-------------------------------------------------------------dkCapitalizeAxis---------------------------------------------------------------------
global proc string dkCapitalizeAxis(string $axis) {
    if ($axis == "x") $axis = "X";
    else if ($axis == "y") $axis = "Y";
    else if ($axis == "z") $axis = "Z";
    else if ($axis == "-x") $axis = "-X";
    else if ($axis == "-y") $axis = "-Y";
    else if ($axis == "-z") $axis = "-Z";
    return $axis;
}

//-------------------------------------------------------------dkLowercaseAxis---------------------------------------------------------------------
global proc string dkLowercaseAxis(string $axis) {
    if ($axis == "X") $axis = "x";
    else if ($axis == "Y") $axis = "y";
    else if ($axis == "Z") $axis = "z";
    else if ($axis == "-X") $axis = "-x";
    else if ($axis == "-Y") $axis = "-y";
    else if ($axis == "-Z") $axis = "-z";
    return $axis;
}

//-------------------------------------------------------------dkGetNonDefaultAttrs---------------------------------------------------------------------
//finds attrs that are not at their default value
global proc string[] dkGetNonDefaultAttrs() {
    string $sels[], $attrs[], $nonDefaultAttrs[];
    $sels = `ls -sl`;
    for ($sel in $sels) {
        $attrs = `listAttr -k $sel`;
        for ($attr in $attrs) {
            if (`gmatch $attr "scale*"` || `gmatch $attr "visibility"`) {
                if (`getAttr ($sel + "." + $attr)` != 1) $nonDefaultAttrs[size($nonDefaultAttrs)] = $attr;
            } else {
                if (`getAttr ($sel + "." + $attr)` != 0) $nonDefaultAttrs[size($nonDefaultAttrs)] = $attr;
            }
        }
    }
    return $nonDefaultAttrs;
}

//-------------------------------------------------------------dkGeneralistControls---------------------------------------------------------------------
//Z:\Fanboy\Maya_Fanboy\scenes\Default_Setups\Controllers
global proc int dkGeneralistControls(string $axis, int $createCog, float $transformScale, float $cogScale, int $stickies[], string $type, string $prod, int $cogFit) {
    string $array[], $groups[], $cog, $transform, $geos[], $group, $name, $parents[], $meshGroup, 
    $childs[], $controlGroup, $offsetNode, $projectNode, $worldNode, $groupNames[], $assetName, $numbers[];
    int $count;
    vector $axisVec;
    float $bb[], $edits[], $max, $centerWp[], $scale, $otherAxes[], $maxWidth;
    
    $geos = `ls -sl -long`;
    $bb = `nas_boundingBox $geos`;
    $array = `ls -sn $geos[0]`;
    $array = stringToStringArray($array[0], "_");
    if (size($array) > 1) {
        if ($array[size($array)-1] == "Geo" || $array[size($array)-1] == "geo") stringArrayRemoveAtIndex((size($array)-1), $array);
        $numbers = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"};        
        for ($i = size($array[size($array)-1]); $i > 0; $i--) {
            for ($number in $numbers) if (`substring $array[size($array)-1] $i $i` == $number) {
                $count++;
                break;
            }
        }
        $array[size($array)-1] = `startString $array[size($array)-1] (size($array[size($array)-1])-$count)`;
        if (size($array[size($array)-1]) == 0) stringArrayRemoveAtIndex((size($array)-1), $array);
        $assetName = stringArrayToString($array, "_");
    } else {
        $assetName = "could_not_determine_asset_name";
    }
    
    if (`promptDialog -t "dkGeneralistControlsName" -ma "center" -m "Name of BG Asset:" -tx $assetName -b "OK" -b "Cancel" -db "OK" -cb "Cancel" -ds "Cancel"` == "OK") $name = `promptDialog -q -tx`;
    else return 0;
    
    //create the hierarchy of the asset ctrl
    $projectNode = `group -n ($prod + "_" + $name) -em`;
    $worldNode = `group -n ("World_" + $name) -em`;
    parent $projectNode $worldNode;
    $groupNames = {"Controllers", "Geometry", "Skeleton", "Deformers"};
    for ($i=0; $i<size($groupNames); $i++) {
        $groups[$i] = `group -em`;
        parent $groups[$i] $projectNode;
        $groups[$i] = `rename $groups[$i] $groupNames[$i]`;
    }
    $offsetNode = `group -em`;
    parent $offsetNode $groups[0];
    $offsetNode = `rename $offsetNode "Offset"`;
    $meshGroup = `group -em`;
    parent $meshGroup $groups[1];
    $meshGroup = `rename $meshGroup ($name + "_Mesh_Group")`;
    $groupNames = {"HiRes", "LoRes", "Proxy"};
    for ($i=0; $i<size($groupNames); $i++) {
        $groups[$i] = `group -em`;
        parent $groups[$i] $meshGroup;
        $groups[$i] = `rename $groups[$i] $groupNames[$i]`;
    }
    parent $geos $groups[0];
    
    $axisVec = `nas_axisToVector $axis`;
    $otherAxes = {(1-($axisVec.x)), (1-($axisVec.y)), (1-($axisVec.z))};
    
    //gather info about center and max
    $centerWp = {(($bb[0]+$bb[3])/2), (($bb[1]+$bb[4])/2), (($bb[2]+$bb[5])/2)};
    $max = ($bb[3]-$bb[0]);
    if (($bb[4]-$bb[1]) > $max) $max = ($bb[4]-$bb[1]);
    if (($bb[5]-$bb[2]) > $max) $max = ($bb[5]-$bb[2]);
    if(($bb[3] - $bb[0]) > ($bb[5] - $bb[2])) $maxWidth = $bb[3] - $bb[0];
    else $maxWidth = $bb[5] - $bb[2];
    
    //make the transform
    if ($type == "BGAsset") {
        $transformScale -= 1;
        $scale = $transformScale*$max;
        $edits = $bb;
        for ($i = 0; $i < 3; $i++) if (!$stickies[$i]) $edits[$i] = $bb[$i]-$scale;
        for ($i = 3; $i < 6; $i++) if (!$stickies[$i]) $edits[$i] = $bb[$i]+$scale;
        $transform = `curve -n ($name + "_Transform") -d 1 -p $edits[0] $edits[1] $edits[5] -p $edits[0] $edits[4] $edits[5] -p $edits[0] $edits[4] $edits[2] -p $edits[0] $edits[1] $edits[2] -p $edits[3] $edits[1] $edits[2] -p $edits[3] $edits[4] $edits[2] -p $edits[3] $edits[4] $edits[5] -p $edits[3] $edits[1] $edits[5] -p $edits[0] $edits[1] $edits[5] -p $edits[0] $edits[1] $edits[2] -p $edits[0] $edits[4] $edits[2] -p $edits[3] $edits[4] $edits[2] -p $edits[3] $edits[1] $edits[2] -p $edits[3] $edits[1] $edits[5] -p $edits[3] $edits[4] $edits[5] -p $edits[0] $edits[4] $edits[5] -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15`;
        select -r $transform;
        nas_colorControls "red" 0;
        for ($i = 0; $i < 3; $i++) {
            if ($stickies[$i] == 1 && $stickies[$i+3] == 0) $edits[$i] = $bb[$i];
            else if ($stickies[$i] == 0 && $stickies[$i+3] == 1) $edits[$i] = $bb[$i+3];
            else $edits[$i] = ($bb[$i] + $bb[$i+3])/2;
        }
        xform -ws -rp $edits[0] $edits[1] $edits[2] $transform;
    } else if ($type == "Prop") {
        if ($stickies[0] || $stickies[3]) $wp = {1, 0, 0};
        else if ($stickies[1] || $stickies[4]) $wp = {0, 1, 0};
        else if ($stickies[1] || $stickies[5]) $wp = {0, 0, 1};
        
        $array = `circle -n ($name + "_Transform") -c 0 0 0 -nr $wp[0] $wp[1] $wp[2] -sw 360 -r ($maxWidth/2*$transformScale) -d 3 -ut 0 -tol 0.01 -s 8 -ch 1`;
        $transform = $array[0];
        select -r $transform;
        nas_colorControls "blue" 0;
        //move transforms node to first sticky side
        for ($i = 0; $i < 3; $i++) {
            if ($stickies[$i] == 1 && $stickies[$i+3] == 0) $edits[$i] = $bb[$i];
            else if ($stickies[$i] == 0 && $stickies[$i+3] == 1) $edits[$i] = $bb[$i+3];
            else $edits[$i] = ($bb[$i] + $bb[$i+3])/2;
        }
        move -ws $edits[0] $edits[1] $edits[2] $transform;
    }        
    parent $transform $offsetNode;
    delete -ch $transform;
    
    //create attrs on transform and connect with sdk's
    addAttr -ln "Smooth" -at "enum" -en "UnSmoothed:MediumShot:CloseUp:" $transform;
    setAttr -e -keyable true ($transform + ".Smooth");
    addAttr -ln "GeoVis" -at "enum" -en "Off:On:" $transform;
    setAttr -e -keyable true ($transform + ".GeoVis") 1;
    connectAttr ($transform + ".GeoVis") ("|" + $worldNode + "|" + $projectNode + "|Geometry|" + $meshGroup + ".v");
    addAttr -ln "GeoRes" -at "enum" -en "Proxy:LoRes:HiRes:" $transform;
    setAttr -e -keyable true ($transform + ".GeoRes") 2;
    
    setDrivenKeyframe -currentDriver ($transform + ".GeoRes") -driverValue 0 -value 1 ("|" + $worldNode + "|" + $projectNode + "|Geometry|" + $meshGroup + "|Proxy.v");
    setDrivenKeyframe -currentDriver ($transform + ".GeoRes") -driverValue 1 -value 0 ("|" + $worldNode + "|" + $projectNode + "|Geometry|" + $meshGroup + "|Proxy.v");
    
    setDrivenKeyframe -currentDriver ($transform + ".GeoRes") -driverValue 0 -value 0 ("|" + $worldNode + "|" + $projectNode + "|Geometry|" + $meshGroup + "|LoRes.v");
    setDrivenKeyframe -currentDriver ($transform + ".GeoRes") -driverValue 1 -value 1 ("|" + $worldNode + "|" + $projectNode + "|Geometry|" + $meshGroup + "|LoRes.v");
    setDrivenKeyframe -currentDriver ($transform + ".GeoRes") -driverValue 2 -value 0 ("|" + $worldNode + "|" + $projectNode + "|Geometry|" + $meshGroup + "|LoRes.v");
    
    setDrivenKeyframe -currentDriver ($transform + ".GeoRes") -driverValue 1 -value 0 ("|" + $worldNode + "|" + $projectNode + "|Geometry|" + $meshGroup + "|HiRes.v");
    setDrivenKeyframe -currentDriver ($transform + ".GeoRes") -driverValue 2 -value 1 ("|" + $worldNode + "|" + $projectNode + "|Geometry|" + $meshGroup + "|HiRes.v");
    
    //make the cog
    if ($createCog) {
        $scale = $cogScale;
        if ($cogFit) {
            $array = `circle -n ($name + "_COG") -c 0 0 0 -nr ($axisVec.x) ($axisVec.y) ($axisVec.z) -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1`;
            $cog = $array[0];
            move -ws $centerWp[0] $centerWp[1] $centerWp[2] $cog;
            scale -r ((($bb[3]-$bb[0])/2)*$scale) ((($bb[4]-$bb[1])/2)*$scale) ((($bb[5]-$bb[2])/2)*$scale) $cog;
        } else {
            $array = `circle -n ($name + "_COG") -c 0 0 0 -nr 0 1 0 -sw 360 -r ($maxWidth/2*$scale) -d 3 -ut 0 -tol 0.01 -s 8 -ch 1`;
            $cog = $array[0];
        }
        makeIdentity -apply true -t 1 -r 0 -s 1 $cog;
        delete -ch $cog;
        select -r $cog;
        nas_colorControls "yellow" 0;
        if (`objExists $transform`) parent $cog $transform;
        parentConstraint -mo $cog $meshGroup;
        scaleConstraint -mo $cog $meshGroup;
    } else {
        parentConstraint -mo $transform $meshGroup;
        scaleConstraint -mo $transform $meshGroup;
    }
    return 1;
}

//-------------------------------------------------------------dkGeneralistControlsUI---------------------------------------------------------------------
global proc dkGeneralistControlsUI(int $activeSlide) {
    global string $dkGeneralistControlsRadio[], $dkGeneralistControlsCheckbox, $dkGeneralistControlsTransformSlider, $dkGeneralistControlsCOGSlider, 
    $dkGeneralistControlsSticky1[], $dkGeneralistControlsSticky2[], $dkGeneralistControlsRadio2[], $dkGeneralistControlsProdRadio[], $dkGeneralistControlsCogType;
    string $window, $form, $button, $separator, $separator2, $array[];
    
    $window = `nas_window dkGeneralistControls 1 0 0`;
    $form = `formLayout`;
        $dkGeneralistControlsProdRadio  = `dkRadioCheckBoxGrp "Production:" 89 {"Fanboy", "Penguins"} {"1", ""} "" 0 {}`;
        $dkGeneralistControlsRadio2 = `dkRadioCheckBoxGrp "Type:" 89 {"BG Asset", "Prop"} {"1", ""} "" 0 {
        "dkGeneralistControlsPreview \"Transform\" 0;dkGeneralistControlsPreview \"COG\" 0;floatSliderGrp -e -maxValue 1.5 -precision 2 $dkGeneralistControlsTransformSlider;floatSliderGrp -e -maxValue 2.5 -precision 2 $dkGeneralistControlsCOGSlider;",
        "dkGeneralistControlsPreview \"Transform\" 0;dkGeneralistControlsPreview \"COG\" 0;floatSliderGrp -e -maxValue 3 -precision 2 $dkGeneralistControlsTransformSlider;floatSliderGrp -e -maxValue 2.5 -precision 2 $dkGeneralistControlsCOGSlider;", "", ""}`;
        $array[0] = $activeSlide;
        $array[1] = (1-$activeSlide);
        $dkGeneralistControlsActiveSlide  = `dkRadioCheckBoxGrp "Active Slide:" 89 {"On", "Off"} $array "" 0 {"dkGeneralistControlsUI 1", "dkGeneralistControlsUI 0", "", ""}`;
        $separator2 = `separator -style "double"`;
        if ($activeSlide) $dkGeneralistControlsTransformSlider = `floatSliderGrp -label "Transform Scale:" -precision 2 -field 1 -fieldMinValue .001 -minValue 1 -maxValue 1.5 -value 1.1 -columnAlign 1 "right" -cw3 89 30 139 -adj 3 -dragCommand "dkGeneralistControlsPreview \"Transform\" 1;" -changeCommand "flushUndo;"`;
        else $dkGeneralistControlsTransformSlider = `floatSliderGrp -label "Transform Scale:" -precision 2 -field 1 -fieldMinValue .001 -minValue 1 -maxValue 1.5 -value 1.1 -columnAlign 1 "right" -cw3 89 30 139 -adj 3 -changeCommand "dkGeneralistControlsPreview \"Transform\" 1;"`;
        $dkGeneralistControlsSticky1 = `dkCheckboxGrp "       " 89 {"-X", "-Y", "-Z"} {0, 1, 0}`;
        $dkGeneralistControlsSticky2 = `dkCheckboxGrp "Sticky:" 89 {"+X", "+Y", "+Z"} {0, 0, 0}`;
        //$dkGeneralistControlsSticky1 = `checkBoxGrp -numberOfCheckBoxes 3 -label "       " -labelArray3 "-X" "-Y" "-Z" -v2 1 -cw4 41 77 77 77 -cal 1 "left"`;
        //$dkGeneralistControlsSticky2 = `checkBoxGrp -numberOfCheckBoxes 3 -label "Sticky:" -labelArray3 "+X" "+Y" "+Z" -cw4 41 77 77 77 -cal 1 "left"`;
        $separator = `separator`;
        $dkGeneralistControlsCheckbox = `checkBox -label "Create COG" -align "left" -value 1 -onCommand "formLayout -e -enable 1 $dkGeneralistControlsCogType;formLayout -e -enable 1 $dkGeneralistControlsRadio[0];floatSliderGrp -e -enable 1 $dkGeneralistControlsCOGSlider;" -offCommand "formLayout -e -enable 0 $dkGeneralistControlsCogType;formLayout -e -enable 0 $dkGeneralistControlsRadio[0];floatSliderGrp -e -enable 0 $dkGeneralistControlsCOGSlider;"`;
        $dkGeneralistControlsCogType = `checkBox -label "Fit" -align "left" -value 1 -onCommand "dkGeneralistControlsPreview \"COG\" 1;" -offCommand "dkGeneralistControlsPreview \"COG\" 1;"`;
        $dkGeneralistControlsRadio = `dkRadioCheckBoxGrp "Axis:" 89 {"X", "Y", "Z"} {"", "1", ""} "" 0 {"dkGeneralistControlsPreview \"COG\" 0;dkGeneralistControlsPreview \"COG\" 1;", "dkGeneralistControlsPreview \"COG\" 0;dkGeneralistControlsPreview \"COG\" 1;", "dkGeneralistControlsPreview \"COG\" 0;dkGeneralistControlsPreview \"COG\" 1;", "", ""}`;
        if ($activeSlide) $dkGeneralistControlsCOGSlider = `floatSliderGrp -label "COG Scale:" -precision 1 -field 1 -fieldMinValue .001 -minValue 1 -maxValue 2.5 -value 1.2 -columnAlign 1 "right" -cw3 89 30 139 -adj 3 -dragCommand "dkGeneralistControlsPreview \"COG\" 1;" -changeCommand "flushUndo;"`;
        else $dkGeneralistControlsCOGSlider = `floatSliderGrp -label "COG Scale:" -precision 2 -field 1 -fieldMinValue .001 -minValue 1 -maxValue 2.5 -value 1.2 -columnAlign 1 "right" -cw3 89 30 139 -adj 3 -changeCommand "dkGeneralistControlsPreview \"COG\" 1;"`;
        $button = `button -label "Create BG Asset Ctrls" -c "dkGeneralistControlsExecute;dkGeneralistControlsPreview \"\" 0;"`;
        setParent..;
    formLayout -e
        -af $dkGeneralistControlsActiveSlide "top" 5 
        -af $dkGeneralistControlsActiveSlide "left" 5
        -af $dkGeneralistControlsActiveSlide "right" 5
        -an $dkGeneralistControlsActiveSlide "bottom"
        
        -ac $dkGeneralistControlsProdRadio[0] "top" 5 $dkGeneralistControlsActiveSlide
        -af $dkGeneralistControlsProdRadio[0] "left" 5
        -af $dkGeneralistControlsProdRadio[0] "right" 5
        
        -ac $dkGeneralistControlsRadio2[0] "top" 5 $dkGeneralistControlsProdRadio[0]
        -af $dkGeneralistControlsRadio2[0] "left" 5
        -af $dkGeneralistControlsRadio2[0] "right" 5
        
        -ac $separator2 "top" 5 $dkGeneralistControlsRadio2[0]
        -af $separator2 "left" 5
        -af $separator2 "right" 5
        
        -ac $dkGeneralistControlsTransformSlider "top" 5 $separator2
        -af $dkGeneralistControlsTransformSlider "left" 5
        -af $dkGeneralistControlsTransformSlider "right" 5
        
        -ac $dkGeneralistControlsSticky2[0] "top" 5 $dkGeneralistControlsTransformSlider
        -af $dkGeneralistControlsSticky2[0] "left" 5
        -af $dkGeneralistControlsSticky2[0] "right" 5
        
        -ac $dkGeneralistControlsSticky1[0] "top" 5 $dkGeneralistControlsSticky2[0]
        -af $dkGeneralistControlsSticky1[0] "left" 5
        -af $dkGeneralistControlsSticky1[0] "right" 5
        
        -ac $separator "top" 5 $dkGeneralistControlsSticky1[0]
        -af $separator "left" 5
        -af $separator "right" 5
        
        -ac $dkGeneralistControlsCheckbox "top" 5 $separator
        -af $dkGeneralistControlsCheckbox "left" 5
        -ap $dkGeneralistControlsCheckbox "right" 0 50
        
        -ac $dkGeneralistControlsCogType "top" 5 $separator
        -ap $dkGeneralistControlsCogType "left" 0 50
        -af $dkGeneralistControlsCogType "right" 5
        
        -ac $dkGeneralistControlsRadio[0] "top" 5 $dkGeneralistControlsCogType
        -af $dkGeneralistControlsRadio[0] "left" 5
        -af $dkGeneralistControlsRadio[0] "right" 5
        
        -ac $dkGeneralistControlsCOGSlider "top" 5 $dkGeneralistControlsRadio[0]
        -af $dkGeneralistControlsCOGSlider "left" 5
        -af $dkGeneralistControlsCOGSlider "right" 5
        
        -ac $button "top" 5 $dkGeneralistControlsCOGSlider
        -af $button "left" 5
        -af $button "right" 5
        -af $button "bottom" 5
        $form;
    window -e -wh 300 300 $window;
    showWindow $window;
    dkGeneralistControlsPreview "Transform" 0;
    dkGeneralistControlsPreview "COG" 0;
}

//-------------------------------------------------------------dkGeneralistControlsExecute---------------------------------------------------------------------
global proc dkGeneralistControlsExecute() {
    global string $dkGeneralistControlsRadio[], $dkGeneralistControlsCheckbox, $dkGeneralistControlsTransformSlider, $dkGeneralistControlsCOGSlider, 
    $dkGeneralistControlsSticky1[], $dkGeneralistControlsSticky2[], $dkGeneralistControlsRadio2[], $dkGeneralistControlsProdRadio[], $dkGeneralistControlsCogType, $dkGeneralistControlsPreviewGeos[];
    string $axis, $type, $geos[];
    int $stickies[], $value;

    if (`radioButton -q -select $dkGeneralistControlsProdRadio[1]` == 1) $prod = "FB";
    else if (`radioButton -q -select $dkGeneralistControlsProdRadio[2]` == 1) $prod = "PN";
    
    if (`radioButton -q -select $dkGeneralistControlsRadio2[1]` == 1) $type = "BGAsset";
    else if (`radioButton -q -select $dkGeneralistControlsRadio2[2]` == 1) $type = "Prop";
    
    if (`radioButton -q -select $dkGeneralistControlsRadio[1]` == 1) $axis = "x";
    else if (`radioButton -q -select $dkGeneralistControlsRadio[2]` == 1) $axis = "y";
    else if (`radioButton -q -select $dkGeneralistControlsRadio[3]` == 1) $axis = "z";
    
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky1[1]`;
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky1[2]`;
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky1[3]`;
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky2[1]`;
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky2[2]`;
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky2[3]`;
    
    for ($geo in $dkGeneralistControlsPreviewGeos) if (`objExists $geo`) $geos[size($geos)] = $geo;
    select -r $geos;
    dkGeneralistControls $axis `checkBox -q -value $dkGeneralistControlsCheckbox` `floatSliderGrp -q -v $dkGeneralistControlsTransformSlider` `floatSliderGrp -q -v $dkGeneralistControlsCOGSlider` $stickies $type $prod `checkBox -q -value $dkGeneralistControlsCogType`;
}

global int $dkGeneralistControlsPreviewTransformToggle, $dkGeneralistControlsPreviewCOGToggle;
$dkGeneralistControlsPreviewTransformToggle = 0;
$dkGeneralistControlsPreviewCOGToggle = 0;

//-------------------------------------------------------------dkGeneralistControlsPreview---------------------------------------------------------------------
global proc dkGeneralistControlsPreview(string $control, int $on) {
    global string $dkGeneralistControlsPreviewTransform, $dkGeneralistControlsPreviewCOG, $dkGeneralistControlsRadio[], $dkGeneralistControlsCheckbox, $dkGeneralistControlsTransformSlider, $dkGeneralistControlsCOGSlider, 
    $dkGeneralistControlsSticky1[], $dkGeneralistControlsSticky2[], $dkGeneralistControlsRadio2[], $dkGeneralistControlsProdRadio[], $dkGeneralistControlsPreviewGeos[], $dkGeneralistControlsCogType;
    global float $dkGeneralistControlsPreviewBB[], $dkGeneralistControlsPreviewMax, $dkGeneralistControlsPreviewMaxWidth;
    global int $dkGeneralistControlsPreviewTransformToggle, $dkGeneralistControlsPreviewCOGToggle;
    
    string $array[], $type, $geos[];
    float $edits[], $scale, $wp[];
    int $stickies[], $cogFit;
    vector $axisVec;
    
    $cogFit = `checkBox -q -value $dkGeneralistControlsCogType`;
    
    if (!`objExists $dkGeneralistControlsPreviewTransform`) $dkGeneralistControlsPreviewTransformToggle = 0;
    if (!`objExists $dkGeneralistControlsPreviewCOG`) $dkGeneralistControlsPreviewCOGToggle = 0;
    
    if ($on && !$dkGeneralistControlsPreviewTransformToggle && !$dkGeneralistControlsPreviewCOGToggle) {
        $dkGeneralistControlsPreviewGeos = `ls -sl -long`;
        $dkGeneralistControlsPreviewBB = `nas_boundingBox $dkGeneralistControlsPreviewGeos`;
        
        $dkGeneralistControlsPreviewMax = ($dkGeneralistControlsPreviewBB[3]-$dkGeneralistControlsPreviewBB[0]);
        if (($dkGeneralistControlsPreviewBB[4]-$dkGeneralistControlsPreviewBB[1]) > $dkGeneralistControlsPreviewMax) $dkGeneralistControlsPreviewMax = ($dkGeneralistControlsPreviewBB[4]-$dkGeneralistControlsPreviewBB[1]);
        if (($dkGeneralistControlsPreviewBB[5]-$dkGeneralistControlsPreviewBB[2]) > $dkGeneralistControlsPreviewMax) $dkGeneralistControlsPreviewMax = ($dkGeneralistControlsPreviewBB[5]-$dkGeneralistControlsPreviewBB[2]);
        
        if(($dkGeneralistControlsPreviewBB[3] - $dkGeneralistControlsPreviewBB[0]) > ($dkGeneralistControlsPreviewBB[5] - $dkGeneralistControlsPreviewBB[2])) $dkGeneralistControlsPreviewMaxWidth = $dkGeneralistControlsPreviewBB[3] - $dkGeneralistControlsPreviewBB[0];
        else $dkGeneralistControlsPreviewMaxWidth = $dkGeneralistControlsPreviewBB[5] - $dkGeneralistControlsPreviewBB[2];
    }
    
    if (`radioButton -q -select $dkGeneralistControlsRadio2[1]` == 1) $type = "BGAsset";
    else if (`radioButton -q -select $dkGeneralistControlsRadio2[2]` == 1) $type = "Prop";
    
    if (`radioButton -q -select $dkGeneralistControlsRadio[1]` == 1) $axisVec = <<1, 0, 0>>;
    else if (`radioButton -q -select $dkGeneralistControlsRadio[2]` == 1) $axisVec = <<0, 1, 0>>;
    else if (`radioButton -q -select $dkGeneralistControlsRadio[3]` == 1) $axisVec = <<0, 0, 1>>;
    
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky1[1]`;
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky1[2]`;
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky1[3]`;
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky2[1]`;
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky2[2]`;
    $stickies[size($stickies)] = `checkBox -q -value $dkGeneralistControlsSticky2[3]`; 
    
    if ($control == "Transform") $scale = `floatSliderGrp -q -v $dkGeneralistControlsTransformSlider`;
    else if ($control == "COG") $scale = `floatSliderGrp -q -v $dkGeneralistControlsCOGSlider`;
    
    if ($on) {
        if ($dkGeneralistControlsPreviewTransformToggle && $control == "Transform") {
            if ($type == "BGAsset") {
                delete $dkGeneralistControlsPreviewTransform; 
                $scale -= 1;
                $scale *= $dkGeneralistControlsPreviewMax;
                $edits = $dkGeneralistControlsPreviewBB;
                for ($i = 0; $i < 3; $i++) if (!$stickies[$i]) $edits[$i] = $dkGeneralistControlsPreviewBB[$i]-$scale;
                for ($i = 3; $i < 6; $i++) if (!$stickies[$i]) $edits[$i] = $dkGeneralistControlsPreviewBB[$i]+$scale;
                $dkGeneralistControlsPreviewTransform = `curve -d 1 -p $edits[0] $edits[1] $edits[5] -p $edits[0] $edits[4] $edits[5] -p $edits[0] $edits[4] $edits[2] -p $edits[0] $edits[1] $edits[2] -p $edits[3] $edits[1] $edits[2] -p $edits[3] $edits[4] $edits[2] -p $edits[3] $edits[4] $edits[5] -p $edits[3] $edits[1] $edits[5] -p $edits[0] $edits[1] $edits[5] -p $edits[0] $edits[1] $edits[2] -p $edits[0] $edits[4] $edits[2] -p $edits[3] $edits[4] $edits[2] -p $edits[3] $edits[1] $edits[2] -p $edits[3] $edits[1] $edits[5] -p $edits[3] $edits[4] $edits[5] -p $edits[0] $edits[4] $edits[5] -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15`;                    
            } else if ($type == "Prop") {
                scale ($dkGeneralistControlsPreviewMaxWidth/2*$scale) ($dkGeneralistControlsPreviewMaxWidth/2*$scale) ($dkGeneralistControlsPreviewMaxWidth/2*$scale) $dkGeneralistControlsPreviewTransform;
            } 
        } else if ($dkGeneralistControlsPreviewCOGToggle && $control == "COG") {
            if ($cogFit) {
                scale ((($dkGeneralistControlsPreviewBB[3]-$dkGeneralistControlsPreviewBB[0])/2)*$scale) ((($dkGeneralistControlsPreviewBB[4]-$dkGeneralistControlsPreviewBB[1])/2)*$scale) ((($dkGeneralistControlsPreviewBB[5]-$dkGeneralistControlsPreviewBB[2])/2)*$scale) $dkGeneralistControlsPreviewCOG;
            } else {
                scale ($dkGeneralistControlsPreviewMaxWidth/2*$scale) ($dkGeneralistControlsPreviewMaxWidth/2*$scale) ($dkGeneralistControlsPreviewMaxWidth/2*$scale) $dkGeneralistControlsPreviewCOG;
            }
        } else if (!$dkGeneralistControlsPreviewTransformToggle && $control == "Transform") {
            if ($type == "BGAsset") {
                $scale -= 1;
                $scale *= $dkGeneralistControlsPreviewMax;
                $edits = $dkGeneralistControlsPreviewBB;
                if (!$stickies[0]) $edits[0] = $dkGeneralistControlsPreviewBB[0]-$scale;
                if (!$stickies[1]) $edits[1] = $dkGeneralistControlsPreviewBB[1]-$scale;
                if (!$stickies[2]) $edits[2] = $dkGeneralistControlsPreviewBB[2]-$scale;
                if (!$stickies[3]) $edits[3] = $dkGeneralistControlsPreviewBB[3]+$scale;
                if (!$stickies[4]) $edits[4] = $dkGeneralistControlsPreviewBB[4]+$scale;
                if (!$stickies[5]) $edits[5] = $dkGeneralistControlsPreviewBB[5]+$scale;
                $dkGeneralistControlsPreviewTransform = `curve -d 1 -p $edits[0] $edits[1] $edits[5] -p $edits[0] $edits[4] $edits[5] -p $edits[0] $edits[4] $edits[2] -p $edits[0] $edits[1] $edits[2] -p $edits[3] $edits[1] $edits[2] -p $edits[3] $edits[4] $edits[2] -p $edits[3] $edits[4] $edits[5] -p $edits[3] $edits[1] $edits[5] -p $edits[0] $edits[1] $edits[5] -p $edits[0] $edits[1] $edits[2] -p $edits[0] $edits[4] $edits[2] -p $edits[3] $edits[4] $edits[2] -p $edits[3] $edits[1] $edits[2] -p $edits[3] $edits[1] $edits[5] -p $edits[3] $edits[4] $edits[5] -p $edits[0] $edits[4] $edits[5] -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15`;
            } else if ($type == "Prop") {
                if ($stickies[0] || $stickies[3]) $wp = {1, 0, 0};
                else if ($stickies[1] || $stickies[4]) $wp = {0, 1, 0};
                else if ($stickies[1] || $stickies[5]) $wp = {0, 0, 1};
                
                $array = `circle -c 0 0 0 -nr $wp[0] $wp[1] $wp[2] -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1`;
                $dkGeneralistControlsPreviewTransform = $array[0];
                scale -r ($dkGeneralistControlsPreviewMaxWidth/2*$scale) ($dkGeneralistControlsPreviewMaxWidth/2*$scale) ($dkGeneralistControlsPreviewMaxWidth/2*$scale) $dkGeneralistControlsPreviewTransform;
                //move transforms node to sticky side
                for ($i = 0; $i < 3; $i++) {
                    if ($stickies[$i] == 1 && $stickies[$i+3] == 0) $edits[$i] = $dkGeneralistControlsPreviewBB[$i];
                    else if ($stickies[$i] == 0 && $stickies[$i+3] == 1) $edits[$i] = $dkGeneralistControlsPreviewBB[$i+3];
                    else $edits[$i] = ($dkGeneralistControlsPreviewBB[$i] + $dkGeneralistControlsPreviewBB[$i+3])/2;
                }
                move -ws $edits[0] $edits[1] $edits[2] $dkGeneralistControlsPreviewTransform;
            }
            $dkGeneralistControlsPreviewTransformToggle = 1;
        } else if (!$dkGeneralistControlsPreviewCOGToggle && $control == "COG") {
            if ($cogFit) {
                $array = `circle -c 0 0 0 -nr ($axisVec.x) ($axisVec.y) ($axisVec.z) -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1`;
                $dkGeneralistControlsPreviewCOG = $array[0];
                $centerWp = {(($dkGeneralistControlsPreviewBB[0]+$dkGeneralistControlsPreviewBB[3])/2), (($dkGeneralistControlsPreviewBB[1]+$dkGeneralistControlsPreviewBB[4])/2), (($dkGeneralistControlsPreviewBB[2]+$dkGeneralistControlsPreviewBB[5])/2)};
                move -ws $centerWp[0] $centerWp[1] $centerWp[2] $dkGeneralistControlsPreviewCOG;
                scale -r ((($dkGeneralistControlsPreviewBB[3]-$dkGeneralistControlsPreviewBB[0])/2)*$scale) ((($dkGeneralistControlsPreviewBB[4]-$dkGeneralistControlsPreviewBB[1])/2)*$scale) ((($dkGeneralistControlsPreviewBB[5]-$dkGeneralistControlsPreviewBB[2])/2)*$scale) $dkGeneralistControlsPreviewCOG;
            } else {
                $array = `circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1`;
                $dkGeneralistControlsPreviewCOG = $array[0];
                scale -r ($dkGeneralistControlsPreviewMaxWidth/2*$scale) ($dkGeneralistControlsPreviewMaxWidth/2*$scale) ($dkGeneralistControlsPreviewMaxWidth/2*$scale) $dkGeneralistControlsPreviewCOG;  
            }
            $dkGeneralistControlsPreviewCOGToggle = 1;
        }
    } else {
        if (`objExists $dkGeneralistControlsPreviewTransform`) delete $dkGeneralistControlsPreviewTransform;
        if (`objExists $dkGeneralistControlsPreviewCOG`) delete $dkGeneralistControlsPreviewCOG;
        $dkGeneralistControlsPreviewTransformToggle = 0;
        $dkGeneralistControlsPreviewCOGToggle = 0;
        for ($geo in $dkGeneralistControlsPreviewGeos) if (`objExists $geo`) $geos[size($geos)] = $geo;
        select -r $geos;
    }
}

//-------------------------------------------------------------dkAttrVisibility---------------------------------------------------------------------
//controls the visibility of specified attrs
//more useful for custom attr names and when you don't want to mess with previous dkShowAttrs
global proc dkAttrVisibility(int $toggle, string $attrList) {
    string $attrs[], $sels[];
    if (size($attrList) == 0) $attrs = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"};
    else $attrs = stringToStringArray($attrList, ", ");
    $sels = `ls -sl`;
    for ($sel in $sels) {
        if ($toggle) for ($attr in $attrs) setAttr -lock false -keyable true ($sel + "." + $attr);
        else for ($attr in $attrs) setAttr -lock true -keyable false ($sel + "." + $attr);
    }
}

//-------------------------------------------------------------dkDigits---------------------------------------------------------------------
//creates fk controls for joint chains
//if "all" input is 2 then all selected joint chains will rotate in given axis
//if "all" input is 1 then each joint chain will rotate in given axis
//if "all" input is 0 then each joint in each joint chain will rotate in given axis
//example: dkDigits l "index, middle, ring, pinky" "allCurl, indivCurl" "1, 0" "-z, -z";
global proc string[] dkDigits(string $side, string $nameList, string $attrList, string $allList, string $axisList) {
    string $names[], $allsArray[], $attrs[], $axes[], $array[], $digits[], $joints[], $attrGroups[], $ctrls[], $mainCtrl, $attr, $mdn, $axis;
    int $alls[], $isPositive;
    
    $names = stringToStringArray($nameList, ", ");
    $attrs = stringToStringArray($attrList, ", ");
    $allsArray = stringToStringArray($allList, ", ");
    for ($all in $allsArray) $alls[size($alls)] = $all;
    $axes = stringToStringArray($axisList, ", ");
    
    $array = `ls -sl`;
    $mainCtrl = $array[0];
    for ($i = 1; $i < size($array); $i++) $digits[size($digits)] = $array[$i];
    
    if (size($names) != size($digits)) error "Number of names in list must equal number of selected joints.";
    
    if (!`objExists ($mainCtrl + ".showFkCtrls")`) {
        addAttr -ln showFkCtrls -at double -min 0 -max 1 -dv 0 $mainCtrl;
        setAttr -e -keyable true ($mainCtrl + ".showFkCtrls");
    }
    
    for ($i = 0; $i < size($names); $i++) {
        clear $joints;
        clear $ctrls;
        select -hi $digits[$i];
        $array = `ls -sl`;
        appendStringArray($joints, $array, size($array)-1);
        select -r $joints;
        if ($side == "") $array = `dkFk $names[$i] 1`;
        else $array = `dkFk ($side + "_" + $names[$i]) 1`;
        appendStringArray($ctrls, $array, size($array)-2);
        $groups[$i] = $array[size($array)-1];
        for ($j = 0; $j < size($attrs); $j++) {
            $axes[$j] = `dkLowercaseAxis $axes[$j]`;
            if (`substring $axes[$j] 1 1` == "-") {
                $axis = `substring $axes[$j] 2 2`;
                $isPositive = 0;
            } else {
                $axis = $axes[$j];
                $isPositive = 1;
            }
            select -r $ctrls;
            $attrGroups = `nas_group 1 $attrs[$j]`;
            
            if ($alls[$j] > 0) {
                if ($alls[$j] == 2) $attr = $attrs[$j];
                else if ($alls[$j] == 1) $attr = $names[$i] + `capitalizeString $attrs[$j]`;
                if (!`objExists ($mainCtrl + "." + $attr)`) {
                    addAttr -ln $attr -at double -dv 0 $mainCtrl;
                    setAttr -e -keyable true ($mainCtrl + "." + $attr);
                }
                if ($isPositive) for ($attrGroup in $attrGroups) connectAttr ($mainCtrl + "." + $attr) ($attrGroup + ".r" + $axis);
                else {
                    $mdn = `createNode -n ($mainCtrl + "_" + $attr + "_mdn") multiplyDivide`;
                    connectAttr ($mainCtrl + "." + $attr) ($mdn + ".input1X");
                    setAttr ($mdn + ".input2X") -1;
                    for ($attrGroup in $attrGroups) connectAttr ($mdn + ".outputX") ($attrGroup + ".r" + $axis);
                }
            } else {
                for ($k = 0; $k < size($attrGroups); $k++) {
                    $attr = $names[$i] + `capitalizeString $attrs[$j]` + ($k+1);
                    addAttr -ln $attr -at double -dv 0 $mainCtrl;
                    setAttr -e -keyable true ($mainCtrl + "." + $attr);
                    if ($isPositive) connectAttr ($mainCtrl + "." + $attr) ($attrGroups[$k] + ".r" + $axis);
                    else {
                        $mdn = `createNode -n ($mainCtrl + "_" + $attr + "_mdn") multiplyDivide`;
                        connectAttr ($mainCtrl + "." + $attr) ($mdn + ".input1X");
                        setAttr ($mdn + ".input2X") -1;
                        connectAttr ($mdn + ".outputX") ($attrGroups[$k] + ".r" + $axis);
                    }
                }
            }
        }
        select -r $ctrls; dkShowAttrs 1 1 1 1 1 1 1 1 1 1;
        for ($ctrl in $ctrls) connectAttr ($mainCtrl + ".showFkCtrls") ($ctrl + ".v");
        select -r $ctrls; dkShowAttrs 0 0 0 1 1 1 1 0 0 0;
    }
    
    select -r $mainCtrl;
    clear $array;
    $array = $ctrls;
    $array[size($ctrls)] = $mainCtrl;
    return $array;
}

global proc dkDigitsUI() {
    global string $dkDigitsSideText, $dkDigitsNameText, $dkDigitsAttrText, $dkDigitsTypeText, $dkDigitsAxisText;
    string $window, $button, $form, $column;
    
    $window = `nas_window dkDigits 1 0 0`;
        $form = `formLayout`;
            $column = `columnLayout -adjustableColumn 1`;
                $dkDigitsSideText = `textFieldGrp -columnWidth2 45 100 -adjustableColumn 2 -label "Side:" -cal 1 right -text "l"`;
                $dkDigitsNameText = `textFieldGrp -columnWidth2 45 100 -adjustableColumn 2 -label "Name:" -cal 1 right -text "index middle ring pinky"`;
                $dkDigitsAttrText = `textFieldGrp -columnWidth2 45 100 -adjustableColumn 2 -label "Attrs:" -cal 1 right -text "allCurl indivCurl"`;
                $dkDigitsTypeText = `textFieldGrp -columnWidth2 45 100 -adjustableColumn 2 -label "Type:" -cal 1 right -text "1 0"`;
                $dkDigitsAxisText = `textFieldGrp -columnWidth2 45 100 -adjustableColumn 2 -label "Axes:" -cal 1 right -text "-z -z"`;
                setParent..;
            $button = `button -width 135 -label "Rig Digits!" -command dkDigitsUIExecute`;
            setParent..;
        formLayout -edit
            -af $column "top" 5
            -af $column "right" 5
            -an $column "bottom"
            -af $column "left" 5
            
            -ac $button "top" 5 $column 
            -af $button "right" 5
            -af $button "bottom" 5
            -af $button "left" 5
            $form;
        setParent..;
    window -e -w 260 -h 190 $window;
    showWindow $window;
}

global proc dkDigitsUIExecute() {
    global string $dkDigitsSideText, $dkDigitsNameText, $dkDigitsAttrText, $dkDigitsTypeText, $dkDigitsAxisText;
    string $side, $nameList, $attrList, $typeList, $axisList, $sels[], $shapes[], $names[], $attrs[], $types[], $axes[];
    
    $sels = `ls -sl`;
    if (size($sels) < 2) error "Please select one control followed by the top level joint of joint chains.";
    if (`nodeType $sels[1]` != "joint") error "Must select one control followed by the top level joint of joint chains.";
    $shapes = `listRelatives -shapes $sels[0]`;
    if (`nodeType $shapes[0]` != "nurbsCurve") error "Must select one control followed by the top level joint of joint chains.";
    
    $side = `textFieldGrp -q -text $dkDigitsSideText`;
    $nameList = `textFieldGrp -q -text $dkDigitsNameText`;
    $attrList = `textFieldGrp -q -text $dkDigitsAttrText`;
    $typeList = `textFieldGrp -q -text $dkDigitsTypeText`;
    $axisList = `textFieldGrp -q -text $dkDigitsAxisText`;
    
    $names = stringToStringArray($nameList, ", ");
    $attrs = stringToStringArray($attrList, ", ");
    $types = stringToStringArray($typeList, ", ");
    $axes = stringToStringArray($axisList, ", ");
    if (size($names) > 0) {
        if (size($attrs) == size($types) && size($types) == size($axes) && size($axes) == size($attrs)) dkDigits $side $nameList $attrList $typeList $axisList;
        else error "Number of attrs, types, and axes must be the same.";
    } else error "Please input the names of your joint chains.";
}

//-------------------------------------------------------------dkDuplicate---------------------------------------------------------------------
//duplicates the selection and switches L and R if it can
global proc string[] dkDuplicate() {
    string $sels[], $parts[], $array[], $duplicates[], $search, $replace, $group, $locs[];
    $sels = `ls -sl`;
    for ($sel in $sels) {
        $parts = stringToStringArray($sel, "_");
        $search = "";
        $replace = "";
        for ($part in $parts) {
            switch ($part) {
                case "L":
                    $search = "L";
                    $replace = "R";
                    break;
                case "l":
                    $search = "l";
                    $replace = "r";
                    break;
                case "R":
                    $search = "R";
                    $replace = "L";
                    break;
                case "r":
                    $search = "r";
                    $replace = "l";
                    break;
                case "LT":
                    $search = "LT";
                    $replace = "RT";
                    break;
                case "RT":
                    $search = "RT";
                    $replace = "LT";
                    break;
            }
        }
        if ($search == "" || $replace == "") warning ("No L or R found in name " + $sel + ".\n");
        else $array = `dkReplace $search $replace $sel`;
        $array = `duplicate -n $array[0] $sel`;
        $duplicates[size($duplicates)] = $array[0];
    }
    $group = `group -em`;
    parent $duplicates $group;
    setAttr ($group + ".sx") -1;
    for ($sel in $sels) {
        $array = `listRelatives -s $sel`;
        if (`nodeType $array[0]` == "locator") $locs[size($locs)] = $sel;
    }
    if (size($locs) == size($sels)) {
        makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $group;
        for ($dupe in $duplicates) scale -r .1 .1 .1 $dupe;
    } else {
        makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $group;
    }
    parent -w $duplicates;
    delete $group;
    
    select -r $duplicates;
    return $duplicates;
}

//-------------------------------------------------------------dkReplace---------------------------------------------------------------------
//returns an array with names changed by search and replace parameters
global proc string[] dkReplace(string $search, string $replace, string $list) {
    string $newname, $sels[], $parts[], $names[];
    if (size($list) == 0) $sels = `ls -sl`;
    else $sels = stringToStringArray($list, ", ");
    for ($sel in $sels) {
        $parts = stringToStringArray($sel, "_");
        if ($parts[0] == $search) $newName = $replace;
        else $newName = $parts[0];
        for ($i = 1; $i < size($parts); $i++) {
            if ($parts[$i] == $search) $newName += ("_" + $replace);
            else $newName += ("_" + $parts[$i]);
        }
        $names[size($names)] = $newName;
    }
    return $names;
}

//-------------------------------------------------------------dkProxy---------------------------------------------------------------------
global proc dkProxyGeoKeepEdges() {
    global string $dkProxyGeoDelEdges[];
    string $keepEdges[], $allEdges[], $delEdges[], $array[];
    $keepEdges = `ls -sl -flatten`;
    $array = stringToStringArray($keepEdges[0], ".");
    $allEdges = `ls -fl ($array[0] + ".e[*]")`;
    $dkProxyGeoDelEdges = stringArrayRemove($keepEdges, $allEdges);
}

global proc dkProxyGeo(string $axis) {
    global string $dkProxyGeoDelEdges[];
    string $array[], $joints[], $geo, $polyCut, $locator, $locs[], $segmentsLocs[], $result, $proxy, $ogVerts[], $newVerts[], $newEdges[], $allVerts[], $allFaces[];
    vector $position, $jointRot, $worldUpVector;
    float $bb[], $wp[], $increment1, $increment2, $axisWps[], $dist;
    int $segments;

    $result = `promptDialog -title "dkCutFacesSegments" -ma "center" -message "How many segments per joint?" -text "1" -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;    
    if ($result == "OK") $segments = `promptDialog -query -text`;
    
    $array = `ls -sl`;
    $joints = `ls -sl -type joint`;
    $array = stringArrayRemove($joints, $array);
    $geo = $array[0];
    
    for ($i = 0; $i < size($joints)-1; $i++) {
        select -r $joints[$i];
        $array = `nas_locator 1`;
        $locs[0] = $array[0];
        select -r $joints[$i+1];
        $array = `nas_locator 1`;
        $locs[1] = $array[0];
        $proxy = $geo;
        delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $joints[$i] -worldUpVector 0 1 0 $joints[$i+1] $locs[0]`;
        delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject $joints[$i+1] -worldUpVector 0 1 0 $joints[$i] $locs[1]`;
        $dist = `nas_distance {$joints[$i], $joints[$i+1]}`;
        move -r -os -wd 0 0 ($dist*.05) $locs[0];
        move -r -os -wd 0 0 ($dist*-.05) $locs[1];
        if ($axis == "") {
            $jointRot = `getAttr ($locs[0] + ".rotate")`;
        } else {
            if ($axis == "x") $jointRot = <<0, 90, 0>>;
            if ($axis == "y") $jointRot = <<0, 0, 90>>;
            if ($axis == "z") $jointRot = <<0, 0, 0>>;
        }

        select -r $locs;
        $locs = `dkSegments $segments`;
        for ($j = 0; $j < size($locs); $j++) {
            $position = `xform -q -translation -ws $locs[$j]`;
            $array = `polyCut -cd z -ch 1 $proxy`;
            $polyCut = $array[0];
            setAttr ($polyCut + ".cutPlaneCenter") ($position.x) ($position.y) ($position.z);
            setAttr ($polyCut + ".cutPlaneRotate") ($jointRot.x) ($jointRot.y) ($jointRot.z);
        }
        delete $locs;
    }
    polyDelEdge -cv true -ch 1 $dkProxyGeoDelEdges;
}

//-------------------------------------------------------------dkCutFacesSegments---------------------------------------------------------------------
global proc dkCutFacesSegments() {
    global int $dkCutSegments;
    string $result, $input;
    $result = `promptDialog -title "dkCutFacesSegments" -ma "center" -message "How many segments per joint?" -text "1" -button "OK" -button "Cancel" -defaultButton "OK" -cancelButton "Cancel" -dismissString "Cancel"`;    
    if ($result == "OK") {
         $input = `promptDialog -query -text`;
        $dkCutSegments = $input;
    }
}

//-------------------------------------------------------------dkCutFacesGetEdges---------------------------------------------------------------------
global proc string[] dkCutFacesGetEdges() {
    global string $dkCutFacesEdges[];
    string $array[];
    //$array = `ls -sl`;
    //$array = stringToStringArray($array[0], ".");
    $dkCutFacesEdges = `ls -sl -flatten`;
    return $dkCutFacesEdges;
}

//-------------------------------------------------------------dkCutFaces---------------------------------------------------------------------
global proc dkCutFaces(string $worldUp, int $findDeg, int $segments) {
    global string $dkCutFacesEdges[];
    string $array[], $joints[], $object, $polyCut, $locator, $locs[], $segmentsLocs[];
    vector $position, $jointRot, $worldUpVector;
    
    $worldUpVector = `nas_axisToVector $worldUp`;
    $array = `ls -sl`;
    $joints = `ls -sl -type joint`;
    $array = stringArrayRemove($joints, $array);$object = $array[0];
    for ($joint in $joints) {
        select -r $joint;
        $array = `nas_locator 1`;
        $locs[size($locs)] = $array[0];
    }
    for ($i = 0; $i < size($joints)-1; $i++) {
        if ($findDeg) {
            select -r $joints[$i];
            $array = `nas_locator 1`;
            $locator = $array[0];
            delete `pointConstraint $joints[$i] $locator`;
            delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "vector" -worldUpVector ($worldUpVector.x) ($worldUpVector.x) ($worldUpVector.x) $joints[$i+1] $locator`;
            $jointRot = `getAttr ($locator + ".rotate")`;
            delete $locator;
        }
        select -r $locs[$i] $locs[$i+1];
        $segmentLocs = `dkSegments $segments`;
        for ($j = 0; $j < size($segmentLocs)-1; $j++) {
            $position = `xform -q -translation -ws $segmentLocs[$j]`;
            $array = `polyCut -cd z -ch 1 $object`; $polyCut = $array[0];
            setAttr ($polyCut + ".cutPlaneCenter") ($position.x) ($position.y) ($position.z);
            if ($findDeg) setAttr ($polyCut + ".cutPlaneRotate") ($jointRot.x) ($jointRot.y) ($jointRot.z);
        }
        delete `stringArrayRemove $locs $segmentLocs`;
    }
    //dkCutFacesDeleteEdges;
    delete $locs;
    select -r $object;
    setSelectMode components Components;
    selectType -smp 0 -sme 0 -smf 1 -smu 0 -pv 0 -pe 0 -pf 1 -puv 0;
    hilite -r $object;
}
//-------------------------------------------------------------dkCutFacesDeleteEdges---------------------------------------------------------------------
global proc dkCutFacesDeleteEdges() {
    global string $dkCutFacesEdges[];
    string $edges[];
    select -r $dkCutFacesEdges;
    SelectEdgeLoop;
    $edges = `ls -sl`;
    polyDelEdge -cv true -ch 1 $edges;
}

//-------------------------------------------------------------dkProxyGetJoints---------------------------------------------------------------------
global proc dkProxyGetJoints() {
    global string $dkProxyJoints[];
    select -hi;
    $dkProxyJoints = `ls -sl -type joint -visible`;
}    

//-------------------------------------------------------------dkProxy---------------------------------------------------------------------
//select faces on one object to create proxy out of selected faces
//name is derived from closest joint
global proc dkProxy(int $auto, int $cutJoints){
    global string $dkProxyJoints[];
    string $sels[], $array[], $object, $initialFaces, $faceAll, $proxy, $locator, $joints[], $closestJoint, $result, $name;
    float $lowestDistance;

    $sels = `ls -sl`;
    //finds object name
    $array = stringToStringArray($sels[0], ".");
    $object = $array[0];
    $initialFaces = $array[1];
    //finds out how many faces in object
    $array = `ls ($object + ".f[*]")`;
    $array = stringToStringArray($array[0], ".");
    $faceAll = $array[1];

    //finds the name of the closest joint
    if ($auto) {
        select -r $sels;
        $array = `nas_locator 0`;
        $locator = $array[0];
        if ($cutJoints && `objExists $dkProxyJoints[0]` && size($dkProxyJoints) > 1) $joints = $dkProxyJoints; 
        else $joints = `ls -type joint`;
        $lowestDistance = `nas_distance {$locator, $joints[0]}`;
        $closestJoint = $joints[0];
        for ($joint in $joints) {
            if (`nas_distance {$locator, $joint}` < $lowestDistance) {
                $closestJoint = $joint;
                $lowestDistance = `nas_distance {$locator, $joint}`;
            }
        }
        clear $array; $array[0] = $closestJoint;
        $joints = stringArrayRemove($array, $joints);
        $lowestDistance = `nas_distance {$locator, $joints[0]}`;
        $secondClosestJoint = $joints[0];
        for ($joint in $joints) if (`nas_distance{$locator, $joint}` < $lowestDistance) {
            $secondClosestJoint = $joint;
            $lowestDistance = `nas_distance{$locator, $joint}`;
        }
        delete $locator;
        $result = `confirmDialog -title "Which joint?" -message "What joint is this proxy for?" 
            -button $closestJoint -button $secondClosestJoint -button "Cancel" -defaultButton $closestJoint 
            -cancelButton "Cancel" -dismissString "Cancel"`;
        if ($result == $closestJoint) {
            $name = ("Proxy_" + `dkReplaceName "Rig Bind FK Jnt Joint" "Proxy \"\" Proxy Geo Geo" $closestJoint`);
            if ($closestJoint == $name) $name = ("Proxy_" + $closestJoint + "_Geo");
            print $name;
        }
        else if ($result == $secondClosestJoint) {
            $name = ("Proxy_" + `dkReplaceName "Rig Bind FK Jnt Joint" "Proxy \"\" Proxy Geo Geo" $secondClosestJoint`);
            if ($secondClosestJoint == $name) $name = ("Proxy_" + $secondClosestJoint + "_Geo");
            print $name;
        }
        else if ($result == "Cancel") {
            select -r $object;
            setSelectMode components Components;
            selectType -smp 0 -sme 0 -smf 1 -smu 0 -pv 0 -pe 0 -pf 1 -puv 0;
            select -r $sels;
            hilite -r $object;
            return;
        }
    } else {
        $name = "defaultName_Proxy";
    }
    //duplicates object and deletes unselected faces
    if ($initialFaces == $faceAll) {
        $proxy = `rename $object $name`;
        select -r $proxy;
    }
    else {
        select -cl;
        $array = `duplicate -n $name $object`; 
        $proxy = `rename $array[0] $name`;
        for ($sel in $sels) {
            $array = stringToStringArray($sel, ".");
            select -add ($proxy + "." + $array[1]);
        }
        select -tgl ($proxy + "." + $faceAll); $array = `ls -sl`; if (size($array)) delete;
        delete $sels;
    }
    $array = `listRelatives -p $proxy`;
    if (size($array[0])){
        setAttr -lock 0 ($proxy + ".tx");
        setAttr -lock 0 ($proxy + ".ty");
        setAttr -lock 0 ($proxy + ".tz");
        setAttr -lock 0 ($proxy + ".rx");
        setAttr -lock 0 ($proxy + ".ry");
        setAttr -lock 0 ($proxy + ".rz");
        setAttr -lock 0 ($proxy + ".sx");
        setAttr -lock 0 ($proxy + ".sy");
        setAttr -lock 0 ($proxy + ".sz");
        parent -w $proxy;
    }
    string $group = `group $proxy`;
    parent -w $proxy;
    delete $group;
    //sets selection mask to faces mode on original object
    if (`objExists $object`) {
        select -r $object;
        setSelectMode components Components;
        selectType -smp 0 -sme 0 -smf 1 -smu 0 -pv 0 -pe 0 -pf 1 -puv 0;
        hilite -r $object;
    }
}

//-------------------------------------------------------------dkClipboard---------------------------------------------------------------------
global proc dkClipboard(int $type) {
    global string $dkClipboardInfo[];
    string $array[], $sels[], $locs[];
    $sels = `ls -sl`;
    if ($type == 0) {
        for ($i = 1; $i < size($dkClipboardInfo); $i+=2) if (`objExists $dkClipboardInfo[$i]`) delete $dkClipboardInfo[$i];
        clear $dkClipboardInfo;
        for ($sel in $sels) {
            $dkClipboardInfo[size($dkClipboardInfo)] = $sel;
            select -r $sel; 
            $array = `nas_locator 1`;
            $dkClipboardInfo[size($dkClipboardInfo)] = $array[0];
        }
    } else if ($type == 1) {
        for ($i = 0; $i < size($dkClipboardInfo); $i+=2) {
            if (`objExists $dkClipboardInfo[$i]` && `objExists $dkClipboardInfo[$i+1]`) {
                select -r $dkClipboardInfo[$i+1] $dkClipboardInfo[$i];
                nas_matchTransforms 1 1 1 1 1 1 0 0 0;
            } else {
                warning ($dkClipboardInfo[$i] + " or " + $dkClipboardInfo[$i+1] + " does not exist. Please re-run dkClipboard 0.");
            }
        }
    } else if ($type == -1) {
        for ($sel in $sels) {
            for ($i = 0; $i < size($dkClipboardInfo); $i+=2) {
                if ($sel == $dkClipboardInfo[$i]) {
                    $array[0] = $dkClipboardInfo[$i];
                    $array[1] = $dkClipboardInfo[$i+1];
                    if (`objExists $dkClipboardInfo[$i+1]`) delete $dkClipboardInfo[$i+1];
                }
            $dkClipboardInfo = stringArrayRemove($array, $dkClipboardInfo);
            }
        }
        for ($i = 0; $i < size($dkClipboardInfo); $i+=2) print ($dkClipboardInfo[$i] + " " + $dkClipboardInfo[$i+1] + "\n");
    }
}

//-------------------------------------------------------------dkReplaceName---------------------------------------------------------------------
global proc string dkReplaceName(string $find, string $replace, string $name) {
    string $parts[], $finalName, $finds[], $replaces[];
    int $changed;
    $finds = stringToStringArray($find, ", ");
    $replaces = stringToStringArray($replace, ", ");
    $parts = stringToStringArray($name, "_");
    for ($i = 0; $i < size($finds); $i++) {
        if ($parts[0] == $finds[$i]) $finalName = $replaces[$i];
        else $finalName = $parts[0];
    }
    for ($i = 1; $i < size($parts); $i++) {
        $changed = 0;
        for ($j = 0; $j < size($finds); $j++) {
            if ($parts[$i] == $finds[$j]) {
                $finalName += ("_" + $replaces[$j]);
                $changed = 1;
                break;
            }
        }
        if (!$changed) $finalName += ("_" + $parts[$i]);
    }
    return $finalName;
}

//-------------------------------------------------------------dkOtherAttrs---------------------------------------------------------------------
global proc string[] dkOtherAttrs(string $attr) {
    string $otherAttrs[];
    if ($attr == "tx") $otherAttrs = {"ty", "tz"};
    if ($attr == "ty") $otherAttrs = {"tx", "tz"};
    if ($attr == "tz") $otherAttrs = {"tx", "ty"};
    if ($attr == "rx") $otherAttrs = {"ry", "rz"};
    if ($attr == "ry") $otherAttrs = {"rx", "rz"};
    if ($attr == "rz") $otherAttrs = {"rx", "ry"};
    if ($attr == "sx") $otherAttrs = {"sy", "sz"};
    if ($attr == "sy") $otherAttrs = {"sx", "sz"};
    if ($attr == "sz") $otherAttrs = {"sx", "sy"};
    return $otherAttrs;
}

//-------------------------------------------------------------dkTimeLeft---------------------------------------------------------------------
global proc dkTimeLeft(float $startTime, int $num, int $totalNum) {
    float $aveTime, $prediction, $totalTime;
    int $minutes, $seconds;
    
    $totalTime = `timerX -st $startTime`;
    $aveTime = $totalTime/($num+1);
    $prediction = $aveTime * ($totalNum-$num);
    $minutes = $prediction/60;
    $seconds = $prediction - ($minutes*60);
    print ("\n" + $minutes + " minutes and " + $seconds + " seconds remain.");
    
    if ($num == $totalNum-1) {
        $totalTime = `timerX -st $startTime`;
        $minutes = $totalTime/60;
        $seconds = $totalTime - ($minutes*60);
        print ("\n" + $minutes + " minutes and " + $seconds + " have elapsed. Job done.");
    }
}

//-------------------------------------------------------------dkOrganize---------------------------------------------------------------------
global proc dkOrganize(string $axis, float $value) {
    string $sels[];
    float $defaultValue, $bb[];
    vector $axisVec;
    
    $axis = `dkLowercaseAxis $axis`;
    $sels = `ls -sl`;
    $defaultValue = `getAttr ($sels[0] + ".t" + $axis)`;
    $axisVec = `nas_axisToVector $axis`;
    $bb = `nas_boundingBox {$sels[0]}`;
    if ($axis == "x") $value += ($bb[3]-$bb[0]);
    if ($axis == "y") $value += ($bb[4]-$bb[1]);
    if ($axis == "z") $value += ($bb[5]-$bb[2]);
    
    for ($i = 1; $i < size($sels); $i++) {
        setAttr ($sels[$i] + ".t" + $axis) $defaultValue;
        move -r (($axisVec.x)*($value*$i)) (($axisVec.y)*($value*$i)) (($axisVec.z)*($value*$i)) $sels[$i];
    }
}

//-------------------------------------------------------------dkExtractBlendshapes---------------------------------------------------------------------
global proc dkExtractBlendshapes(string $geo, string $blendshape) {
    string $shapes[], $array[], $geos[], $hists[], $deformers[];
    float $boundBoxInfos[], $value, $envelopes[];

    $hists = `listHistory -il 2 -pdo 1 $geo`;
    for ($hist in $hists) {
        if (`objExists ($hist + ".envelope")`) {
            $deformers[size($deformers)] = $hist;
            $envelopes[size($envelopes)] = `getAttr ($hist + ".envelope")`;
            catch(`setAttr ($hist + ".envelope") 0`);
        }
    }
    
    setAttr ($blendshape + ".envelope") 1;
    $shapes = `listAttr -multi ($blendshape + ".w")`;
    for ($shape in $shapes) setAttr ($blendshape + "." + $shape) 0;
    for ($i = 0; $i < size($shapes); $i++) {
        setAttr ($blendshape + "." + $shapes[$i]) 1;
        $array = `duplicate -n $shapes[$i] $geo`;
        $geos[$i] = $array[0];
        setAttr ($blendshape + "." + $shapes[$i]) 0;
        setAttr -lock 0 ($geos[$i] + ".tx");
        setAttr -lock 0 ($geos[$i] + ".ty");
        setAttr -lock 0 ($geos[$i] + ".tz");
        setAttr -lock 0 ($geos[$i] + ".rx");
        setAttr -lock 0 ($geos[$i] + ".ry");
        setAttr -lock 0 ($geos[$i] + ".rz");
        setAttr -lock 0 ($geos[$i] + ".sx");
        setAttr -lock 0 ($geos[$i] + ".sy");
        setAttr -lock 0 ($geos[$i] + ".sz");
    }
    select -r $geos; dkOrganize x 1.5;
    move -r $value 0 0;
    for ($i = 0; $i < size($deformers); $i++) {
        catch(`setAttr ($deformers[$i] + ".envelope") $envelopes[$i]`);
    }
}

//-------------------------------------------------------------dkTransferDeformers---------------------------------------------------------------------
global proc dkTransferDeformers(string $sourceDeformersList, string $targetDeformersList, string $geosList) {
    string $sourceDeformers[], $targetDeformers[], $geos[], $sels[];
    $sourceDeformers = stringToStringArray($sourceDeformersList, ", ");
    $targetDeformers = stringToStringArray($targetDeformersList, ", ");
    $geos = stringToStringArray($geosList, ", ");
    $sels = `ls -sl`;
    for ($i = 0; $i < size($sourceDeformers); $i++) {
        select -r $sels;
        if (size($geos) == 1) {
            if ($targetDeformers[$i] == "") dkDeformerWeights $sourceDeformers[$i] $sourceDeformers[$i] $geos[0] $geos[0];
            else dkDeformerWeights $sourceDeformers[$i] $targetDeformers[$i] $geos[0] $geos[0];
        } else if (size($geos) == 2) {
            if ($targetDeformers[$i] == "") dkDeformerWeights $sourceDeformers[$i] $sourceDeformers[$i] $geos[0] $geos[1];
            else dkDeformerWeights $sourceDeformers[$i] $targetDeformers[$i] $geos[0] $geos[1];
        }
    }
}

//-------------------------------------------------------------dkModelingHotkeys---------------------------------------------------------------------
global proc dkModelingHotkeyCommands() {
    string $runTimeCommands[], $cmd, $alreadyLoaded[], $justLoaded[];
    $runTimeCommands = { 
    "Change sculpt tool to normal", "User", "dkSculptPolygonOptions normal 0;dkSculptPolygonOptions pull 0", "dkSculptPullNormal",  
    "Change sculpt tool to xaxis", "User", "dkSculptPolygonOptions xaxis 0;dkSculptPolygonOptions pull 0", "dkSculptPullXaxis", 
    "Change sculpt tool to yaxis", "User", "dkSculptPolygonOptions yaxis 0;dkSculptPolygonOptions pull 0", "dkSculptPullYaxis", 
    "Change sculpt tool to zaxis", "User", "dkSculptPolygonOptions zaxis 0;dkSculptPolygonOptions pull 0", "dkSculptPullZaxis",  
    "Clears the hypershade graph", "User", "hyperShadePanelGraphCommand hyperShadePanel1 clearGraph", "dkClearGraph", 
    "Adds selection to hypershade graph", "User", "hyperShadePanelGraphCommand hyperShadePanel1 addSelected", "dkAddSelectionToGraph"
    };
    
    for ($i = 0; $i < size($runTimeCommands); $i+=4) {
        $cmd = ("runTimeCommand -annotation \"" + $runTimeCommands[$i] + "\" -category \"" + $runTimeCommands[$i+1] + "\" -command \(\"" + $runTimeCommands[$i+2] + "\"\) " + $runTimeCommands[$i+3] + ";");
        print $cmd;
        if (catchQuiet(`eval $cmd`)) {
            $alreadyLoaded[size($alreadyLoaded)] = $runTimeCommands[$i+3];
            runTimeCommand -e -delete $runTimeCommands[$i+3];
            catchQuiet(`eval $cmd`);
        } else $justLoaded[size($justLoaded)] = ($runTimeCommands[$i+3] + " has been loaded.");
        $cmd = ("nameCommand -annotation \"" + $runTimeCommands[$i+3] + "NameCommand\" -command \(\"" + $runTimeCommands[$i+3] + "\"\) " + $runTimeCommands[$i+3] + "NameCommand;");
        eval $cmd;
    }
    
    if (size($alreadyLoaded)) {
        print "The following runTime commands were already loaded:\n";
        print $alreadyLoaded;
        print "\n";
    }
    if (size($justLoaded)) {
        print "The following runTime commands have been loaded:\n";
        print $alreadyLoaded;
        print "Check Script Editor to see which runtime commands loaded.";
    }
}

global proc dkModelingHotkeys(int $overwrite) {
    //add x-ray mode, wireframe on shaded mode, and dkDisplayWireframeToggle
    string $hotKeys[], $cmd, $hotkey, $newHotKeys[], $oldHotKeys[], $annotation;
    $hotKeys = {
        "Q",                     "",                 "",                "dkSculptPullNormalNameCommand", 
        "W",                     "",             "",                 "dkSculptPullXaxisNameCommand",  
        "E",                     "",             "",             "dkSculptPullYaxisNameCommand",  
        "R",                     "",             "",             "dkSculptPullZaxisNameCommand",  
        "-",                    " -ctl",     "",             "dkClearGraphNameCommand", 
        "=",                     " -ctl",     "",             "dkAddSelectedToGraphNameCommand"
    };
    for ($i = 0; $i < size($hotKeys); $i+=4) {
        $hotkey = "";
        if (size($hotKeys[$i+1]) > 0) $hotkey += "ctrl + ";
        if (size($hotKeys[$i+2]) > 0) $hotkey += "alt + ";
        $hotkey += $hotKeys[$i];
         
        if ($overwrite) {
            if ($hotKeys[$i+3] == "dkKeysPopupMenuReleaseNameCommand") {
                $cmd = ("hotkey -keyShortcut \"" + $hotKeys[$i] + "\" -releaseName \(\"dkKeysPopupMenuReleaseNameCommand\"\)");
                eval $cmd;
                $newHotKeys[size($newHotKeys)] = ($hotkey + " assigned to execute " + $hotKeys[$i+3] + "!");
            } else {
                $cmd = ("hotkey -keyShortcut \"" + $hotKeys[$i] + "\"" + $hotKeys[$i+1] + $hotKeys[$i+2] + " -name \(\"" + $hotKeys[$i+3] + "\"\);");
                eval $cmd;
                $newHotKeys[size($newHotKeys)] = ($hotkey + " assigned to execute " + $hotKeys[$i+3] + "!");
            }
        } else {
            $cmd = ("hotkeyCheck -key \"" + $hotKeys[$i] + "\"" + $hotKeys[$i+1] + $hotKeys[$i+2] + ";");
            $annotation = `eval $cmd`;
            if (size($annotation)) $oldHotKeys[size($oldHotKeys)] = ($hotkey + " is already assigned to execute " + $hotKeys[$i+3] + "!");
            else {
                if ($hotKeys[$i+3] == "dkKeysPopupMenuReleaseNameCommand") {
                    $cmd = ("hotkey -keyShortcut \"" + $hotKeys[$i] + "\" -releaseName \(\"dkKeysPopupMenuReleaseNameCommand\"\)");
                    eval $cmd;
                    $newHotKeys[size($newHotKeys)] = ($hotkey + " assigned to execute " + $hotKeys[$i+3] + "!");
                } else {
                    $cmd = ("hotkey -keyShortcut \"" + $hotKeys[$i] + "\"" + $hotKeys[$i+1] + $hotKeys[$i+2] + " -name \(\"" + $hotKeys[$i+3] + "\"\);");
                    eval $cmd;
                    $newHotKeys[size($newHotKeys)] = ($hotkey + " assigned to execute " + $hotKeys[$i+3] + "!");
                }
            }
        }
    }
    if (size($oldHotKeys)) {
        print "\n\nThe following hotkeys are already set in your hotkey editor:\n\n";
        print $oldHotKeys;
        print "\n";
    }
    if (size($newHotKeys)) {
        print "The following hotkeys were installed:\n\n";
        print $newHotKeys;
        print "\n";
    } else print "No new hotkeys were installed";
}

//-------------------------------------------------------------dkSculptPolygonOptions---------------------------------------------------------------------
global proc dkSculptPolygonOptions(string $type, float $amount) {
    switch ($type) {
        case "push":
            artPuttyCtx -e -mtm "push" artPuttyContext;
            break;
        case "pull":
            artPuttyCtx -e -mtm "pull" artPuttyContext;
            break;
        case "smooth":
            artPuttyCtx -e -mtm "smooth" artPuttyContext;
            break;
        case "normal":
            artPuttyCtx -e -refvector "normal" artPuttyContext;
            break;
        case "xaxis":
            artPuttyCtx -e -refvector "xaxis" artPuttyContext;
            break;
        case "yaxis":
            artPuttyCtx -e -refvector "yaxis" artPuttyContext;
            break;
        case "zaxis":
            artPuttyCtx -e -refvector "zaxis" artPuttyContext;
            break;
        case "opacity":
            artPuttyCtx -e -opacity $amount artPuttyContext;
            break;
        case "maxdisp":
            artPuttyCtx -e -maxdisp $amount artPuttyContext;
            break;
    }
}

//-------------------------------------------------------------dkPrintWorldspace---------------------------------------------------------------------
global proc dkPrintWorldspace() {
    string $array[];
    vector $ws;
    $array = `ls -sl`;
    for ($i in $array) {
        $ws = `xform -q -translation -ws $i`;
        print ($ws + "\n");
    }
}

//-------------------------------------------------------------dkDeformerAttrs---------------------------------------------------------------------
global proc dkDeformerAttrs() {
    string $array[], $names[], $wires[];
    $array = `ls -sl`;
    $names = {"SpineDeformControls", "LeftArmDeformControls", "RightArmDeformControls", "LegDeformControls"};
    $wires = {"Spine_Wire", "LT_Arm_Wire", "RT_Arm_Wire", "LT_Leg_Wire", "RT_Leg_Wire"};
    $groups = {"Spine_Deformer_Ctrl_Group", "LT_Arm_Deformer_Ctrl_Group", "RT_Arm_Deformer_Ctrl_Group", "LT_Leg_Deformer_Ctrl_Group", "RT_Leg_Deformer_Ctrl_Group"};
    for ($name in $names) {
        addAttr -ln $name  -at "enum" -en "Off:On:"  $array[0];
        setAttr -e-keyable true ($array[0] + "." + $name);
    }
    for ($i = 0; $i < size($names); $i++) {
        connectAttr ($array[0] + "." + $names[$i]) ($wires[$i] + ".envelope");
        connectAttr ($array[0] + "." + $names[$i]) ($groups[$i] + ".v");
        if ($i == size($names)-1) {
            connectAttr ($array[0] + "." + $names[$i]) ($wires[$i+1] + ".envelope");
            connectAttr ($array[0] + "." + $names[$i]) ($groups[$i+1] + ".v");
        }
    }
}

//-------------------------------------------------------------dkRenameRight---------------------------------------------------------------------
global proc dkRenameRight() {
    string $sels[], $array[], $name;
    $sels = `ls -sl`;
    $sels = `dkSortMultiple 2 $sels`;
    for ($i = size($sels)-1; $i >= 0; $i-=2) {
        $array = stringToStringArray($sels[$i-1], "_");
        stringArrayRemoveAtIndex(0, $array);
        $name = stringArrayToString ($array, "_");
        $name = ("RT_" + $name);
        rename $sels[$i] $name;
    }
}

//-------------------------------------------------------------dkReturnPrefix---------------------------------------------------------------------
global proc string dkReturnPrefix(int $numTokens, string $name) {
    string $prefix, $array[];
    $array = stringToStringArray($name, "_");
    $prefix = ($array[0] + "_");
    for ($i = 1; $i < $numTokens; $i++) $prefix += ($array[$i] + "_");
    return $prefix;
}

//-------------------------------------------------------------dkSetPreferredAngle---------------------------------------------------------------------
//originally concieved by Nick Puetz, further modified by David Taegyu Kim
global proc float dkSetPreferredAngle(string $joints[], int $iter) {
    string $array[], $testJoints[], $startJoint, $endJoint, $lastJoint;
    float $lowestRot, $totalRot, $prefAngle, $rot;
    int $startNum, $limitNum;
    
    $startJoint = $joints[0];
    $endJoint = $joints[1];
    $lastJoint = $endJoint;

    for ($i = 0; $i < 20; $i++) {
        $array = `listRelatives -p -type "joint" $lastJoint`;
        if (size($array) && $array[0] != $startJoint) $testJoints[size($testJoints)] = $array[0];
        else break;
        $lastJoint = $array[0];
    }
    
    $lowestRot = 999999999.99;
    if ($iter < 0) {
        $startNum = $iter;
        $limitNum = 1;
    } else if ($iter > 0) {
        $startNum = 1;
        $limitNum = $iter;
    }
    
    for ($i = $startNum; $i < $limitNum; $i++) {
        for ($testJoint in $testJoints) setAttr ($testJoint + ".preferredAngleY") ($i/10.0);
        $array = `ikHandle -sj $startJoint -ee $endJoint`;
        $totalRot = 0;
        for ($testJoint in $testJoints) {
            $rot = `getAttr ($testJoint + ".rx")`;
            $totalRot += abs($rot);
            $rot = `getAttr ($testJoint + ".ry")`;
            $totalRot += abs($rot);
            $rot = `getAttr ($testJoint + ".rz")`;
            $totalRot += abs($rot);
        }
        if ($totalRot < $lowestRot) {
            $prefAngle = ($i/10.0);
            $lowestRot = $totalRot;
        }
        if ($i%20 == 0) flushUndo;
        delete $array[0];
        for ($testJoint in $testJoints) setAttr ($testJoint + ".r") 0 0 0;
        setAttr ($startJoint + ".r") 0 0 0;
        setAttr ($endJoint + ".r") 0 0 0;
    }
    if ($prefAngle != 0) for ($testJoint in $testJoints) setAttr ($testJoint + ".preferredAngleY") $prefAngle;
    else for ($testJoint in $testJoints) setAttr ($testJoint + ".preferredAngleY") 1;
    return $prefAngle;
}

//-------------------------------------------------------------dkZeroOutJoints---------------------------------------------------------------------
global proc dkZeroOutJoints(string $joints[]) {
    float $rots[];
    for ($joint in $joints) {
        $rots = `getAttr ($joint + ".rotate")`;
        setAttr ($joint + ".rotate") 0 0 0;
        setAttr ($joint + ".jointOrient") $rots[0] $rots[1] $rots[2];
    }
}

//-------------------------------------------------------------dkRTCtrlsReverse---------------------------------------------------------------------
//select controls then translate clusters then rotate clusters
global proc dkRTCtrlsReverse() {
    string $sels[], $mdn, $array[];
    $sels = `ls -sl`;
    $sels = `dkSortMultiple 3 $sels`;
    for ($i=0;$i<size($sels);$i+=3) {
        $array = `pickWalk -d up $sels[$i]`;
        setAttr ($array[0] + ".rotateAxisX") 180;
        $mdn = `createNode -n ($sels[$i+1] + "_Translate_Mdn") multiplyDivide`;
        connectAttr ($sels[$i] + ".translate") ($mdn + ".input1");
        setAttr ($mdn + ".input2X") 1;
        setAttr ($mdn + ".input2Y") -1;
        setAttr ($mdn + ".input2Z") -1;
        if (`isConnected -iuc ($sels[$i] + ".tx") ($sels[$i+1] + ".tx")`) disconnectAttr ($sels[$i] + ".tx") ($sels[$i+1] + ".tx");
        if (`isConnected -iuc ($sels[$i] + ".ty") ($sels[$i+1] + ".ty")`) disconnectAttr ($sels[$i] + ".ty") ($sels[$i+1] + ".ty");
        if (`isConnected -iuc ($sels[$i] + ".tz") ($sels[$i+1] + ".tz")`) disconnectAttr ($sels[$i] + ".tz") ($sels[$i+1] + ".tz");
        connectAttr -f ($mdn + ".output") ($sels[$i+1] + ".translate");
        $mdn = `createNode -n ($sels[$i+2] + "_Rotate_Mdn") multiplyDivide`;
        connectAttr ($sels[$i] + ".rotate") ($mdn + ".input1");
        setAttr ($mdn + ".input2X") 1;
        setAttr ($mdn + ".input2Y") -1;
        setAttr ($mdn + ".input2Z") -1;
        if (`isConnected -iuc ($sels[$i] + ".rx") ($sels[$i+1] + ".rx")`) disconnectAttr ($sels[$i] + ".rx") ($sels[$i+1] + ".rx");
        if (`isConnected -iuc ($sels[$i] + ".ry") ($sels[$i+1] + ".ry")`) disconnectAttr ($sels[$i] + ".ry") ($sels[$i+1] + ".ry");
        if (`isConnected -iuc ($sels[$i] + ".rz") ($sels[$i+1] + ".rz")`) disconnectAttr ($sels[$i] + ".rz") ($sels[$i+1] + ".rz");
        connectAttr -f ($mdn + ".output") ($sels[$i+2] + ".rotate");
    }
}

//-------------------------------------------------------------dkAim---------------------------------------------------------------------
//select three objects and run
//the second object will aim at the first object and the third object will act as the up object
global proc dkAim(string $aimAxis, string $upAxis, string $worldUpAxis) {
    string $locs[];
    vector $aimVector, $upVector;
    $locs = `ls -sl -long`;
    $aimVector = `nas_axisToVector $aimAxis`;
    $upVector = `nas_axisToVector $upAxis`;
    $worldUpVector = `nas_axisToVector $worldUpAxis`;
    if (size($locs) == 3) {
        delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector ($aimVector.x) ($aimVector.y) ($aimVector.z) -upVector ($upVector.x) ($upVector.y) ($upVector.z) -worldUpType "object" -worldUpObject $locs[2] $locs[0] $locs[1]`;
    } else if (size($locs) == 2) {
        delete `aimConstraint -offset 0 0 0 -weight 1 -aimVector ($aimVector.x) ($aimVector.y) ($aimVector.z) -upVector ($upVector.x) ($upVector.y) ($upVector.z) -worldUpType "vector" -worldUpVector ($worldUpVector.x) ($worldUpVector.y) ($worldUpVector.z) $locs[0] $locs[1]`;
    } else {
        error "please select two or three objects before running dkAim.";
    }
}

//-------------------------------------------------------------dkConnectBlendshapes---------------------------------------------------------------------
//select the ctrl followed by the blendshape and run
global proc dkConnectBlendshapes(string $attr, string $weight1, string $weight2) {
    string $mdn, $clamp, $ctrl, $array[];
    $array = `ls -sl`;
    $ctrl = $array[0];
    $blendshape = $array[1];
    $mdn = `createNode -n ($attr + "_Mdn") multiplyDivide`;
    $clamp = `createNode -n ($attr + "_Clamp") clamp`;
    connectAttr ($ctrl + "." + $attr) ($mdn + ".input1X");
    setAttr ($mdn + ".input2X") -1;
    connectAttr -f($mdn + ".outputX") ($clamp + ".inputR");
    connectAttr -f ($mdn + ".outputX") ($clamp + ".maxR");
    connectAttr -f ($ctrl + "." + $attr) ($clamp + ".inputG");
    connectAttr -f ($ctrl + "." + $attr) ($clamp + ".maxG");
    connectAttr -f ($clamp + ".outputR") ($blendshape + "." + $weight1);
    connectAttr -f ($clamp + ".outputG") ($blendshape + "." + $weight2);
    select -r $ctrl $blendshape;
}

//-------------------------------------------------------------dkInbetweenBlendshapes---------------------------------------------------------------------
//blends followed by target
global proc dkInbetweenBlendshapes(string $blendshape, float $weight) {
    string $blendGeos[], $targetGeo, $array[];
    $array = `ls -sl`;
    $targetGeo = $array[size($array)-1];
    $blendGeos = stringArrayRemove ({$targetGeo}, $array);
    for ($i = 0; $i < size($blendGeos); $i++) blendShape -e -ib -t $targetGeo $i $blendGeos[$i] $weight $blendshape;
}

//-------------------------------------------------------------dkConnectSmooths---------------------------------------------------------------------
global proc dkConnectSmooths() {
    string $smooths[], $array[];
    //$array = `ls -sl`;
    $smooths = `ls -type polySmoothFace`;
    for ($smooth in $smooths) {
        if (`objExists "Transform.Smooth"`) {
            catch(`connectAttr -f ("Transform.Smooth") ($smooth + ".divisions")`);
        } else {
            $array = `ls "*Transform"`;
            for ($item in $array) catch(`connectAttr -f ($item + ".Smooth") ($smooth + ".divisions")`);
        }
                
        setAttr ($smooth + ".smoothUVs") 1;
        setAttr ($smooth + ".keepBorder") 0;
        setAttr ($smooth + ".keepSelectionBorder") 0;
        setAttr ($smooth + ".keepHardEdge") 0;
        setAttr ($smooth + ".keepMapBorders") 0;
    }
}

//-------------------------------------------------------------dkExtrapToJoints---------------------------------------------------------------------
//select controls and run
global proc string[] dkExtrapToJoints(float $percent, string $verts[]) {
    string $sels[], $ctrls[], $cluster, $clusterHandle, $clusterHandles[], $clusterName, $array[], $shape, $deformer, $clusters[], 
    $groups[], $group, $joint, $geo, $joints[], $skinCluster, $targetVerts[], $skinVerts[], $geos[], $skinClusters[], $cmd, $skinJoints[];
    float $term_x, $term_y, $term_z, $weight, $weights[], $uniqueWeights[], $float, $dupeWeights[];
    int $numVerts, $first, $count, $holds[];
    vector $wp, $baseWp[], $deformWp[], $vec1, $vec2;
    
    $ctrls = `ls -sl`;

    //find geo names
    for ($i = 0; $i < size($verts); $i++) {
        $array = stringToStringArray($verts[$i], ".");
        $geos[$i] = $array[0];
    }
    $geos = `stringArrayRemoveDuplicates $geos`;
    
    //extrap for each geo separately
    for ($geo in $geos) {
        clear $skinVerts;
        clear $weights;
        clear $targetVerts;
        clear $joints;

        //get verts for current geo
        for ($vert in $verts) {
            $array = stringToStringArray($vert, ".");
            if ($array[0] == $geo) $skinVerts[size($skinVerts)] = $vert;
        }
        $numVerts = size($skinVerts);
        
        //get joints from skin cluster
        $skinCluster = `nas_getSkinCluster $geo`;
        
        if (`objExists $skinCluster`) {
            $skinJoints = `skinPercent -q -t $skinCluster $skinVerts`;
        } else {
            for ($ctrl in $ctrls) {
                $array = nas_getDeformerVerts($ctrl);
                if (size($array)) {
                    select -r $array;
                    $skinJoints = stringArrayCatenate(`nas_influencesFromVerts`, $skinJoints);
                }
            }
            select -r $skinJoints $geo;
            $skinCluster = `nas_skinCluster`;
        }
        for ($i = 0; $i < size($skinJoints); $i++) {
            $holds[$i] = `getAttr ($skinJoints[$i] + ".liw")`;
            setAttr ($skinJoints[$i] + ".liw") 0;
        }

        //find each ctrl's corresponding joint
        for ($ctrl in $ctrls) $joints[size($joints)] = `nas_findClosest $ctrl $skinJoints`;
        
        //get non-zero weights and transfer to joints
        for ($i = 0; $i < size($ctrls); $i++) {
            //get weights for current ctrl
            setAttr ($ctrls[$i] + ".tx") 0;
            for($j=0;$j<$numVerts;$j++) $baseWp[$j] = `xform -query -translation -worldSpace $skinVerts[$j]`;
            setAttr ($ctrls[$i] + ".tx") 1;
            for($j=0;$j<$numVerts;$j++) {
                $vec1 = $baseWp[$j];
                $vec2 = `xform -query -translation -worldSpace $skinVerts[$j]`;
                $term_x = `pow(($vec2.x)-($vec1.x)) 2`; 
                $term_y = `pow(($vec2.y)-($vec1.y)) 2`; 
                $term_z = `pow(($vec2.z)-($vec1.z)) 2`;
                $weight = sqrt($term_x + $term_y + $term_z);
                $weights[size($weights)] = $weight;
                $targetVerts[size($targetVerts)] = $skinVerts[$j];
            }
            setAttr ($ctrls[$i] + ".tx") 0;
        }
        
        skinPercent -normalize off -pruneWeights 100 $skinCluster $skinVerts;
        //----insert old script here
        //nas_progress $numVerts "start";
        nas_progress $numVerts "start";
        //weight verts that don't have the same weighting on one joint
        for ($i = 0; $i < $numVerts; $i++) {
            $cmd =  "skinPercent -normalize off ";
            for ($j = 0; $j < size($ctrls); $j++) {
                if ($weights[($numVerts * $j) + $i] != 0) $cmd += ("-tv " + $joints[$j] + " " + $weights[($numVerts * $j) + $i] + " ");
            }
            $cmd += ($skinCluster + " " + $targetVerts[$i] + ";");
            //if (`nas_progress 0 (((size($geos))-$count) + " geos left: " + $targetVerts[$i] + ". ")`) return {};
            if (`nas_progress 0 ("skinning weights for " + $targetVerts[$i] + ", " + ((size($geos))-$count) + " geos left")`) return {};
            //print $cmd;
            eval $cmd;
        }
        skinPercent -normalize on $skinCluster $skinVerts;
        nas_progress 0 "end";
        $skinClusters[size($skinClusters)] = $skinCluster;
        $count++;
        for ($i = 0; $i < size($holds); $i++) if (`objExists ($skinJoints[$i] + ".liw")`) setAttr ($skinJoints[$i] + ".liw") $holds[$i];
    }
    $joints = stringArrayRemoveDuplicates($joints);
    $array = stringArrayCatenate($joints, $skinClusters);
    return $array;
}

//-------------------------------------------------------------dkShaderMatches---------------------------------------------------------------------
global proc dkShaderMatches() {
    string $array[], $shaderLoc, $shaderFileList, $shaderFiles[], $removeFolders[], $matches[], $fails[], $messages[], $shaders[], $finalOutput, $window, $form, $text, $files[];
    int $match;
    $shaders = `ls -sl`;
    $shaders = `sort $shaders`;

    $array = stringToStringArray(`file -q -sn`, "/");
    stringArrayRemoveAtIndex(size($array)-1, $array);
    if ($array[0] == "P:") {
        $array[2] = "renderData/shaders";
    } else {
        if ($array[1] == "Fanboy") $array[3] = "renderData/shaders";
        else if ($array[1] == "KFP") $array[3] = "renderData/shaders";
    }
    $removes = {"Old", "Rig", "Clean", "old", "rig", "clean", "Rigging", "WIP"};
    for ($remove in $removes) {
        for ($i = 0; $i < size($array); $i++) if ($array[$i] == $remove) {
            stringArrayRemoveAtIndex($i, $array);
            break;
        }
    }

    $files = `getFileList -folder ((stringArrayToString($array, "/")) + "/")`;
    for ($file in $files) {
        $array = stringToStringArray($file, ".");
        if ($array[1] == "ma") $shaderFiles[size($shaderFiles)] = $file;
    }
    $shaderFiles = `sort $shaderFiles`;
    
    for ($shader in $shaders) {
        $match = 0;
        for ($file in $shaderFiles) {
            $array = stringToStringArray($file, ".");
            if ($shader == $array[0]) {
                $matches[size($matches)] = ($shader + " = " + $file);
                $shaderFiles = stringArrayRemove({$file}, $shaderFiles);
                $match = 1;
                break;
            }
        }
        if ($match == 0) $fails[size($fails)] = $shader;
    }

    $finalOutput = "Could not match shader file to:\n";
    $finalOutput += stringArrayToString($fails, "\n");
    $finalOutput += "\n\n";
    $finalOutput += "The following shaders match:\n";
    $finalOutput += stringArrayToString($matches, "\n");
    $finalOutput += "\n\n";
    $finalOutput += "Files left in shader folder:\n";
    $finalOutput += stringArrayToString($shaderFiles, "\n");

    if (size($fails) || size($matches) || size($matches)) {
        $window = `nas_window dkMatchShaders 1 0 0`;
        $form = `formLayout`;
            $text = `text -label $finalOutput`;
            setParent..;
        formLayout -e 
            -af $text "top" 5
            -af $text "left" 5
            -af $text "right" 5
            -af $text "bottom" 5 
            $form;
        window -e -rtf 1 $window;
        showWindow $window;
    }
    if (size($fails)) error "No files found for one or more selected shaders. Please check shader match window.";
}

//-------------------------------------------------------------dkImportShaders---------------------------------------------------------------------
global proc dkImportShaders() {
    string $shaders[], $faces[], $shaderLoc, $array[], $sceneName, $shaderFiles[], $shadingGroup, $name, $smoothProxies[], $parts[], $matchedShaders[], $removeFolders[];
    $shaders = `ls -sl`;
    $sceneName = `file -q -sceneName`;
    $array = stringToStringArray($sceneName, "/");
    stringArrayRemoveAtIndex(size($array)-1, $array);
    if ($array[0] == "P:") {
        $array[2] = "renderData/shaders";
    } else {
        if ($array[1] == "Fanboy") $array[3] = "renderData/shaders";
        else if ($array[1] == "KFP") $array[3] = "renderData/shaders";
    }
    $removeFolders = {"Old", "Rig", "Clean", "old", "rig", "clean", "Rigging", "WIP"};
    for ($removeFolder in $removeFolders) {
        for ($i = 0; $i < size($array); $i++) if ($array[$i] == $removeFolder) {
            stringArrayRemoveAtIndex($i, $array);
            break;
        }
    }
    $shaderLoc = stringArrayToString($array, "/");
    $shaderLoc += "/";
    $shaderFiles = `getFileList -folder $shaderLoc`;
    
    for ($shader in $shaders) {
        $shadingGroup = "";
        if (`objExists ($shader + ".outColor")`) $array = `listConnections -s on ($shader + ".outColor")`;
        else $array = `listConnections -s on ($shader + ".message")`;
        for ($item in $array) {
            if (`nodeType $item` == "shadingEngine") {
                $shadingGroup = $item;
                break;
            }
        } 
        hyperShade -objects $shader;
        $faces = `ls -sl`;
        for ($face in $faces) {
            $parts = stringToStringArray($face, "_.");
            for ($part in $parts) {
                if ($part == "SmoothProxy" || $part == "SmoothProxyShape") {
                    $smoothProxies[size($smoothProxies)] = $face;
                    break;
                }
            }
        }
        $faces = stringArrayRemove($smoothProxies, $faces);
        for ($shaderFile in $shaderFiles) {
            $array = stringToStringArray($shaderFile, ".");
            if ($array[0] == $shader) {
                $matchedShaders[size($matchedShaders)] = $shader;
                if (size($smoothProxies)) {
                    $array = stringToStringArray($shader, "_");
                    $name = $array[0];
                    for ($i = 1; $i < size($array)-1; $i++) $name += ("_" + $array[$i]);
                    if ($array[size($array)-1] == "Shader" || $array[size($array)-1] == "LayeredShader") $name += ("_SmoothProxy_" + $array[size($array)-1]);
                    else $name += ("_SmoothProxy_Shader");
                    rename $shader $name;
                } else {
                    delete $shader;
                }
                //if ($shadingGroup != "") delete $shadingGroup;
                file -import -type "mayaAscii" -gr -rdn -rpr $shader -options "v=0" -pr -loadReferenceDepth "all" ($shaderLoc + $shader + ".ma");
                select -r $faces;
                hyperShade -assign $shader;
            }
        }
    }
    $array = stringArrayRemove($matchedShaders, $shaders);
    if (size($array)) {
        print "\nCould not find the following shaders in renderData\\shaders folder:\n";
        print $array;
        print "\n";
        error "Some shaders were not found, check script editor for details";
    }
    for ($i = 0; $i < size($shaderFiles); $i++) {
        $array = stringToStringArray($shaderFiles[$i], ".");
        $shaderFiles[$i] = $array[0];
    }
    $array = stringArrayRemove($matchedShaders, $shaderFiles);
    if (size($array)) {
        print "\nJust in case, here are the shader files that were not used when importing shaders this time around:\n";
        print $array;
    }
        
    dkRenameShadingNodes;
}

//-------------------------------------------------------------dkRemoveUnusedShadingNodes---------------------------------------------------------------------
global proc dkRemoveUnusedShadingNodes() {
    string $infos[], $name, $array[], $shader, $shadingGroup, $deletedShaders[];
    $infos = `ls -type materialInfo`;
    $infos = stringArrayRemove({"initialMaterialInfo"}, $infos);
    select -cl;
    for ($i = 0; $i < size($infos); $i++) {
        $array = stringToStringArray($infos[$i], ":");
        if (size($array) == 1) {
            $shadingGroup = `connectionInfo -sfd ($infos[$i] + ".shadingGroup")`;
            $array = stringToStringArray ($shadingGroup, ".");
            $shadingGroup = $array[0];
            if (`objExists ($shadingGroup + ".surfaceShader")`) {
                $array[0] = `connectionInfo -sfd ($shadingGroup + ".surfaceShader")`;
                $array = stringToStringArray($array[0], ".");
                $shader = $array[0];
                if ($shader == "") {
                    delete $infos[$i];
                    delete $shadingGroup;
                } else {
                    hyperShade -objects $shader;
                    if (size(`ls -sl`) == 0) {
                        if (`objExists $shader`) delete $shader;
                        if (`objExists $shadingGroup`) delete $shadingGroup;
                        if (`objExists $infos[$i]`) delete $infos[$i];
                        $deletedShaders[size($deletedShaders)] = $shader;
                    }
                }
            }
        }
    }
    if (size($deletedShaders)) {
        print "\nDeleted the following shaders:\n";
        for ($deletedShader in $deletedShaders) print ($deletedShader + "\n");
        print "Deleted some shaders. Check Script Editor for details.";
    } else {
        print "\n";
        print "All shaders are being used in this scene.";
    }
}

//-------------------------------------------------------------dkConstrainToGroup---------------------------------------------------------------------
//geos must be constrained to appropriate joints
//groups geos and constrains groups instead of geos
global proc dkConstrainToGroup() {
    string $sels[], $array[], $parentConstraint, $scaleConstraint, $childs[], $constrainers[], $type, $group;
    $sels = `ls -sl`;
    for ($sel in $sels) {
        select -r $sel;
        $childs = `listRelatives -c $sel`;
        for ($child in $childs) {
            if (!catchQuiet($type = `nodeType $child`)) {
                if ($type == "parentConstraint") $parentConstraint = $child;
                if ($type == "scaleConstraint") $scaleConstraint = $child;
            }
        }
        if (`objExists $parentConstraint` || `objExists $scaleConstraint`) {
            $array = `nas_group 0 Group`;
            $group = $array[0];
        }
        if (`objExists $parentConstraint`) {
            $array = `listConnections -d false ($parentConstraint + ".target[0].targetParentMatrix")`;
            $constrainers[0] = $array[0];
            delete $parentConstraint;
        }
        if (`objExists $scaleConstraint`) {
            $array = `listConnections -d false ($scaleConstraint + ".target[0].targetParentMatrix")`;
            $constrainers[1] = $array[0];
            delete $scaleConstraint;
        }
        makeIdentity -apply true -t 1 -r 0 -s 1 -n 0 $group;
        if ($parentConstraint != "") {
            parentConstraint -mo $constrainers[0] $group;
            $parentConstraint = "";
        }
        if ($scaleConstraint != "") {
            scaleConstraint -mo $constrainers[1] $group;
            $scaleConstraint = "";
        }
    }
    print "Transferred constraints to groups!";
}

//-------------------------------------------------------------dkReConstrain---------------------------------------------------------------------
global proc dkReConstrain() {
    string $sels[], $array[], $parentConstraint, $scaleConstraint, $childs[], $constrainer;
    $sels = `ls -sl`;
    for ($sel in $sels) {
        $childs = `listRelatives -c $sel`;
        for ($i = 0; $i < size($childs); $i++) {
            if (`objectType -isType parentConstraint $childs[$i]`) $parentConstraint = $childs[$i];
            if (`objectType -isType scaleConstraint $childs[$i]`) $scaleConstraint = $childs[$i];
        }
        if ($scaleConstraint != "") {
            $array = `listConnections -d false ($scaleConstraint + ".target[0].targetParentMatrix")`;
            delete $scaleConstraint;
            $constrainer = $array[0];
            if (!`objectType -isType joint $sel`) makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $sel;
            scaleConstraint -mo $constrainer $sel;
        }
        if ($parentConstraint != "") {
            $array = `listConnections -d false ($parentConstraint + ".target[0].targetParentMatrix")`;
            delete $parentConstraint;
            $constrainer = $array[0];
            if (!`objectType -isType joint $sel`) makeIdentity -apply true -t 1 -r 0 -s 0 -n 0 $sel;
            parentConstraint -mo $constrainer $sel;
        }
        $parentConstraint = "";
        $scaleConstraint = "";
    }
}

//-------------------------------------------------------------dkSelectSameVerts---------------------------------------------------------------------
//selects same verts on target geo
global proc string[] dkSelectSameVerts(string $targetObj) {
    string $sourceVerts[], $targetVerts[], $sourceObj, $array[];
    $sourceVerts = `ls -sl -flatten`;
    for ($i = 0; $i < size($sourceVerts); $i++) {
        $array = stringToStringArray($sourceVerts[$i], ".");
        $targetVerts[$i] = ($targetObj + "." + $array[1]);
    }
    select -r $targetVerts;
    return $targetVerts;
}

//-------------------------------------------------------------dkSmoothProxy---------------------------------------------------------------------
//select all the geos to smooth proxy and run
global proc string[] dkSmoothProxy() {
    string $geos[], $array[], $parent, $geo, $proxy, $name, $smoothProxies[], $groups[], $prefix, $proxies[], $attrs[], $hists[], $version;
    int $hasSmoothProxy;

    $version = `about -v`;
    $array = stringToStringArray($version, " ");
        $version = $array[0];

    $attrs = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz", "v"};
    $prefix = (`dkProjectName` + "_" + `nas_charNameFromDir`);
    $geos = `ls -sl -long`;
    $array = `polyCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 1`;
    select $array[0];
    SmoothProxy;
    pickWalk -d up;
    $array = `pickWalk -d up`;
    delete $array[0];
    for ($i = 0; $i < size($geos); $i++) {
        $hists = `listHistory -pdo 1 -interestLevel 1 -future 1 $geos[$i]`;
        $hasSmoothProxy = 0;
        for ($hist in $hists) {
            if (`nodeType $hist` == "polySmoothProxy") {
                $hasSmoothProxy = 1;
                break;
            }
        }
        if ($hasSmoothProxy == 1) {
            $array = `ls -sn $geos[$i]`;
            print ("\n" + $array[0] + " already has a smooth proxy, so it was skipped.");
        } else {        
            select -r $geos[$i];
                        optionVar -floatValue polySmoothBaseMeshDisplay 2;
                        performSmoothProxy 0;
            pickWalk -d up;
            $array = `pickWalk -d up`;
            $groups[$i] = $array[0];
        
            $array = `listRelatives -p $groups[$i]`;
            $parent = $array[0];
            
            select -r $groups[$i];
            $array = `pickWalk -d down`;
            $geos[$i] = $array[0];
            $array = `pickWalk -d right`;
            $proxies[$i] = $array[0];
            
            $array = `listHistory -pdo 1 -interestLevel 1 $proxies[$i]`;
            $smoothProxies[$i] = $array[0];
            setAttr ($smoothProxies[$i] + ".exponentialLevel") 0;
            
            if (`objExists $parent`) parent $geos[$i] $parent;
            else parent -w $geos[$i];
            
            $array = stringToStringArray($proxies[$i], "_");
            stringArrayRemoveAtIndex(size($array)-1, $array);
            $name = stringArrayToString($array, "_");
            $proxies[$i] = `rename $proxies[$i] ($name + "_SmoothProxy_Geo")`;
            
            select -r $proxies[$i];
            nas_showAttrs 1 1 1 1 1 1 1 1 1 1;
            
            for ($attr in $attrs) if (`connectionInfo -sfd ($geos[$i] + "." + $attr)` != "") connectAttr -f `connectionInfo -sfd ($geos[$i] + "." + $attr)` ($proxies[$i] + "." + $attr);
            if (`nas_getSkinCluster $geos[$i]` == "") {
                parentConstraint -mo $geos[$i] $proxies[$i];
                scaleConstraint -mo $geos[$i] $proxies[$i];
            }
            if (!`objExists "SmoothProxy_Geo_Group"`) group -em -n "SmoothProxy_Geo_Group";
            parent $proxies[$i] "SmoothProxy_Geo_Group";
            
            delete $groups[$i];
        }
    }
    return $proxies;
}

//-------------------------------------------------------------dkWiresToJoints---------------------------------------------------------------------
//select curves and run
global proc dkWiresToJoints(int $rig) {
    string $curves[], $array[], $clusters[], $joints[], $wire, $verts[];
    $curves = `ls -sl`;
    if (!`objExists "old_deformers_delete_when_done"`) $group = `group -n "old_deformers_delete_when_done" -em`;
    else $group = "old_deformers_delete_when_done";
    for ($curve in $curves) {
        select -r `ls ($curve + ".cv[*]")`;
        $clusters = `nas_clusters`;
        $array = `listHistory -pdo 1 -f 1 -il 2 $curve`;
        $verts = `nas_getDeformerVerts $array[0]`;
        select -r $clusters;
        $array = `dkExtrapToJoints 1 $verts`;
        for ($item in $array) if (`nodeType $item` == "joint") $joints[size($joints)] = $item;
        $joints = `sort $joints`;
        select -r $joints[0];
        if ($rig) dkSimpleFK 2 5;
        parent $curve $clusters $group;
        hide $group;
    }
}

//-------------------------------------------------------------dkRigDeformers---------------------------------------------------------------------
//select geos and run
global proc dkRigDeformers(string $deformers[], string $axis) {
    string $array[], $loc, $sels[], $ctrl, $name, $cog, $groups[];
    float $bb[], $wp[];
    vector $axisVec;
    
    $axisVec = `nas_axisToVector $axis`;
    $sels = `ls -sl`;
    $name = `dkCharNameFromFile`;
    if (!size($name)) {
        $array = stringToStringArray($sels[0], "_");
        if (size($array) == 1) {
            $name = $sels[0];
        } else {
            stringArrayRemoveAtIndex($array[size($array)-1], $array);
            $name = stringArrayToString($array, "_");
        }
    }
    
    $bb = `nas_boundingBox $sels`;
    $array = `ls "*_COG"`;
    $cog = $array[0];
    if ($cog == "") {
        $array = `nas_locator 0`;
        $loc = $array[0];
        select -r $loc; 
        $array = `dkControls curveCircle ($bb[3] + 1)`;
        $cog = `rename $array[0] ($name + "_COG")`;
        select -r $cog; nas_colorControls "yellow" 0;
        makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $cog;
        delete -ch $cog;
        delete $loc;
        if (`objExists ($name + "_Transform")`) parent $cog ($name + "_Transform");
    }
    for ($deformer in $deformers) {
        switch ($deformer) {
            case "squash":
                select -r $cog;
                nas_addAttr "float" 0 0 "" {"Squash", "SquashDeformPivot"};
                nas_addAttr "float" -10 0 "" {"SquashLowBound"};
                nas_addAttr "float" 0 10 "" {"SquashHighBound"};
                
                $array = `nonLinear -type squash -lowBound 0 -highBound 2 $sels`;
                $array[0] = `rename $array[0] ($name + "_Squash")`;
                $array[1] = `rename $array[1] ($name + "_Deformer_SquashHandle")`;
                connectAttr ($cog + ".Squash") ($array[0] + ".factor");
                if (($axisVec.x)==1) {
                    setAttr ($array[1] + ".tx") $bb[0];
                    makeIdentity -apply true -t 1 -r 0 -s 0 -n 0 $array[1];
                    addAttr -e -minValue 0 -maxValue ($bb[3]-$bb[0]) ($cog + ".SquashDeformPivot");
                } else if (($axisVec.y)==1) {
                    setAttr ($array[1] + ".ty") $bb[1];
                    makeIdentity -apply true -t 1 -r 0 -s 0 -n 0 $array[1];
                    addAttr -e -minValue 0 -maxValue ($bb[4]-$bb[1]) ($cog + ".SquashDeformPivot");
                } else if (($axisVec.z)==1) {
                    setAttr ($array[1] + ".tz") $bb[2];
                    makeIdentity -apply true -t 1 -r 0 -s 0 -n 0 $array[1];
                    addAttr -e -minValue 0 -maxValue ($bb[5]-$bb[2]) ($cog + ".SquashDeformPivot");
                }
                if ($axis == "x") setAttr ($array[1] + ".rz") -90;
                else if ($axis == "z") setAttr ($array[1] + ".rx") 90;
                select -r $array[1]; $groups = `nas_group 0 "Group"`;
                makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $groups[0];
                connectAttr ($cog + ".SquashDeformPivot") ($array[1] + ".ty");
                addAttr -e -minValue -10 -maxValue 0 ($cog + ".SquashLowBound");
                connectAttr ($cog + ".SquashLowBound") ($array[0] + ".lowBound");
                setAttr ($cog + ".SquashLowBound") 0;
                addAttr -e -minValue 0 -maxValue 10 ($cog + ".SquashHighBound");
                connectAttr ($cog + ".SquashHighBound") ($array[0] + ".highBound");
                setAttr ($cog + ".SquashHighBound") 2;
                break;
            case "bend":
                select -r $cog;
                nas_addAttr "float" 0 0 "" {"Bend", "BendOrient", "BendDeformPivot"};
                nas_addAttr "float" -10 0 "" {"BendLowBound"};
                nas_addAttr "float" 0 10 "" {"BendHighBound"};
                $array = `nonLinear -type bend -lowBound 0 -highBound 2 -curvature 0 $sels`;
                $array[0] = `rename $array[0] ($name + "_Bend")`;
                $array[1] = `rename $array[1] ($name + "_Deformer_BendHandle")`;
                connectAttr ($cog + ".Bend") ($array[0] + ".curvature");
                if (($axisVec.x)==1) {
                    setAttr ($array[1] + ".tx") $bb[0];
                    makeIdentity -apply true -t 1 -r 0 -s 0 -n 0 $array[1];
                    addAttr -e -minValue 0 -maxValue ($bb[3]-$bb[0]) ($cog + ".BendDeformPivot");
                } else if (($axisVec.y)==1) {
                    setAttr ($array[1] + ".ty") $bb[1];
                    makeIdentity -apply true -t 1 -r 0 -s 0 -n 0 $array[1];
                    addAttr -e -minValue 0 -maxValue ($bb[4]-$bb[1]) ($cog + ".BendDeformPivot");
                } else if (($axisVec.z)==1) {
                    setAttr ($array[1] + ".tz") $bb[2];
                    makeIdentity -apply true -t 1 -r 0 -s 0 -n 0 $array[1];
                    addAttr -e -minValue 0 -maxValue ($bb[5]-$bb[2]) ($cog + ".BendDeformPivot");
                }
                if ($axis == "x") setAttr ($array[1] + ".rz") -90;
                else if ($axis == "z") setAttr ($array[1] + ".rx") 90;
                select -r $array[1]; $groups = `nas_group 0 "Group"`;
                makeIdentity -apply true -t 0 -r 0 -s 1 -n 0 $groups[0];
                connectAttr ($cog + ".BendDeformPivot") ($array[1] + ".ty");
                connectAttr ($cog + ".BendOrient") ($array[1] + ".ry");
                addAttr -e -minValue -10 -maxValue 0 ($cog + ".BendLowBound");
                connectAttr ($cog + ".BendLowBound") ($array[0] + ".lowBound");
                setAttr ($cog + ".BendLowBound") 0;
                addAttr -e -minValue 0 -maxValue 10 ($cog + ".BendHighBound");
                connectAttr ($cog + ".BendHighBound") ($array[0] + ".highBound");
                setAttr ($cog + ".BendHighBound") 2;
                break;
        }
        parentConstraint -mo $cog $groups[0];
        scaleConstraint -mo $cog $groups[0];
        if (`objExists "Deformers"`) parent $groups[0] "Deformers";
    }
    if (`objExists "Deformers"`) hide "Deformers";
    select -r $cog;
}

global proc dkRigDeformersUI() {
    global string $dkRigDeformersRadio, $dkRigDeformersCheckbox;
    string $window, $form, $button;
    
    $window = `nas_window dkRigDeformers 1 0 0`;
        $form = `formLayout`;
            $dkRigDeformersCheckbox = `checkBoxGrp -numberOfCheckBoxes 2 -label "Types:" -labelArray2 "Squash" "Bend" -va2 1 1 -cw 1 41 -cw 2 60`;    
            $dkRigDeformersRadio = `radioButtonGrp -numberOfRadioButtons 3 -label "Axis:" -labelArray3 "X" "Y" "Z" -select 2 -cw 1 41 -cw 2 60 -cw 3 60 -cw 4 60`;                
            $button = `button -label "Rig Deformers" -align "center" -c "dkRigDeformersExecute"`;
        formLayout -e
            -af $dkRigDeformersCheckbox "top" 5 
            -af $dkRigDeformersCheckbox "right" 5
            -af $dkRigDeformersCheckbox "left" 5
            
            -ac $dkRigDeformersRadio "top" 5 $dkRigDeformersCheckbox
            -af $dkRigDeformersRadio "right" 5
            -af $dkRigDeformersRadio "left" 5
            
            -ac $button "top" 5 $dkRigDeformersRadio
            -af $button "right" 5
            -af $button "bottom" 5
            -af $button "left" 5
            $form;
        setParent..;
    window -e -wh 235 120 $window;
    showWindow $window;
}

global proc dkRigDeformersExecute() {
    global string $dkRigDeformersRadio, $dkRigDeformersCheckbox;
    string $deformers[], $axis;
    
    if (`checkBoxGrp -q -v1 $dkRigDeformersCheckbox` == 1) $deformers[size($deformers)] = "squash";
    if (`checkBoxGrp -q -v2 $dkRigDeformersCheckbox` == 1) $deformers[size($deformers)] = "bend";
    
    if (`radioButtonGrp -q -select $dkRigDeformersRadio` == 1) $axis = "x";
    if (`radioButtonGrp -q -select $dkRigDeformersRadio` == 2) $axis = "y";
    if (`radioButtonGrp -q -select $dkRigDeformersRadio` == 3) $axis = "z";
    
    dkRigDeformers $deformers $axis;
}

//-------------------------------------------------------------dkDeformerToCluster---------------------------------------------------------------------
//select controls and deformer transform and run to make rotate clusters
global proc string dkDeformerToCluster() {
    float $percent = 1;
    float $pruneAmount = .001;
    string $type;
    
    string $verts[], $cluster, $clusterHandle, $array[], $deformer, $shape, $sels[], $ctrls[], $clusterHandles[], $object, $allVerts[], $geos[];
    float $term_x, $term_y, $term_z, $weights[], $wp[];
    vector $baseWp[], $deformWp[], $vec1, $vec2;
    
    waitCursor -state 1;
    //separate deformers from clusters, there should only be one deformer
    $sels = `ls -sl`;
    if (`gmatch $sels[0] "*.pt*"` || `gmatch $sels[0] "*.vtx*"` || `gmatch $sels[0] "*.cv*"`) $type = "points";
    else $type = "ctrls";
    
    if ($type == "points") {
        $array = stringToStringArray($sels[0], ".");
        $array = `listHistory -pdo 1 -f 1 $array[0]`;
        $deformer = $array[0];
        $array = `cluster -relative -envelope 1`;
        $ctrls[0] = $array[1];
    } else if ($type == "ctrls") {
        for ($sel in $sels) {
            $array = `listRelatives -s $sel`; $shape = $array[0];
            if (`objectType -isType lattice $shape`) {
                $array = `connectionInfo -dfs ($shape + ".worldMatrix[0]")`;
                $array = stringToStringArray($array[0], ".");
                $deformer = $array[0];
            } else {
                clear $array;
                if (`objExists ($shape + ".worldSpace[0]")`) $array = `connectionInfo -dfs ($shape + ".worldSpace[0]")`;
                if (size($array)) {
                    $array = stringToStringArray($array[0], ".");
                    if (`objectType -isType wire $array[0]`) $deformer = $array[0]; 
                    else if (`objectType -isType cluster $array[0]`) $deformer = $array[0];
                    else if (`objectType -isType ffd`) $deformer = $array[0];
                    else $ctrls[size($ctrls)] = $sel;
                } else {
                    $ctrls[size($ctrls)] = $sel;
                }
            }
        }
    }
    
    //gets the verts that are affected by deformer
    $array[0] = `dkGetDeformerSet $deformer`;
    $verts = `sets -q $array[0]`;
    select -r $verts;
    $verts = `ls -sl -flatten`;
    
    for ($vert in $verts) {
        $array = stringToStringArray($vert, ".");
        $geos[size($geos)] = $array[0];
    }
    $geos = stringArrayRemoveDuplicates($geos);
    for ($geo in $geos) $allVerts = stringArrayCatenate($allVerts, `ls -flatten ($geo + ".vtx[*]")`);

    nas_progress ((size($verts))*(size($ctrls))) "start";
    
    for ($ctrl in $ctrls) {
        //get world space coordinates of verts in two different poses
        setAttr ($ctrl + ".tx") 0;
        for($i=0;$i<size($verts);$i++) $baseWp[$i] = `xform -query -translation -worldSpace $verts[$i]`;
        setAttr ($ctrl + ".tx") 1;
        for($i=0;$i<size($verts);$i++) $deformWp[$i] = `xform -query -translation -worldSpace $verts[$i]`;
        setAttr ($ctrl + ".tx") 0;
        
        //creates cluster
        $array = `cluster -relative -envelope 1 $allVerts`;
        $cluster = $array[0];
        $clusterHandle = $array[1];
        
        //move cluster pivots and origin to ctrl and connect rotates and scales
        $wp = `xform -q -ws -rp $ctrl`;
        move $wp[0] $wp[1] $wp[2] ($clusterHandle + ".scalePivot") ($clusterHandle + ".rotatePivot");
        $array = `listRelatives -s $clusterHandle`;
        $shape = $array[0];
        setAttr ($shape + ".origin") $wp[0] $wp[1] $wp[2];
        
        //find distance travelled by each vert between two poses
        //find weights to apply to each vert for the rotate cluster
        percent -v 0 $cluster $allVerts;
        for($i = 0; $i < size($verts); $i++) {
            // do distance formula on base position to deform position (inflat/scale by 100 for calculations)
            $vec1 = $baseWp[$i];
            $vec2 = $deformWp[$i];
            $term_x = `pow(($vec2.x)-($vec1.x)) 2`; 
            $term_y = `pow(($vec2.y)-($vec1.y)) 2`; 
            $term_z = `pow(($vec2.z)-($vec1.z)) 2`;
            $weights[$i] = sqrt($term_x + $term_y + $term_z);
            if ($weights[$i] > 0) percent -v ($weights[$i]*$percent) $cluster $verts[$i];
            if (`nas_progress 0 ("AWESOMENESS for " + $ctrl + ". ")`) return "";
        }
        //nas_pruneDeformerWeights {$cluster} $pruneAmount;
        if ($type == "points") delete $ctrl;
        $clusterHandles[size($clusterHandles)] = $clusterHandle;
    }
    
    select -r $clusterHandles;
    nas_progress 0 "end";
    waitCursor -state 0;
    return $cluster;
}

//-------------------------------------------------------------dkJointsToClusters---------------------------------------------------------------------
global proc string[] dkJointsToClusters() {
    string $joints[], $array[], $clusters[], $verts[], $skinCluster, $cluster, $clusterHandle, $clusterHandles[], $allVerts[];
    float $rp[], $weights[], $startTime, $weightQuery;
    
    ConvertSelectionToVertices;
    $allVerts = `ls -sl -flatten`;
    $skinCluster = `nas_getSkinCluster $allVerts[0]`;
    $joints = `skinPercent -ignoreBelow .0000000001 -q -t $skinCluster $allVerts`;
    
    nas_progress (size($joints)) "start";
    for ($i = 0; $i < size($joints); $i++) {
        if (`nas_progress 0 ("creating cluster for " + $joints[$i] + ". ")`) return {};
        //find the verts that have weighting
        clear $verts;
        clear $weights;
        for ($j = 0;$j < size($allVerts);$j++) {
            $weightQuery = `skinPercent -t $joints[$i] -q -v $skinCluster $allVerts[$j]`;
            if ($weightQuery > 0) {
                $verts[size($verts)] = $allVerts[$j];
                $weights[size($weights)] = $weightQuery;
            }
        }
        
        //create the cluster
        $array = `cluster -relative -envelope 1 $verts`;
        $clusters[$i] = $array[0];
        $clusterHandle = $array[1];
        $clusterHandles[size($clusterHandles)] = $clusterHandle;
        $rp = `xform -ws -q -rp $joints[$i]`;
        xform -rp $rp[0] $rp[1] $rp[2] $clusterHandle;
        $array = `listRelatives -s $clusterHandle`;
        setAttr ($array[0] + ".origin") $rp[0] $rp[1] $rp[2];
        
        //weight the cluster
        for ($j = 0;$j < size($weights);$j++) if ($weights[$j] != 0) percent -v $weights[$j] $clusters[$i] $verts[$j];
    }
    nas_progress 0 "end";
    select -r $clusterHandles;
    return $clusterHandles;
}

//-------------------------------------------------------------dkGetSceneGeos---------------------------------------------------------------------
global proc string[] dkGetSceneGeos() {
    string $array[], $parents[], $geos[];

    $array = `ls -long -type mesh`;
    $parents = `listRelatives -type transform -p $array`;
    $parents = stringArrayRemoveDuplicates($parents);
    for ($i = 1; $i < size($parents); $i++) {
        if (size(ls($parents[$i])) > 1) {
            $array = `ls -long $parents[$i]`;
            $geos = stringArrayCatenate($geos, $array);
        } else {
            $geos[size($geos)] = $parents[$i];
        }
    }
    return $geos;
}

//-------------------------------------------------------------dkCheckAttr---------------------------------------------------------------------
//sets attrs for provided attrs
global proc int dkCheckAttr(string $object, string $attrs[], float $values[]) {
    string $array[];
    if (size($attrs) != size($values)) error "attrs and values are not the same size";
    if (!`objExists $object`) {
        warning ($object + " does not exist in this scene!\n");
        return 1;
    } else {
        if (size(`ls $object`) > 1) $array = `ls -long $object`;
        else $array[0] = $object;
        for ($item in $array) {
            for ($i = 0; $i < size($attrs); ++$i) {
                if (!`objExists ($item + "." + $attrs[$i])`) {
                    //warning (($item + "." + $attrs[$i]) + " does not exist in this scene!\n");
                    return 1;
                } else {
                    //print ($item + "." + $attrs[$i] + "\n");
                    //if (`getAttr ($item + "." + $attrs[$i])` != $values[$i]) {
                        if (catchQuiet(`setAttr ($item + "." + $attrs[$i]) $values[$i]`)) {
                            return 1;
                        } else {
                            setAttr ($item + "." + $attrs[$i]) $values[$i];
                            print ("*Set " + $attrs[$i] + " of " + $item + " to " + $values[$i] + "\n");
                        }
                    //}
                }
            }
        }
        return 0;
    }
}

//-------------------------------------------------------------dkCheckFlagAttr---------------------------------------------------------------------
//checks attr flags for provided attrs
global proc int dkCheckFlagAttr(string $object, string $attrs[], string $flags[], float $values[]) {
    string $cmd, $objects[];
    int $run;
    $objects = `ls $object`;
    if (size($objects) > 1) warning ("more than one object matches name " + $object); 
    if (size($flags) != size($values)) error "attrs and values are not the same size";
    if (!`objExists $object`) {
        warning ($object + " does not exist in this scene!\n");
        return 1;
    } else {
        for ($object in $objects) {
            for ($attr in $attrs) {
                if (`objExists ($object + "." + $attr)`) {
                    for ($i = 0; $i < size($flags); $i++) {
                        $cmd = ("getAttr -" + $flags[$i] + " " + $object + "." + $attr + ";");
                        if (`eval $cmd` != $values[$i]) {
                            $cmd = ("setAttr -" + $flags[$i] + " " + $values[$i] + " " + $object + "." + $attr + ";"); 
                            eval $cmd;
                            print ("*Set " + $flags[$i] + " to " + $values[$i] + " for " + $object + "." + $attr + "\n");
                            $run = 1;
                        }
                    }
                }
            }
        }
    }
    return $run;
}

//-------------------------------------------------------------dkNoteFlag---------------------------------------------------------------------
global proc string dkNoteFlag(string $object, string $flag, float $value) {
    string $cmd;
    if ($flag == "keyable" && $value == 1) $message = ("- make non-keyable: " + $object + "\n");
    else if ($flag == "keyable" && $value == 0) $message = ("- make keyable: " + $object + "\n");
    else if ($flag == "lock" && $value == 1) $message = ("- unlock: " + $object + "\n");
    else if ($flag == "lock" && $value == 0) $message = ("- lock: " + $object + "\n");
    else if ($flag == "channelBox" && $value == 1) $message = ("- hide: " + $object + "\n");
    else if ($flag == "channelBox" && $value == 0) $message = ("- unhide: " + $object + "\n");
    
    $cmd = ("getAttr -" + $flag + " " + $object);
    if (eval($cmd) == $value) return $message;
    else return "";
}
//-------------------------------------------------------------dkNotesProp---------------------------------------------------------------------
global proc dkNotesProp() {
    string $ctrls[], $array[], $transforms[], $geos[], $parents[], $notes[], $cogs[], $longNames[], $parents[];
    int $flagged, $isHires;
    $array = `ls -type nurbsCurve`;
    $ctrls = `listRelatives -type transform -p $array`;
    $transforms = `ls "*Transform"`;
    $cogs = `ls "*COG"`;
    for ($ctrl in $ctrls) {
        dkNoteFlag ($ctrl + ".visibility") lock 1;
        $flagged = 0;
        for ($transform in $transforms) if ($ctrl == $transform) $flagged = 1;
        for ($cog in $cogs) if ($ctrl == $cog) $flagged = 2;
        if ($flagged == 1) {
            $notes[0] = ($notes[0] + `dkNoteFlag ($ctrl + ".visibility") "keyable" 1`);
        } else if ($flagged == 2) {
            $notes[1] = ($notes[1] + `dkNoteFlag ($ctrl + ".visibility") "keyable" 0`);
        } else {
            $notes[2] = ($notes[2] + `dkNoteFlag ($ctrl + ".visibility") "keyable" 1`);
            $notes[3] = ($notes[3] + `dkNoteFlag ($ctrl + ".visibility") "channelBox" 1`);
        }
    }
    for ($i = 0; $i < size($notes); $i++) if (size($notes[$i])) print ($notes[$i] + "\n");
    for ($ctrl in $ctrls) {
        $array = `listHistory -pdo 1 $ctrl`;
        for ($item in $array) if (`gmatch $item "makeNurb*"`) print ("- delete history (" + $item + ") on " + $ctrl + "\n");
    }
    
    $geos = `dkGetSceneGeos`;
    for ($geo in $geos) print `dkNoteFlag ($geo + ".visibility") "lock" 1`;
    
    /*
    for ($geo in $geos) {
        $isHires = 0;
        $array = `listRelatives -fullPath $geo`;
        $parents = stringToStringArray($array[0], "|");
        for ($parent in $parents) if ($parent == "HiRes") {
            $isHires = 1;
            break;
        }
        if ($isHires) {
            $array = `listHistory -pdo 1 $geo`;
            if (!`gmatch $array[0] "polySmoothFace*"`) print ("- please smooth " + $geo + " and connect to transform\n");
        }
    }
    for ($transform in $transforms) {
        if (`objExists ($transform + ".Smooth")`) {
            $array = `connectionInfo -dfs ($transform + ".Smooth")`;
            if (size($array) == 0) print ("- connect " + $transform + ".Smooth to smooth nodes\n");
        }
    }
    */
}

//-------------------------------------------------------------dkCheckProp---------------------------------------------------------------------
global proc dkCheckProp() {
    global int $dkWorldNotesSaved;
    string $array[], $propName, $panels[], $transforms[], $array[], $geos[], $parents[];
    float $timelineData[];
    int $run, $changed, $snag;
    
    $transforms = `ls "*Transform"`;
    $array = stringToStringArray($transforms[0], "_");
    stringArrayRemoveAtIndex((size($array)-1), $array);
    $propName = stringArrayToString($array, "_");
    print ("\n\n--------------------------------------------------------------Checking " + $propName + "--------------------------------------------------------------\n");
    
    $geos = `dkGetSceneGeos`;
    for ($geo in $geos) if (`dkCheckFlagAttr $geo {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"} {"lock"} {1}`) $run = 1;
    if ($run) {
        print "*Locked transforms of geometry in scene.\n";
        $changed = 1;
        $run = 0;
    }
    for ($geo in $geos) if (`dkCheckFlagAttr $geo {"v"} {"lock"} {0}`) $run = 1;
    if ($run) {
        print "*Unlocked vis of geometry in scene.\n";
        $changed = 1;
        $run = 0;
    }
    for ($transform in $transforms) {
        if (`dkCheckFlagAttr $transform {"visibility", "Smooth", "GeoRes"} {"keyable", "channelBox", "lock"} {0, 1, 0}`) $run = 1;
        if (`dkCheckAttr $transform {"Smooth", "GeoRes"} {0, 0}`) $snag = 1;
    }
    if ($run) {
        print "*made visibility, smooth, and geores attrs on Transform non-keyable.\n";
        $changed = 1;
        $run = 0;
    }
    $array = `ls "*COG"`;
    for ($item in $array) {
        if (`dkCheckFlagAttr $item {"visibility"} {"keyable", "lock"} {0, 1}`) print "*made visibility on COG keyable and unlocked.\n";;
    }
    
    $timelineData[0] = `playbackOptions -q -min`;
    $timelineData[1] = `playbackOptions -q -max`;
    $timelineData[2] = `playbackOptions -q -ast`;
    $timelineData[3] = `playbackOptions -q -aet`;
    if ($timelineData[0] != 0 || $timelineData[1] != 200 || $timelineData[2] != 0 || $timelineData[3] != 200) {
        playbackOptions -min 0 -max 200 -ast 0 -aet 200;
        print "*Set time range to 0-200\n";
        $changed = 1;
    }

    $panels  = `nas_getVisibleModelPanels`;
    for ($panel in $panels) {
        if (`modelEditor -q -wireframeOnShaded $panel` != 0) {
            modelEditor -e -wireframeOnShaded 0 $panel;
            $run = 1;
        }
        if (`modelEditor -q -displayAppearance $panel` != "boundingBox") {
            modelEditor -e -displayAppearance boundingBox $panel;
            $run = 1;
        }
    }
    if ($run) {
        print "*Set shading mode to bounding box and turned off wireframe on shaded\n";
        $run = 0;
        $changed = 1;
    }
    
    dkCheckAttr Skeleton {"visibility"} {0};
    dkCheckAttr Deformers {"visibility"} {0};
    dkCheckAttr top {"visibility"} {0};
    dkCheckAttr side {"visibility"} {0};
    dkCheckAttr front {"visibility"} {0};
    dkCheckAttr persp {"visibility"} {0};
    //dkCheckAttr perspShape {"nearClipPlane"} {.01};
    
    if ($snag) {
        error "Some checks failed. Please check for warnings in script editor.";
        ScriptEditor;
        $dkWorldNotesSaved = 0;
    } else if ($changed) {
        warning "Some changes were made. Please check script editor for details.";
        ScriptEditor;
        $dkWorldNotesSaved = 0;
    } else {
        dkKillWindows;
        if ($dkWorldNotesSaved) {
            dkSaveOptions;
        } else {
            $dkWorldNotesSaved = 1;
        }            
        print "All Clear!";
    }
}

//-------------------------------------------------------------dkCheck---------------------------------------------------------------------
global proc dkCheck() {
    global int $dkWorldNotesSaved;
    string $groups[], $array[], $geos[], $lockObjs[], $panels[], $masterCtrls[], $charName, $attrs[], $refs[], $lightRef, $newName, $name;
    float $timelineData[];
    int $snag, $run, $nums[], $foundScenes, $changed, $warn;
    
    //find the name of the asset
    $charName = `nas_charNameFromDir`;
    print ("\n\n--------------------------------------------------------------Checking " + $charName + "--------------------------------------------------------------\n");
    
    $geos = `dkGetSceneGeos`;
    $groups = {"Controllers", "Geometry", "Skeleton", "Deformers"};
    $lockObjs = stringArrayCatenate($geos, $groups);
    for ($lockObj in $lockObjs) if (`dkCheckFlagAttr $lockObj {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"} {"lock"} {1}`) print "*Locked transforms of geometry in scene.\n";
    
    if (`objExists "Transform"`) {
        if (`dkCheckFlagAttr "Transform" {"visibility"} {"keyable", "channelBox"} {0, 0}`) $run = 1;
        if (`dkCheckFlagAttr "Transform" {"GeoRes"} {"keyable", "channelBox"} {0, 1}`) $run = 1;
        if (`dkCheckFlagAttr "Transform" {"Smooth", "GeoVis", "Model"} {"keyable"} {0}`) $run = 1;
    } else {
        warning "Either \"Transform\" does not exist in scene or it needs to be renamed.";
        $snag = 1;
    }

    if (`objExists "COG"`) {
        if (`dkCheckFlagAttr "COG" {"visibility"} {"lock", "keyable"} {1, 0}`) $run = 1;
    } else if (`objExists "Upper_Body.Display"`) {
        if (`dkCheckFlagAttr "Upper_Body" {"Display"} {"keyable", "channelBox", "lock"} {0, 0, 1}`) $run = 1;
    } else {
        warning "Neither a COG or an Upper_Body control exists.";
        $snag = 1;
    }
    
    if ($run) {
        print "*Locked, hid, and made user-defined COG and Transform channels non-keyable.\n";
        $run = 0;
        $changed = 1;
    }
    
    if (`dkRenameShadingNodes`) {
        print "*Renamed material infos and shading groups.\n";
        //$changed = 1;
    }
    
    $timelineData[0] = `playbackOptions -q -min`;
    $timelineData[1] = `playbackOptions -q -max`;
    $timelineData[2] = `playbackOptions -q -ast`;
    $timelineData[3] = `playbackOptions -q -aet`;
    if ($timelineData[0] != 0 || $timelineData[1] != 200 || $timelineData[2] != 0 || $timelineData[3] != 200) {
        playbackOptions -min 0 -max 200 -ast 0 -aet 200;
        print "*Set time range to 0-200\n";
        $changed = 1;
    }

    $panels  = `nas_getVisibleModelPanels`;
    for ($panel in $panels) {
        if (`modelEditor -q -wireframeOnShaded $panel` != 0) {
            modelEditor -e -wireframeOnShaded 0 $panel;
            $run = 1;
        }
        if (`modelEditor -q -displayAppearance $panel` != "boundingBox") {
            modelEditor -e -displayAppearance boundingBox $panel;
            $run = 1;
        }
    }
    if ($run) {
        print "*Set shading mode to bounding box and turned off wireframe on shaded\n";
        $run = 0;
        $changed = 1;
    }
    
    $masterCtrls = {"Neck_Master_Ctrl", "Spine_Top_Master_Ctrl", "Spine_Bottom_Master_Ctrl", "LT_Arm_Master_Ctrl", "RT_Arm_Master_Ctrl", "LT_Leg_Master_Ctrl", "RT_Leg_Master_Ctrl"};
    for ($ctrl in $masterCtrls) { 
        if (`objExists $ctrl`) {
            if (`dkCheckFlagAttr $ctrl {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"} {"lock"} {1}`) {
                print ("*Locked translates, rotates, scales, and visibility of " + $ctrl + "\n");
                $changed = 1;
            }
        }
    }
    //if (`objExists "Upper_Body.Display"`) if (`dkCheckAttr Upper_Body {"Display"} {2}`) $snag = 1;
    if (`objExists "ControllerGroupVisibility.Model"`) if (`dkCheckAttr ControllerGroupVisibility {"Model"} {0}`) $snag = 1;
    if (`dkCheckAttr Skeleton {"visibility"} {0}`) $snag = 1;
    if (`dkCheckAttr Deformers {"visibility"} {0}`) $snag = 1;
    if (`dkCheckAttr Light_Rig {"visibility", "displayType"} {1, 2}`) $snag = 1;
    if (`dkCheckAttr ($charName + "_Mesh") {"visibility", "displayType"} {1, 2}`) $snag = 1;
    if (`dkCheckAttr Controller_Vis {"visibility", "displayType"} {1, 0}`) $snag = 1;
    
    if (`dkCheckAttr Transform {"LT_Arm_IKFK", "RT_Arm_IKFK", "LT_Leg_IKFK", "RT_Leg_IKFK"} {10, 10, 0, 0}`) $warn = 1;
    if (`dkCheckAttr LT_Arm_IK_Ctrl {"Stretchy", "LockLength"} {0, 1}`) $warn = 1;
    if (`dkCheckAttr RT_Arm_IK_Ctrl {"Stretchy", "LockLength"} {0, 1}`) $warn = 1;
    if (`dkCheckAttr LT_Leg_IK_Ctrl {"Stretchy", "LockLength"} {1, 1}`) $warn = 1;
    if (`dkCheckAttr RT_Leg_IK_Ctrl {"Stretchy", "LockLength"} {1, 1}`) $warn = 1;
    
    $array = `ls "*Master_Ctrl"`;
    for ($item in $array) {
        if (`dkCheckFlagAttr $ctrl {"v"} {"lock"} {0}`) $warn = 1;
        if (`dkCheckAttr $item {"visibility"} {0}`) $warn = 1;
    }
    
    dkCheckAttr EyesTongueTeeth_Mesh {"visibility", "displayType"} {1, 2};
    
    $refs = `file -un -q -r`;
    if (size($refs)) {
        for ($ref in $refs) {
            $array = stringToStringArray($ref, "/");
            for ($part in $array) {
                if ($part == "Light_Rigs") {
                    $lightRef = $ref;
                    break;
                }
            }
            if (size($lightRef)) break;
        }
        $array = stringToStringArray($lightRef, "/");
        if ($array[0] != "scenes") {
            $refNode = `file -q -referenceNode $lightRef`;
            $newName = "scenes";
            for ($part in $array) {
                if ($foundScenes == 1) $newName += ("/" + $part);
                if ($part == "scenes") $foundScenes = 1;
            }
            file -loadReference $refNode $newName;
            print ("*Renamed light rig reference\n");
            $changed = 1;
        }
    }
    
    $refs = `file -q -r`;
    if (size($refs)) {
        for ($ref in $refs) {
            $array = stringToStringArray($ref, "/");
            for ($part in $array) {
                if ($part == "Light_Rigs") {
                    $lightRef = $ref;
                    break;
                }
            }
            if (size($lightRef)) break;
        }

        string $array[] = stringToStringArray(`file -q -ns $lightRef`, "_");
        $name = $array[2];
        for ($i = 3; $i < size($array); $i++) $name += ("_" + $array[$i]);
        if ($name != $charName) {
            if (`namespace -ex $charName`) namespace -rm $charName;
            file -e -ns ($array[0] + "_" + $array[1] + "_" + $charName) $lightRef;
            print ("*Renamed light rig namespace to " + ($array[0] + "_" + $array[1] + "_" + $charName) + "\n");
            $changed = 1;
        }
    }

    if ($warn) {
        warning "Some checks failed, but the nodes mentioned might not apply for this character. Please check script editor for details.";
    }
    
    if ($snag) {
        $dkWorldNotesSaved = 0;
        ScriptEditor;
        error "Some checks failed. Please check for warnings in script editor.";
    } else if ($changed) {
        warning "Some changes were made. Please check script editor for details.";
        $dkWorldNotesSaved = 0;
        ScriptEditor;
    } else {
        dkKillWindows;
        if ($dkWorldNotesSaved) {
            dkSaveOptions;
        } else {
            $dkWorldNotesSaved = 1;
        }
        print "All Clear!";
    }        
}

//-------------------------------------------------------------dkProjectName---------------------------------------------------------------------
global proc string dkProjectName() {
    string $charName = `file -q -sn`;
    $array = stringToStringArray($charName, "/");
    if ($array[0] == "P:") $charName = "PN";
     else if ($array[1] == "Fanboy") $charName = "FB";
     else if ($array[1] == "RobotAndMonster") $charName = "RM";
    return $charName;
}

//-------------------------------------------------------------dkConsolidateShaders---------------------------------------------------------------------
//select shaders and all affected objects will be assigned to the first shader selected
global proc dkConsolidateShaders() {
    string $shaders[], $objects[], $shadingGroup, $array[];
    $shaders = `ls -sl`;
    for ($i = 1; $i < size($shaders); $i++) {
        $shadingGroup = "";
        $array = `listConnections -s on ($shaders[$i] + ".outColor")`;
        $shadingGroup = $array[0];
        hyperShade -objects $shaders[$i];
        $array = `ls -sl`;
        $objects = stringArrayCatenate($objects, $array);
        delete $shaders[$i];
        delete $shadingGroup;
    }
    select -r $objects;
    hyperShade -assign $shaders[0];
    select -r $shaders[0];
}

//-------------------------------------------------------------dkFindName---------------------------------------------------------------------
global proc string dkFindName(string $object, int $numParts) {
    string $array[];
    $array = stringToStringArray($object, "_");
    $name = $array[0];
    for ($i = 1; $i < $numParts; $i++) $name += ("_" + $array[$i]);
    return $name;
}

//-------------------------------------------------------------dkStripFromLast---------------------------------------------------------------------
global proc string dkStripFromLast(string $object, int $numParts) {
    string $array[];
    $array = stringToStringArray($object, "_");
    $name = $array[0];
    for ($i = 1; $i < size($array)-$numParts; $i++) $name += ("_" + $array[$i]);
    return $name;
}

//-------------------------------------------------------------dkAverageLocationAll---------------------------------------------------------------------
global proc dkAverageLocationAll(string $axis) {
    string $sels[];
    float $xforms[], $values[], $resultPos[], $offsets[];
    vector $axisVector, $worldVecs[];

    $sels = `ls -sl`;
    $axisVector = `nas_axisToVector $axis`;
    for ($sel in $sels) $worldVecs[size($worldVecs)] = `xform -ws -q -rp $sel`;
    for ($vec in $worldVecs) {
        $resultPos[0] += ($vec.x);
        $resultPos[1] += ($vec.y);
        $resultPos[2] += ($vec.z);
    }
    $resultPos[0] /= size($worldVecs);    
    $resultPos[1] /= size($worldVecs);    
    $resultPos[2] /= size($worldVecs);    
    
    for ($i=0;$i<size($sels);$i++) {
        $xforms = $worldVecs[$i];
        $offset[0] = $resultPos[0] - $xforms[0];
        $offset[1] = $resultPos[1] - $xforms[1];
        $offset[2] = $resultPos[2] - $xforms[2];
        move -r ($offset[0]*($axisVector.x)) ($offset[1]*($axisVector.y)) ($offset[2]*($axisVector.z)) $sels[$i];
    }
}

//-------------------------------------------------------------dkAverageLocationLast---------------------------------------------------------------------
global proc dkAverageLocationLast(string $axis) {
    string $sels[], $lastSel;
    float $xforms[], $values[], $resultPos[], $offsets[];
    vector $axisVector, $worldVecs[];

    $sels = `ls -sl`;
    $lastSel = $sels[size($sels)-1];
    $sels = stringArrayRemove({$lastSel}, $sels);
    $axisVector = `nas_axisToVector $axis`;
    for ($sel in $sels) $worldVecs[size($worldVecs)] = `xform -ws -q -rp $sel`;
    for ($vec in $worldVecs) {
        $resultPos[0] += ($vec.x);
        $resultPos[1] += ($vec.y);
        $resultPos[2] += ($vec.z);
    }
    $resultPos[0] /= size($worldVecs);    
    $resultPos[1] /= size($worldVecs);    
    $resultPos[2] /= size($worldVecs);    
    
    for ($i=0;$i<size($sels);$i++) {
        $xforms = `xform -ws -q -rp $lastSel`;
        $offset[0] = $resultPos[0] - $xforms[0];
        $offset[1] = $resultPos[1] - $xforms[1];
        $offset[2] = $resultPos[2] - $xforms[2];
        move -r ($offset[0]*($axisVector.x)) ($offset[1]*($axisVector.y)) ($offset[2]*($axisVector.z)) $lastSel;
    }
}

//-------------------------------------------------------------dkSlope---------------------------------------------------------------------
global proc dkSlope(string $axis) {
    string $sels[];
    float $xforms1[], $xforms2[], $slope, $targetXforms[], $offset, $values1[], $values2[], $floatArray[];
    int $axis1Index, $axis2Index;
    vector $axisVec1, $axisVec2;
    
    $axisVec1 = `nas_axisToVector $axis`;
    $sels = `ls -sl`;
    $xforms1 = `xform -q -translation -ws $sels[0]`;
    $xforms2 = `xform -q -translation -ws $sels[1]`;
    $targetXforms = `xform -q -translation -ws $sels[2]`;
    $floatArray = $axisVec1;
    for ($i = 0; $i < size($floatArray);$i++) if ($floatArray[$i] > 0) $axis1Index = $i;
    
    if ($axis == "x") $axisVec2 = << 0, 1, 0 >>;
    else if ($axis == "y") $axisVec2 = << 0, 0, 1 >>;
    else if ($axis == "z") $axisVec2 = << 1, 0, 0 >>;
    //move first "other" axis onto slope
    $values1[0] = ($xforms1[0]*($axisVec1.x)) + ($xforms1[1]*($axisVec1.y)) + ($xforms1[2]*($axisVec1.z));
    $values1[1] = ($xforms2[0]*($axisVec1.x)) + ($xforms2[1]*($axisVec1.y)) + ($xforms2[2]*($axisVec1.z));
    $values2[0] = ($xforms1[0]*($axisVec2.x)) + ($xforms1[1]*($axisVec2.y)) + ($xforms1[2]*($axisVec2.z));
    $values2[1] = ($xforms2[0]*($axisVec2.x)) + ($xforms2[1]*($axisVec2.y)) + ($xforms2[2]*($axisVec2.z));
    
    if (($values1[1] - $values1[0]) != 0) $slope = ($values2[1] - $values2[0])/($values1[1] - $values1[0]);
    else $slope = 0;
    $offset = $values2[0] - ($slope*$values1[0]);
    
    $floatArray = $axisVec2;
    for ($i = 0; $i < size($floatArray);$i++) if ($floatArray[$i] > 0) $axis2Index = $i;
    $targetXforms[$axis2Index] = $slope*$targetXforms[$axis1Index] + $offset;
    
    //do the same to the other axis
    if ($axis == "x") $axisVec2 = << 0, 0, 1 >>;
    else if ($axis == "y") $axisVec2 = << 1, 0, 0 >>;
    else if ($axis == "z") $axisVec2 = << 0, 1, 0 >>;
    $values1[0] = ($xforms1[0]*($axisVec1.x)) + ($xforms1[1]*($axisVec1.y)) + ($xforms1[2]*($axisVec1.z));
    $values1[1] = ($xforms2[0]*($axisVec1.x)) + ($xforms2[1]*($axisVec1.y)) + ($xforms2[2]*($axisVec1.z));
    $values2[0] = ($xforms1[0]*($axisVec2.x)) + ($xforms1[1]*($axisVec2.y)) + ($xforms1[2]*($axisVec2.z));
    $values2[1] = ($xforms2[0]*($axisVec2.x)) + ($xforms2[1]*($axisVec2.y)) + ($xforms2[2]*($axisVec2.z));
    
    if (($values1[1] - $values1[0]) != 0) $slope = ($values2[1] - $values2[0])/($values1[1] - $values1[0]);
    else $slope = 0;
    $offset = $values2[0] - ($slope*$values1[0]);
    
    $floatArray = $axisVec2;
    for ($i = 0; $i < size($floatArray);$i++) if ($floatArray[$i] > 0) $axis2Index = $i;
    $targetXforms[$axis2Index] = $slope*$targetXforms[$axis1Index] + $offset;
    
    move -ws $targetXforms[0] $targetXforms[1] $targetXforms[2] $sels[2];
}

//-------------------------------------------------------------dkArrayToStringArray---------------------------------------------------------------------
global proc string dkArrayToStringArray(string $array[]) {
    string $cmd;
    $cmd = ("string $names[] = {\"" + $array[0] + "\"");
    for ($i=1; $i<size($array); $i++) $cmd += (", \"" + $array[$i] + "\"");
    $cmd += "};";
    print ($cmd + "\n");
    return $cmd;
}

//-------------------------------------------------------------dkSelectionToStringArray---------------------------------------------------------------------
global proc string dkSelectionToStringArray() {
    string $sels[], $cmd;
    $sels = `ls -sl`;
    $cmd = ("$names = {\"" + $sels[0] + "\"");
    for ($i=1; $i<size($sels); $i++) $cmd += (", \"" + $sels[$i] + "\"");
    $cmd += "};";
    print ($cmd + "\n");
    return $cmd;
}

//-------------------------------------------------------------dkSelectionToCmd---------------------------------------------------------------------
global proc string dkSelectionToCmd() {
    string $sels[], $cmd;
    $sels = `ls -sl`;
    $cmd = ("select -r");
    for ($i=0; $i<size($sels); $i++) $cmd += (" " + $sels[$i]);
    $cmd += ";";
    print ($cmd + "\n");
    return $cmd;
}

//-------------------------------------------------------------dkGetCVNums---------------------------------------------------------------------
global proc string[] dkGetCVNums() {
    string $sels[], $cvs[], $array[];
    
    $sels = `ls -sl`;
    for ($i = 0; $i < size($sels); $i++) {
        $array = stringToStringArray($sels[$i], "[]");
        $cvs[$i] = $array[1];
    }
    return $cvs;
}

//-------------------------------------------------------------dkLattice---------------------------------------------------------------------
//creates a lattice that is the length of non-mesh selections and rotates 45 degrees                                                                                                                                                       
global proc string dkLattice() {
    global string $dkLatticeTempJoint;
    string $array[], $joints[], $sels[], $verts[], $ffdLattice, $ffdBase, $result, $name;
    float $length, $wp[], $minWidth, $bb[], $hyp;

    $result = `promptDialog -b "OK" -b "Cancel" -db "OK" -message "Name That Lattice! (trademark, restricted, copyright 2009)" -messageAlign "center" -text "duuuuuude" -title "Name Lattice" -dismissString "Cancel"`;
    if ($result == "OK") $name = `promptDialog -q -text`; 
    else return $result;
    
    $sels = `ls -sl`;
    for ($sel in $sels)  {
        if  (`nodeType $sel` == "mesh") $verts[size($verts)] = $sel;
        else $joints[size($joints)] = $sel;
    }

    if (size($joints) != 2) error "please select two transform points.";
    
    select -r $verts;
    $length = `nas_distance {$joints[0], $joints[size($joints)-1]}`;
    $res = $length / .16;
    $array = `lattice -n ($name + "_ffd") -divisions $res 2 2 -objectCentered true -ldv 10 10 10`;
    $ffdLattice = $array[1];
    $ffdBase = $array[2];

    $wp = `xform -ws -q -bb $ffdLattice`;
    if (($wp[5] - $wp[2]) > ($wp[4] - $wp[1])) $minWidth = $wp[5] - $wp[2];
    else $minWidth = $wp[4] - $wp[1];
    $hyp = sqrt((pow($minWidth, 2) + pow($minWidth, 2)));
    scale $length $hyp $hyp $ffdLattice $ffdBase; 

    $array = `ls ($ffdLattice + ".pt[0][0:1][0:1]")`;
    $bb = `xform -ws -q -bb $array`;
    for ($i = 0; $i < 3; $i++) $wp[$i] = ($bb[$i] + $bb[$i+3])/2.0;
    xform -ws -rp $wp[0] $wp[1] $wp[2] -sp $wp[0] $wp[1] $wp[2] $ffdLattice $ffdBase;
    
    select -r $joints[0] $ffdLattice $ffdBase;
    nas_matchTransforms 1 1 1 1 1 1 0 0 0;
    select -r $joints[size($joints)-1] $ffdLattice;
    dkAim x y y;
    select -r $joints[size($joints)-1] $ffdBase;
    dkAim x y y;
    rotate -r -os 45 0 0 $ffdLattice $ffdBase;
    select -r $ffdLattice $ffdBase;
    print "adjust lattice and run dkSkinLattice with lattice and influences selected";
    return $ffdLattice;
}

//-------------------------------------------------------------dkSkinLattice---------------------------------------------------------------------
//make ability to revert back to lattice stage when run
global proc dkSkinLattice() {
    global string $dkLatticeTempJoint;
    string $ffdLattice, $array[], $verts[], $sels[], $joints[], $geos[];
    
    //find the lattice and joints in selection
    $sels = `ls -sl`;
    for ($sel in $sels) {
        $array = `listRelatives -s $sel`;
        if (`objExists $array[0]`) if (`nodeType $array[0]` == "lattice") $ffdLattice = $sel;
    }
    $joints = stringArrayRemove({$ffdLattice}, $sels);
    
    //bind joints to lattice
    select -r $joints $ffdLattice;
    nas_skinCluster;
    
    //find deformer verts and geos from verts
    $verts = `nas_getDeformerVerts $ffdLattice`;
    for ($vert in $verts) {
        $array = stringToStringArray($vert, ".");
        $geos[size($geos)] = $array[0];
    }
    $geos = `stringArrayRemoveDuplicates $geos`;    
    
    //create temp joint
    select -cl;
    if (!`objExists $dkLatticeTempJoint`) $dkLatticeTempJoint = `joint -n "dkLatticeTempJnt" -p 0 0 0`;
    
    //assign verts to temp joint 
    for ($geo in $geos) {        
        select -r $joints $dkLatticeTempJoint $geo;
        skinPercent -tv $dkLatticeTempJoint 1 `nas_skinCluster` (nas_stringArrayIntersection(`ls -fl ($geo + ".vtx[*]")`, $verts));
    }
    select -r $ffdLattice;
    print "\n";
    print "Lattice skinned!";
}

//-------------------------------------------------------------dkLatticeToJoints---------------------------------------------------------------------
//select lattice and run
global proc dkLatticeToJoints() {
    global string $dkLatticeTempJoint;
    string $verts[], $lattice, $clusters[], $array[], $skinClusters[], $joints[], $skin, $ffd, $infs[], $geos[];
    
    //assign lattice and ffd
    $array = `ls -sl`;
    $lattice = $array[0];
    $array = `listHistory -pdo 1 -f 1 $lattice`;
    $ffd = $array[0];
    $verts = `nas_getDeformerVerts $ffd`;
    
    //get influences affecting lattice
    $infs = `skinCluster -q -inf (nas_getSkinCluster($lattice))`;
    
    for ($vert in $verts) {
        $array = stringToStringArray($vert, ".");
        $geos[size($geos)] = $array[0];
    }
    $geos = stringArrayRemoveDuplicates($geos);
    
    //set envelopes of skin clusters and ffd
    for ($geo in $geos) {
        select -r $infs $geo;
        setAttr (`nas_skinCluster` + ".envelope") 0;
    }
    setAttr ($ffd + ".envelope") 1;
    
    //make clusters from joints and use clusters as controls for dkExtrapToJoints
    select -r `ls ($lattice + ".pt[*][*][*]")`;
    $clusters = `dkJointsToClusters`;
    select -r $clusters;
    $array = `dkExtrapToJoints 1 $verts`;
    for ($item in $array) if (`nodeType $item` == "skinCluster") $skinClusters[size($skinClusters)] = $item;
    
    //set envelopes for skin clusters and ffd
    for ($skinCluster in $skinClusters) setAttr ($skinCluster + ".envelope") 1;
    setAttr ($ffd + ".envelope") 0;
    
    //clean up
    if (!`objExists ($lattice + "_Weighting_Group")`) group -em -n ($lattice + "_Weighting_Group");
    delete $clusters;
    catchQuiet (`parent $lattice ($lattice + "_Weighting_Group")`);
    if (`objExists ($ffd + "Base")`) catchQuiet(`parent($ffd + "Base") ($lattice + "_Weighting_Group")`);
    hide ($lattice + "_Weighting_Group");
    if (`objExists $dkLatticeTempJoint`) delete $dkLatticeTempJoint;
    print "\n";
}

//-------------------------------------------------------------dkWeightVerts---------------------------------------------------------------------
global proc dkWeightVerts(int $override, string $verts[], string $joints[], int $midIndex, float $baseWeight, float $fallOff) {
    string $array[], $skinCluster, $sels[];
    float $max, $envelope, $totalWeight;
    int $nums[];

    if ($baseWeight > 1 || $baseWeight < 0) error "base weight must be between 0 and 1";
    if (size($joints) != 2) error "must specify only 2 joints";

    $skinCluster = `nas_getSkinCluster $verts[0]`;
    $infs = `skinCluster -q -inf $skinCluster`;
    for ($i = 0; $i < size($infs); $i++) $holds[$i] = `getAttr ($infs[$i] + ".liw")`;
    if ($override) for ($inf in $infs) setAttr ($inf + ".liw") 0;
    
    //skinPercent -normalize off -tv $joints[0] $baseWeight -tv $joints[1] (1-$baseWeight) $skinCluster $verts[$midIndex];
    $max = `pow $midIndex $fallOff`;
    for ($i=0;$i<=$midIndex;$i++) {
        if ($override) {
            $totalWeight = 1;
            skinPercent -normalize off -pruneWeights 100 $skinCluster $verts[$i];
        } else {
            /*print "\n";
            $totalWeight = `skinPercent -t $joints[0] -q -v $skinCluster $verts[$i]`;
            print ($joints[0] + "'s weighting is " + $totalWeight + "\n");
            $totalWeight = `skinPercent -t $joints[1] -q -v $skinCluster $verts[$i]`;
            print ($joints[1] + "'s weighting is " + $totalWeight + "\n");
            */
            $totalWeight = `skinPercent -t $joints[0] -q -v $skinCluster $verts[$i]`;
            $totalWeight += `skinPercent -t $joints[1] -q -v $skinCluster $verts[$i]`;
            //print ("total weight is " + $totalWeight + "\n");
        }
        $envelope = `pow $i $fallOff`;
        if ($envelope == $max) $envelope = 1;
        else $envelope /= $max;
        skinPercent -normalize off -tv $joints[0] (`pow $baseWeight $envelope`*$totalWeight) -tv $joints[1] ((1-`pow $baseWeight $envelope`)*$totalWeight) $skinCluster $verts[$i];
    }
    $max = `pow ((size($verts)-1)-$midIndex) $fallOff`;
    for ($i=$midIndex+1;$i<size($verts);$i++) {
        if ($override) {
            $totalWeight = 1;
            skinPercent -normalize off -pruneWeights 100 $skinCluster $verts[$i];
        } else {
            $totalWeight = `skinPercent -t $joints[0] -q -v $skinCluster $verts[$i]`;
            $totalWeight += `skinPercent -t $joints[1] -q -v $skinCluster $verts[$i]`;
        }
        $envelope = `pow ((size($verts)-1)-$i) $fallOff`;
        $envelope /= $max;
        skinPercent -normalize off -tv $joints[0] ((1-`pow (1-$baseWeight) $envelope`)*$totalWeight) -tv $joints[1] (`pow (1-$baseWeight) $envelope`*$totalWeight) $skinCluster $verts[$i];
    }
    if ($override) for ($i = 0; $i < size($holds); $i++) if ($holds[$i] == 1) setAttr ($infs[$i] + ".liw") 1;
    select -r $verts;
}

global proc dkWeightVertsUI() {
    global string $dkWeightVertsScroll, $dkWeightVertsMidIndexSlider, $dkWeightVertsBaseWeightSlider, $dkWeightVertsFallOffSlider, $dkWeightVertsOverrideCheckBox;
    string $window, $form, $cmd, $items[], $loadButton, $unloadButton, $upButton, $downButton, $getButton, $reloadButton, $weightButton, $joints[], $selects[], $infs[], $weightButton;
    int $override;
    
    if (`optionVar -exists "dkWeightVertsJoints"`) $items = `optionVar -q "dkWeightVertsJoints"`;
    if (`optionVar -exists "dkWeightVertsOverride"`) $override = `optionVar -q "dkWeightVertsOverride"`;
    
    $window = `nas_window dkWeightVerts 1 0 0`;
        $form = `formLayout`;
            $cmd = "textScrollList ";
            for ($item in $items) $cmd += ("-append \"" + $item + "\" ");
            for ($select in $selects) $cmd += ("-si \"" + $select + "\" ");
            $cmd += " -allowMultiSelection true -showIndexedItem 1 dkWeightVertsScroll";
            $dkWeightVertsScroll = `eval ($cmd)`;
            $dkWeightVertsOverrideCheckBox = `checkBox -al center -label "Override Hold" -v 0`;
            $loadButton = `button -label "Add" -c "dkWeightVertsFuncs add"`;
            $unloadButton = `button -label "Remove" -c "dkWeightVertsFuncs remove"`;
            $upButton = `button -label "Up" -c "dkWeightVertsFuncs up"`;
            $downButton = `button -label "Down" -c "dkWeightVertsFuncs down"`;
            $getButton = `button -label "Get" -c "dkWeightVertsFuncs get"`;
            $weightButton = `button -label "Weight" -c "dkWeightVertsFuncs weight"`;
            $weightOthersButton = `button -label "Weight Others" -c "dkWeightVertsExecute 1"`;
            $selectOthersButton = `button -label "Select Others" -c "dkWeightVertsFuncs selectOthers"`;
            
            $dkWeightVertsMidIndexSlider = `floatSliderGrp -label "Mid Index" -field true
                -minValue .001 -maxValue 1.0
                -fieldMinValue .001 -fieldMaxValue 1.0
                -cw 1 80 -cw 2 40 -adjustableColumn 3
                -value .5 -fieldStep .001 -sliderStep .001
                -changeCommand "dkWeightVertsExecute 0"`;
                //-dragCommand "dkWeightVertsExecute"`;
            $dkWeightVertsBaseWeightSlider = `floatSliderGrp -label "Base Weight" -field true
                -minValue .001 -maxValue .999
                -fieldMinValue .001 -fieldMaxValue .999
                -cw 1 80 -cw 2 40 -adjustableColumn 3
                -value .5 -fieldStep .001 -sliderStep .001
                -changeCommand "dkWeightVertsExecute 0"`; 
                //-dragCommand "dkWeightVertsExecute"`;
            $dkWeightVertsFallOffSlider = `floatSliderGrp -label "Fall Off" -field true
                -minValue 0.0 -maxValue 5.0
                -fieldMinValue 0.0 -fieldMaxValue 100.0
                -cw 1 80 -cw 2 40 -adjustableColumn 3
                -value 2.5 -fieldStep .001 -sliderStep .001
                -changeCommand "dkWeightVertsExecute 0"`; 
                //-dragCommand "dkWeightVertsExecute"`;
            setParent..;
        formLayout -e 
            -af $dkWeightVertsMidIndexSlider "left" 5
            -af $dkWeightVertsMidIndexSlider "right" 5
            -af $dkWeightVertsMidIndexSlider "top" 5
            
            -af $dkWeightVertsBaseWeightSlider "left" 5
            -af $dkWeightVertsBaseWeightSlider "right" 5
            -ac $dkWeightVertsBaseWeightSlider "top" 0 $dkWeightVertsMidIndexSlider
            
            -af $dkWeightVertsFallOffSlider "left" 5
            -af $dkWeightVertsFallOffSlider "right" 5
            -ac $dkWeightVertsFallOffSlider "top" 0 $dkWeightVertsBaseWeightSlider
            
            -af $dkWeightVertsOverrideCheckBox "left" 5
            -ac $dkWeightVertsOverrideCheckBox "top" 0 $dkWeightVertsFallOffSlider
            
            -af $dkWeightVertsScroll "left" 5
            -af $dkWeightVertsScroll "right" 5
            -ac $dkWeightVertsScroll "top" 0 $dkWeightVertsOverrideCheckBox
            -ac $dkWeightVertsScroll "bottom" 0 $loadButton
            
            -af $loadButton "left" 5
            -ap $loadButton "right" 0 20
            -ac $loadButton "bottom" 0 $weightOthersButton
            
            -ap $unloadButton "left" 0 20
            -ap $unloadButton "right" 0 40
            -ac $unloadButton "bottom" 0 $weightOthersButton
            
            -ap $getButton "left" 0 40
            -ap $getButton "right" 0 60
            -ac $getButton "bottom" 0 $weightOthersButton
            
            -ap $upButton "left" 0 60
            -ap $upButton "right" 0 80
            -ac $upButton "bottom" 0 $weightOthersButton
            
            -ap $downButton "left" 0 80
            -af $downButton "right" 5
            -ac $downButton "bottom" 0 $weightOthersButton
            
            -af $weightButton "left" 5
            -ap $weightButton "right" 0 33
            -af $weightButton "bottom" 5
            
            -ap $weightOthersButton "left" 0 33
            -ap $weightOthersButton "right" 0 66
            -af $weightOthersButton "bottom" 5
            
            -ap $selectOthersButton "left" 0 66
            -af $selectOthersButton "right" 5
            -af $selectOthersButton "bottom" 5

        $form;
    window -e -wh 400 (160 + (size($items)*16)) $window;
    showWindow $window;
}

global proc dkWeightVertsExecute(int $others) {
    global string $dkWeightVertsScroll, $dkWeightVertsMidIndexSlider, $dkWeightVertsBaseWeightSlider, $dkWeightVertsFallOffSlider, $dkWeightVertsOverrideCheckBox;
    string $verts[], $array[], $sels[], $joints[], $selInds[], $allPoints[], $otherInds[], $workInds[], $lattice, $otherVerts[];
    float $midIndexFloat;
    int $nums[], $midIndex;
    
    $sels = `ls -sl -flatten`;
    if (`gmatch $sels[0] "*.pt*"`) {    
        for ($i=0;$i<size($sels);$i++) {
            $array = stringToStringArray($sels[$i], "[]");
            $nums[$i] = $array[1];
        }
        $nums = `sort $nums`;
        for ($i=0;$i<size($nums);$i++) {
            for ($sel in $sels) {
                $array = stringToStringArray($sel, "[]");
                if ($nums[$i] == $array[1]) {
                    $verts[$i] = $sel;
                    break;
                }
            }
        }
    } else if (`gmatch $sels[0] "*.vtx*"`) {
        $verts = `nas_getSels`;
    }
    
    $joints = `textScrollList -q -si $dkWeightVertsScroll`;
    if (size($joints) != 2) error "must select two joints only from list";
    $midIndexFloat = `floatSliderGrp -q -v $dkWeightVertsMidIndexSlider`;
    $midIndex = ((size($verts)) - .0000000001) * $midIndexFloat;    
    if (`optionVar -exists "dkWeightVertsOverride"`) optionVar -rm "dkWeightVertsOverride";
    optionVar -intValue "dkWeightVertsOverride" `checkBox -q -value $dkWeightVertsOverrideCheckBox`;
    
    if ($others) {
        for ($i=0;$i<size($verts);$i++) {
            $array = stringToStringArray($verts[$i], "[]");
            $workInds[$i] = $array[1];
        }
        $array = stringToStringArray($verts[0], "[]");
        $lattice = $array[0];
        $selInds = {$array[2], $array[3]};
        $allPoints = `ls -flatten ($array[0] + "[*][*][*]")`;
        sort $allPoints;
        for ($vert in $allPoints) {
            $array = stringToStringArray($vert, "[]");
            if (($array[2] + $array[3]) != ($selInds[0] + $selInds[1])) $otherInds[size($otherInds)] = ("[" + $array[2] + "][" + $array[3] + "]");
        }
        $otherInds = stringArrayRemoveDuplicates($otherInds);
        for ($otherInd in $otherInds) {
            for ($i = 0;$i < size($workInds); $i++) $otherVerts[$i] = ($lattice + "[" + $workInds[$i] + "]" + $otherInd);
            dkWeightVerts `checkBox -q -value $dkWeightVertsOverrideCheckBox` $otherVerts $joints $midIndex `floatSliderGrp -q -v $dkWeightVertsBaseWeightSlider` `floatSliderGrp -q -v $dkWeightVertsFallOffSlider`;
        }
    } else {
        dkWeightVerts `checkBox -q -value $dkWeightVertsOverrideCheckBox` $verts $joints $midIndex `floatSliderGrp -q -v $dkWeightVertsBaseWeightSlider` `floatSliderGrp -q -v $dkWeightVertsFallOffSlider`;
    }
    select -r $sels;
}

global proc dkWeightVertsFuncs(string $option) {
    global string $dkWeightVertsMidIndexSlider, $dkWeightVertsScroll;
    string $items[], $allItems[], $cmd, $selectCmd, $sels[], $scrollSels[], $verts[], $array[], $workInds[], $lattice, $selInds[], $allPoints[], $otherInds[], $otherVerts[];
    int $indices[];
    
    $items = `textScrollList -q -si $dkWeightVertsScroll`;
    $allItems = `textScrollList -q -allItems $dkWeightVertsScroll`;
    $indices = `textScrollList -q -selectIndexedItem $dkWeightVertsScroll`;
    
    $cmd = "textScrollList -e ";
    switch ($option) {
        case "weight":
            nas_weight 1 0 $items;
            break;
        case "up":
            for ($i = 0; $i < size($items); $i++) {
                if (($indices[$i] - 1) < 1) $cmd += ("-ri " + "\"" + $items[$i] + "\" -appendPosition " + $indices[$i] + " \"" + $items[$i] + "\" ");
                else $cmd += ("-ri " + "\"" + $items[$i] + "\" -appendPosition " + ($indices[$i] - 1) + " \"" + $items[$i] + "\" ");
                $cmd += ("-si " + "\"" + $items[$i] + "\" ");
            }
            break;
        case "down":
            for ($i = 0; $i < size($items); $i++) $cmd += ("-ri " + "\"" + $items[$i] + "\" -appendPosition " + ($indices[$i] + 1) + " \"" + $items[$i] + "\" -si " + "\"" + $items[$i] + "\" ");
            break;
        case "add":
            $sels = `ls -sl`;
            if (size($sels) > 0) textScrollList -e -da $dkWeightVertsScroll;
            $selectCmd = "textScrollList -e ";
            for ($sel in $sels) for ($item in $allItems) if ($sel == $item) $selectCmd += ("-si \"" + $sel + "\" ");
            $selectCmd += $dkWeightVertsScroll;
            eval $selectCmd;
            $sels = stringArrayRemove($allItems, $sels);
            if (size($sels) > 0) for ($sel in $sels) $cmd += ("-append \"" + $sel + "\" -si \"" + $sel + "\" ");
            break;
        case "remove":
            if (size($items) > 0) for ($item in $items) $cmd += ("-ri \"" + $item + "\" ");
            break;
        case "get":
            $sels = `nas_influencesFromVerts`;
            textScrollList -e -da $dkWeightVertsScroll;
            $selectCmd = "textScrollList -e ";
            for ($sel in $sels) for ($item in $allItems) if ($sel == $item) $selectCmd += ("-si \"" + $sel + "\" ");
            $selectCmd += $dkWeightVertsScroll;
            eval $selectCmd;
            $sels = stringArrayRemove($allItems, $sels);
            if (size($sels) > 0) for ($sel in $sels) $cmd += ("-append \"" + $sel + "\" -si \"" + $sel + "\" ");
            break;
        case "reload":    
            dkWeightVertsUI;     
            for ($index in $indices) $cmd += ("-sii " + $index + " ");
            break;
        case "selectOthers":
            $verts = `ls -sl -flatten`;
            for ($i=0;$i<size($verts);$i++) {
                $array = stringToStringArray($verts[$i], "[]");
                $workInds[$i] = $array[1];
            }
            $array = stringToStringArray($verts[0], "[]");
            $lattice = $array[0];
            $selInds = {$array[2], $array[3]};
            $allPoints = `ls -flatten ($array[0] + "[*][*][*]")`;
            sort $allPoints;
            for ($vert in $allPoints) {
                $array = stringToStringArray($vert, "[]");
                if (($array[2] + $array[3]) != ($selInds[0] + $selInds[1])) $otherInds[size($otherInds)] = ("[" + $array[2] + "][" + $array[3] + "]");
            }
            $otherInds = stringArrayRemoveDuplicates($otherInds);
            for ($otherInd in $otherInds) for ($i = 0;$i < size($workInds); $i++) $otherVerts[size($otherVerts)] = ($lattice + "[" + $workInds[$i] + "]" + $otherInd);
            select -r $otherVerts;
    }
    $cmd += $dkWeightVertsScroll;
    eval $cmd;

    $allItems = `textScrollList -q -allItems $dkWeightVertsScroll`;
    if (`optionVar -exists "dkWeightVertsJoints"`) optionVar -rm "dkWeightVertsJoints";
    for ($allItem in $allItems) optionVar -stringValueAppend "dkWeightVertsJoints" $allItem;
}

//-------------------------------------------------------------dkControlSquareAttrs---------------------------------------------------------------------
//select square control and run
global proc dkControlSquareAttrs() {
    string $attrs[] = {"FaceControls", "EyeControls", "BrowControls", "ElbowControls", "KneeControls", "Head", "LeftArm", "RightArm", "LeftLeg", "RightLeg", "SpineDeformControls", "LeftArmDeformControls", "RightArmDeformControls", "LegDeformControls", "HeadSquashDeformControls", "StomachDeformControls"};
    nas_addAttr "enum" 0 0 "Off:On:" $attrs;
}

//-------------------------------------------------------------dkCloseVerts---------------------------------------------------------------------
//finds verts on the last selected geo that are within the bounding box of the previously selected geos
global proc string[] dkCloseVerts(float $buffer) {
    string $geos[], $array[], $baseGeo, $baseVerts[], $closeVerts[];
    float $bb[], $rp[];

    $geos = `ls -sl`;
    $baseGeo = $geos[size($geos)-1];
    $geos = stringArrayRemove ({$baseGeo}, $geos);
    $bb = `xform -ws -q -bb $geos[0]`;
    for ($geo in $geos) {
        $rp = `xform -ws -q -bb $geo`;
        if ($rp[0] < $bb[0]) $bb[0] = $rp[0];
        if ($rp[1] < $bb[1]) $bb[1] = $rp[1];
        if ($rp[2] < $bb[2]) $bb[2] = $rp[2];
        if ($rp[3] > $bb[3]) $bb[3] = $rp[3];
        if ($rp[4] > $bb[4]) $bb[4] = $rp[4];
        if ($rp[5] > $bb[5]) $bb[5] = $rp[5];
    }
    $baseVerts = `ls -flatten ($baseGeo + ".vtx[*]")`;
    $baseVerts = stringArrayCatenate($baseVerts, `ls -flatten ($baseGeo + ".cv[*][*]")`);
    for ($baseVert in $baseVerts) {
        $rp = `xform -q -ws -translation $baseVert`;
        if ($rp[0] > ($bb[0]-$buffer) && $rp[1] > ($bb[1]-$buffer) && $rp[2] > ($bb[2]-$buffer) && $rp[0] < ($bb[3]+$buffer) && $rp[1] < ($bb[4]+$buffer) && $rp[2] < ($bb[5]+$buffer)) {
            $closeVerts[size($closeVerts)] = $baseVert;
        }
    }
    select -r $closeVerts;
    return $closeVerts;
}

//-------------------------------------------------------------dkWrap---------------------------------------------------------------------
global proc string[] dkWrap(float $buffer) {
    string $geos[], $array[], $baseGeo, $baseVerts[], $closeVerts[], $hists[], $wraps[], $result, $clusters[], $wrapVerts[], $joints[], $skinClusters[], $baseInfs[], $infs[];
    int $askQuestion;

    $geos = `ls -sl`;
    $baseGeo = $geos[size($geos)-1];
    $geos = stringArrayRemove ({$baseGeo}, $geos);

    for ($i = 0; $i < size($geos); $i++) {
        $hists = `listHistory -pdo 1 -il 2 $geos[$i]`;
        for ($hist in $hists) if (`nodeType $hist` == "wrap") {
            $wraps[$i] = $hist;
            break;
        }
        if ($wraps[$i] == "") {
            $askQuestion = 1;
            select -r $geos[$i] $baseGeo;
            $array = `doWrapArgList "4" { "1","0","1", "2", "0" }`;
            $wraps[$i] = $array[0];
        }
    }
    
    if ($askQuestion) {
        $result = `confirmDialog -b "keep going!" -b "tweak wrap attrs" -db "keep going!" -cb "tweak wrap attrs" -ds "tweak wrap attrs" -m "I had to create some wraps. Should I pause so you can edit them?" -ma "center" -title "Change Wrap Settings?"`;
        if ($result == "tweak wrap attrs") return {};
    }
    
    for ($i = 0; $i < size($geos); $i++) {
        select -r $geos[$i] $baseGeo;
        $baseVerts = `dkCloseVerts $buffer`;
        $skinCluster = `nas_getSkinCluster $baseVerts[0]`;
        $infs = `nas_influencesFromVerts`;
        select -r $infs $geos[$i];
    }
    
    select -r $geos $baseGeo;
    $baseVerts = `dkCloseVerts $buffer`;
    $clusters = `dkJointsToClusters`;

    select -r $geos;
    ConvertSelectionToVertices;
    $wrapVerts = `ls -sl -flatten`;
    select -r $clusters;
    $array = `dkExtrapToJoints 1 $wrapVerts`;
    for ($object in $array) if (`nodeType $object` == "skinCluster") $skinClusters[size($skinClusters)] = $object;
    for ($skinCluster in $skinClusters) {
        setAttr ($skinCluster + ".envelope") 1;
        dkRemoveUnusedInfluences($skinCluster);
    }

    delete $clusters;
    delete $wraps;
    //for ($wrap in $wraps) setAttr ($wrap + ".envelope") 0;
    return {""};
}

//-------------------------------------------------------------dkRemoveUnusedInfluences---------------------------------------------------------------------
global proc string[] dkRemoveUnusedInfluences(string $skinCluster) {
    string $infs[], $cmd;
    $infs = stringArrayRemove(`skinCluster -q -wi $skinCluster`, `skinCluster -q -inf $skinCluster`);
    $cmd = "skinCluster -e";
    for ($inf in $infs) $cmd += (" -ri " + $inf);
    $cmd += (" " + $skinCluster);
    eval($cmd);
    select -r $infs;
    return $infs;
}

//-------------------------------------------------------------dkEditMembership---------------------------------------------------------------------
//select controls that will deform geo through the deformer
global proc dkEditMembership(string $deformer) {
    string $ctrls[], $verts[], $removeVerts[];
    float $term_x, $term_y, $term_z;
    vector $baseWp[], $deformWp[], $vec1, $vec2;

    $ctrls = `ls -sl`;
    $verts = `nas_getDeformerVerts $deformer`;
    
    //get world space coordinates of verts in two different poses
    move -os 0 0 0 $ctrls;
    for($i=0;$i<size($verts);$i++) $baseWp[$i] = `xform -query -translation -worldSpace $verts[$i]`;
    move -os 99 99 99 $ctrls;
    for($i=0;$i<size($verts);$i++) $deformWp[$i] = `xform -query -translation -worldSpace $verts[$i]`;
    move -os 0 0 0 $ctrls;

    for ($i = 0; $i < size($verts); $i++) {
        // do distance formula on base position to deform position (inflat/scale by 100 for calculations)
        $vec1 = $baseWp[$i];
        $vec2 = $deformWp[$i];
        $term_x = `pow(($vec2.x)-($vec1.x)) 2`; 
        $term_y = `pow(($vec2.y)-($vec1.y)) 2`; 
        $term_z = `pow(($vec2.z)-($vec1.z)) 2`;
        if (sqrt($term_x + $term_y + $term_z) == 0) $removeVerts[size($removeVerts)] = $verts[$i];
    }
    sets -rm `dkGetDeformerSet $deformer` $removeVerts;
}

//-------------------------------------------------------------dkFloatArrayRemoveAtIndex---------------------------------------------------------------------
global proc float[] dkFloatArrayRemoveAtIndex(int $inds[], float $floatArray[]) {
    float $newFloatArray[];
    int $flag;
    
    for ($i = 0; $i < size($floatArray); $i++) {
        for ($ind in $inds) {
            if ($i == $ind) $flag = 1;
        }
        if ($flag == 0) $newFloatArray[size($newFloatArray)] = $floatArray[$i];
        $flag = 0;
    }
    return $newFloatArray;
}

//-------------------------------------------------------------dkRenameSide---------------------------------------------------------------------
global proc string[] dkRenameSide(string $sourceObjs[]) {
    string $newName, $targetObjs[];
    $sides = {"LT", "RT", "Lt", "Rt", "Left", "Right", "left", "right"};
    for ($i = 0; $i < size($sourceObjs); $i++) {
        for ($j = 0; $j < size($sides); $j+=2) {
            $newName = `substitute $sides[$j] $sourceObjs[$i] $sides[$j+1]`;
            if ($newName == $sourceObjs[$i]) $newName = `substitute $sides[$j+1] $sourceObjs[$i] $sides[$j]`;
            if ($newName != $sourceObjs[$i]) {
                $targetObjs[$i] = $newName;
                break;
            }
        }
        print ($sourceObjs[$i] + " ----> " + $targetObjs[$i] + "\n");
    }
    return $targetObjs;
}

//-------------------------------------------------------------dkNudge---------------------------------------------------------------------
global proc dkNudge(string $type, string $axis, float $amount) {
    global float $dkNudgePivots[];
    string $loc, $sels[];
    vector $axisVec = `nas_axisToVector $axis`;
    float $pivots[], $bb[];
    $sels = `ls -sl -long`;
    
    $pivots = $dkNudgePivots;
    
    if (!size($pivots)) {
        $bb = `nas_boundingBox $sels`;
        for ($i = 0; $i < 3; $i++) $pivots[$i] = ($bb[$i] + $bb[$i+3])/2;
    }
    if ($type == "translate") move -r -os -wd ($axisVec.x*$amount) ($axisVec.y*$amount) ($axisVec.z*$amount);
    else if ($type == "rotate") rotate -r -p $pivots[0] $pivots[1] $pivots[2] -os ($axisVec.x*$amount) ($axisVec.y*$amount) ($axisVec.z*$amount);
    else if ($type == "scale") scale -r -p $pivots[0] $pivots[1] $pivots[2] (1+($axisVec.x*$amount)) (1+($axisVec.y*$amount)) (1+($axisVec.z*$amount));
}

global proc dkGetNudgePivot() {
    string $sels[] = `ls -sl`;
    global float $dkNudgePivots[];
    if (`gmatch $sels[0] "*.vtx*"` || `gmatch $sels[0] "*.cv*"` || `gmatch $sels[0] "*.pt*"`) $dkNudgePivots = `xform -q -ws -translation $sels[0]`;
    else $dkNudgePivots = `xform -q -ws -rp $sels[0]`;
}

global proc dkClearNudgePivot() {
    global float $dkNudgePivots[];
    clear $dkNudgePivots;
}

//-------------------------------------------------------------dkCompareScale---------------------------------------------------------------------
//returns scale values for second obj when compared to first obj
global proc dkCompareScale1() {
    global float $dkCompareScale1[];
    float $bb[];
    string $sels[];
    
    $sels = `ls -sl -long`;
    
    $bb = `nas_boundingBox $sels`;
    for ($i = 0; $i < 3; $i++) $dkCompareScale1[$i] = abs($bb[$i+3] - $bb[$i]);
    print "\nLengths per axis:\n";
    print ("x: " + $dkCompareScale1[0] + "\n");
    print ("y: " + $dkCompareScale1[1] + "\n");
    print ("z: " + $dkCompareScale1[2] + "\n");
}
global proc dkCompareScale2() {
    global float $dkCompareScale2[];
    float $bb[];
    string $sels[];
    
    $sels = `ls -sl -long`;
    
    $bb = `nas_boundingBox $sels`;
    for ($i = 0; $i < 3; $i++) $dkCompareScale2[$i] = abs($bb[$i+3] - $bb[$i]);
    print "\nLengths per axis:\n";
    print ("x: " + $dkCompareScale2[0] + "\n");
    print ("y: " + $dkCompareScale2[1] + "\n");
    print ("z: " + $dkCompareScale2[2] + "\n");
}
global proc float[] dkCompareScale() {
    global float $dkCompareScale1[], $dkCompareScale2[];
    float $scales[];
    if (size($dkCompareScale1) == 3 && size($dkCompareScale2) == 3) for ($i = 0; $i < 3; $i++) $scales[$i] = ($dkCompareScale2[$i]/$dkCompareScale1[$i]);
    print "\nscale comparison:\n";
    print ("x: " + $scales[0] + "\n");
    print ("y: " + $scales[1] + "\n");
    print ("z: " + $scales[2] + "\n");
    return $scales;
}

//-------------------------------------------------------------dkPointsToCluster---------------------------------------------------------------------
global proc string[] dkPointsToCluster() {
    string $targetPoints[], $clusters[];
    $targetPoints = `nas_getSels`;
    for ($targetPoint in $targetPoints) {
        select -r $targetPoint;
        $clusters[size($clusters)] = `dkDeformationToCluster`;
    }
    select -r $clusters;
    return $clusters;
}

//-------------------------------------------------------------dkMirrorClusters---------------------------------------------------------------------
global proc dkMirrorClusters(){
    string $sourceVerts[], $targetVerts[], $deformers[], $array[], $targetDeformer, $clusters[], $resultClusters[], $allVerts[], $mirrorVerts[];
    float $weights[], $wp[];
    
    $clusters = `ls -sl`;
    for ($i = 0; $i < size($clusters); $i++) {
        $array = `listHistory -pdo 1 -f 1 $clusters[$i]`;
        $deformers[$i] = $array[0];
        $allVerts = stringArrayCatenate($allVerts, `nas_getDeformerVerts $deformers[$i]`);
    }
    $allVerts = stringArrayRemoveDuplicates($allVerts);
    select -r $allVerts;
    $mirrorVerts = `dkGetMirrorVerts -x 0`;
    for ($i = 0; $i < size($clusters); $i++) {
        //find target verts for mirror verts
        $sourceVerts = `nas_getDeformerVerts $deformers[$i]`;
        for ($j = 0; $j < size($sourceVerts); $j++) {
            for ($k = 0; $k < size($allVerts); $k++) {
                if ($sourceVerts[$j] == $allVerts[$k]) {
                    $targetVerts[$j] = $mirrorVerts[$k];
                    break;
                }
            }
        }
        
        //create the cluster
        select -r $targetVerts;
        $array = `newCluster " -envelope 1"`;
        $targetDeformer = $array[0];
        $resultClusters[$i] = $array[1];
        $wp = `xform -q -rp -ws $clusters[$i]`;
        xform -ws -rp (-1*$wp[0]) $wp[1] $wp[2] $resultClusters[$i];
        select -r $array[1]; dkCenterCluster;
        
        //weight the new cluster
        $weights = `percent -q -v $deformers[$i] $sourceVerts`;
        for ($j = 0; $j < size($targetVerts); $j++) {
            percent -v $weights[$j] $targetDeformer $targetVerts[$j];
        }
    }
    $array = `dkRenameSide $clusters`;
    for ($i = 0; $i < size($clusters); $i++) $resultClusters[$i] = `rename $resultClusters[$i] $array[$i]`;
    select -r $resultClusters;
}

//-------------------------------------------------------------dkFlipVerts---------------------------------------------------------------------
//select base geo followed by the target geo
global proc dkFlipVerts(string $axis) {
    string $array[], $baseGeo, $targetGeo, $baseVerts[], $mirrorVerts[], $vtx, $targetBaseVerts[], $targetMirrorVerts[];
    float $wp[];
    vector $sourceBaseVec, $targetBaseVec, $sourceVec, $targetVec, $offsetVec, $targetMirrorVecs[], $mirrorOffsetVec, $targetBaseVecs[];
    
    $result = `confirmDialog -b "Flip" -b "Mirror" -b "Cancel" -db "Flip" -cb "Mirror" -ds "Cancel" -m "flip or mirror?" -ma "center" -title "Flip?"`;
    if ($result == "Cancel") return;
    
    $array = `ls -sl`;
    $sourceGeo = $array[0];
    $targetGeo = $array[1];
    $baseVerts = `dkAlteredVerts $targetGeo $sourceGeo`;
    select -r $baseVerts;
    $mirrorVerts = `dkGetMirrorVerts $axis 0`;
    
    //get base and mirror verts for target geo
    for ($i = 0; $i < size($baseVerts); $i++) {
        $array = stringToStringArray($baseVerts[$i], ".");
        $targetBaseVerts[$i] = ($targetGeo + "." + $array[1]);
        $array = stringToStringArray($mirrorVerts[$i], ".");
        $targetMirrorVerts[$i] = ($targetGeo + "." + $array[1]);
    }
    $sourceVec = `xform -q -ws -rp $sourceGeo`;
    $targetVec = `xform -q -ws -rp $targetGeo`;
    
    //move mirror verts on target geo
    for ($i = 0; $i < size($targetBaseVerts); $i++) {
        $targetBaseVec = `xform -q -ws -translation $targetBaseVerts[$i]`;
        $targetBaseVec -= $targetVec;
        $sourceBaseVec = `xform -q -ws -translation $baseVerts[$i]`;
        $sourceBaseVec -= $sourceVec;
        $offsetVec = $targetBaseVec - $sourceBaseVec;
        $targetBaseVecs[$i] = $offsetVec;
        
        if ($axis == "x" || $axis == "-x") $mirrorOffsetVec = <<($offsetVec.x)*-1, ($offsetVec.y), ($offsetVec.z)>>;
        if ($axis == "y" || $axis == "-y") $mirrorOffsetVec = <<($offsetVec.x), ($offsetVec.y)*-1, ($offsetVec.z)>>;
        if ($axis == "z" || $axis == "-z") $mirrorOffsetVec = <<($offsetVec.x), ($offsetVec.y), ($offsetVec.z)*-1>>;
        
        $targetMirrorVecs[$i] = `xform -q -ws -translation $targetMirrorVerts[$i]`;
        $targetMirrorVecs[$i] += $mirrorOffsetVec;
    }
    
    for ($i = 0; $i < size($targetMirrorVerts); $i++) {
        $wp = $targetMirrorVecs[$i];
        xform -ws -translation $wp[0] $wp[1] $wp[2] $targetMirrorVerts[$i];
    }
    
    //bring base verts back to default position if flip
    if ($result == "Flip") {
        for ($i = 0; $i < size($targetBaseVerts); $i++) {
            $targetBaseVec = `xform -q -ws -translation $targetBaseVerts[$i]`;
            $targetBaseVec -= $targetBaseVecs[$i];
            xform -ws -translation ($targetBaseVec.x) ($targetBaseVec.y) ($targetBaseVec.z) $targetBaseVerts[$i];            
        }
    }
}

//-------------------------------------------------------------dkSaveOptions---------------------------------------------------------------------
global proc dkSaveOptions() {
    string $result = `confirmDialog -m "Would you like to save?" -ma "center" -b "Incremental Save" -b "Save New Version" -b "Save As" -b "No Thanks!"`;
    if (size(`file -q -sn`)) {
        if ($result == "Incremental Save") {
            incrementalSaveScene;
            print ("Scene saved as " + `file -q -sn` + " and backed up in \"incrementalSave\" folder\n");
        } else if ($result == "Save New Version") {
            dkSaveNewVersion;
        } else if ($result == "Save As") {
            dkSaveSceneAs;
        }
    } else projectViewer SaveAs;
}

//-------------------------------------------------------------dkReturnPath---------------------------------------------------------------------
global proc string dkReturnPath(int $mode) {
    string $array[], $path, $filename, $shaderLoc, $shaderFileList, $shaderFiles[], $removeFolders[], $results[], $messages[], $parts[], $outWip;
    $path = `file -q -sn`;
    $array = stringToStringArray($path, "/");
    $filename = $array[size($array)-1];
    stringArrayRemoveAtIndex(size($array)-1, $array);
    $path = stringArrayToString($array, "\\");
    if ($array[0] == "P:") $array[2] = "renderData\\shaders";
    else $array[3] = "renderData\\shaders";
    $removeFolders = {"Old", "Rig", "Clean", "old", "rig", "clean"};
    for ($removeFolder in $removeFolders) {
        for ($i = 0; $i < size($array); $i++) if ($array[$i] == $removeFolder) {
        stringArrayRemoveAtIndex($i, $array);
            break;
        }
    }
    $shaderLoc = stringArrayToString($array, "\\");
    $array = stringToStringArray($shaderLoc, "\\");
    $shaderFiles = `getFileList -folder ((stringArrayToString($array, "/")) + "/")`;
    $shaderFiles = `sort $shaderFiles`;
    $shaderFileList = stringArrayToString($shaderFiles, "\n");
    
    $array = stringToStringArray($path, "\\");
    for ($item in $array) {
        if ($item == "WIP") break;
        else $parts[size($parts)] = $item;
    }
    $array = `getFileList -folder (stringArrayToString($parts, "/") + "/") -filespec "*.ma"`;
    $outWip = $array[0];

    $results = {$outWip, $path, $filename, $shaderLoc, $shaderFileList};
    $messages = {"out of WIP name:", "current file's path:", "current file's name:", "shader location:", "Shaders names for this character:"};
    if ($mode < 3) {
        promptDialog -b "OK" -db "OK" -m $messages[$mode] -ma "center" -t "dkReturnPath" -tx $results[$mode];
    } else if ($mode == 3) {
        confirmDialog -b "OK" -db "OK" -m ($messages[$mode] + "\n\n" + $shaderFileList) -ma "left";
        print $shaderFileList;
        return $path;
    }
    return $results[$mode];
}

//-------------------------------------------------------------dkMatchVerts---------------------------------------------------------------------
global proc dkMatchVerts(string $sourceGeo, string $targetGeo) {
    string $verts[], $array[], $sourceVerts[], $targetVerts[], $matchVerts[];
    float $dist, $lowestDist, $wp[];
    int $sum, $counter;
    
    $verts = `ls -sl -flatten`;
    for ($vert in $verts) {
        $array = stringToStringArray($vert, ".");
        if ($array[0] == $sourceGeo) $sourceVerts[size($sourceVerts)] = $vert;
        if ($array[0] == $targetGeo) $targetVerts[size($targetVerts)] = $vert;
    }
    
    for ($i = 1; $i <= size($targetVerts); $i++) $sum += $i;  
    nas_progress (size($sourceVerts)) "start";
    for ($i = 0; $i < size($sourceVerts); $i++) {
        $lowestDist = 10000000000;
        for ($j = 0; $j < size($targetVerts); $j++) {
            $dist = `nas_distance {$sourceVerts[$i], $targetVerts[$j]}`;
            if ($dist < $lowestDist) {
            $matchVerts[$i] = $targetVerts[$j];
            $lowestDist = $dist;
            }
        }
        $wp = `xform -q -translation $matchVerts[$i]`;
        move -ws $wp[0] $wp[1] $wp[2] $sourceVerts[$i];
        $targetVerts = stringArrayRemove({$matchVerts[$i]}, $targetVerts);
        if (`nas_progress 0 ("finding match for " + $sourceVerts[$i])`) return;
    }
    nas_progress 0 "end";
}

//-------------------------------------------------------------dkGoHome---------------------------------------------------------------------
global proc dkGoHome() {
    switchModelView persp;
    viewSet -animate 0 -home persp;
    select -r `ls "World*"`;
    fitPanel -selected;
}

//-------------------------------------------------------------dkReEnumSels---------------------------------------------------------------------
global proc dkReEnumSels() {
    string $attrs[], $targets[], $array[], $sels[];
    
    $sels = `ls -sl -long`;
    $attrs = `nas_getCBSelection`;
    
    for ($sel in $sels) {
        for ($i = 0; $i < size($attrs); $i++) {
            $targets = `connectionInfo -dfs ($sel + "." + $attrs[$i])`;
            deleteAttr -attribute $attrs[$i] $sel;
            nas_addAttr "enum" 0 0 "Off:On:" {$attrs[$i]};
            for ($target in $targets) {
                if (`nodeType $target` == "animCurveUU") {
                    $array = stringToStringArray($target, ".");
                    $array = `connectionInfo -dfs ($array[0] + ".output")`;
                    connectAttr -f ($sel + "." + $attrs[$i]) $array[0];
                    delete $target;
                } else {
                    connectAttr -f ($sel + "." + $attrs[$i]) $target;
                }
            }
        }
    }
}

//-------------------------------------------------------------dkConstrainMeshGroup---------------------------------------------------------------------
//script modified from Seiji Tanaka's script
//select COGs and run to constrain mesh groups
global proc dkConstrainMeshGroup() {
    string $sels[], $assetName, $array[];
    
    $sels = `ls -sl`;
    for ($sel in $sels) {
        $array = stringToStringArray($sel, "_");
        stringArrayRemoveAtIndex(size($array)-1, $array);
        $assetName = stringArrayToString($array, "_");
        parent ($assetName + "_COG") ($assetName + "_Transform");
        if (`objExists ($assetName + "_COG")`) {
            makeIdentity -apply true -t 1 -r 1 -s 1 ($assetName + "_COG");
            delete -ch ($assetName + "_COG");
        }
        if (`objExists ($assetName + "_Transform")`) {
            makeIdentity -apply true -t 1 -r 1 -s 1 ($assetName + "_Transform");
            delete -ch ($assetName + "_Transform");
        }
        parentConstraint -mo $sel ($assetName +"_Mesh_Group");
        scaleConstraint -mo $sel ($assetName +"_Mesh_Group");
    }
}

//-------------------------------------------------------------dkReleaseMeshGroup---------------------------------------------------------------------
//script modified from Seiji Tanaka's script
global proc dkReleaseMeshGroup() {
    string $sels[], $assetName, $array[];

    $sels = `ls -sl`;
    for ($sel in $sels) {
        $array = stringToStringArray($sel, "_");
        stringArrayRemoveAtIndex(size($array)-1, $array);
        $assetName = stringArrayToString($array, "_");
        $array = `listRelatives -fullPath -p ($assetName + "_Transform")`;
        parent ($assetName + "_COG") $array[0];
        if (`objExists ($assetName + "_Mesh_Group_parentConstraint1")`) delete ($assetName + "_Mesh_Group_parentConstraint1");
        if (`objExists ($assetName + "_Mesh_Group_scaleConstraint1")`) delete ($assetName + "_Mesh_Group_scaleConstraint1");
    }    
}

//-------------------------------------------------------------dkScaleCtrls---------------------------------------------------------------------
global proc dkScaleCtrls(int $num, float $value) {
    string $sels[], $array[], $cvs[];
    $sels = `ls -sl -flatten`;
    $array = `ls -sl -type joint`;
    $cvs = stringArrayRemove($array, $sels);
    
    select -r $array[0];
    dkGetNudgePivot;
    select -r $cvs;
    for ($i = 0; $i < $num; $i++) {
        dkNudge "scale" "x" $value;dkNudge "scale" "y" $value;dkNudge "scale" "z" $value;
    }
    select -r $cvs;
    setSelectMode components Components;
    selectType -v 1 -smp 0 -sme 0 -smf 0 -smu 0 -pv 1 -pe 0 -pf 0 -puv 0;
}

//-------------------------------------------------------------dkListUnusedSGs---------------------------------------------------------------------
global proc string[] dkListUnusedSGs() {
    string $SGs[], $array[], $deleteSGs[];
    $SGs = `ls -type shadingEngine`;
    for ($SG in $SGs) {
        if (`connectionInfo -sfd ($SG + ".dagSetMembers[0]")` == "" && `connectionInfo -sfd ($SG + ".surfaceShader")` == "") {
            $array = stringToStringArray($SG, ":");
            if (size($array) < 2) $deleteSGs[size($deleteSGs)] = $SG;
        }
    }
    if (size($deleteSGs)) {
        print "\nThe following shading groups aren't connected to anything:\n";
        for ($SG in $deleteSGs) print ($SG + "\n");
    }
    return $deleteSGs;
}

//-------------------------------------------------------------dkAttrGoal---------------------------------------------------------------------
global proc dkAttrGoal (string $goals[], string $targets[]) {
    string $array[], $targetObj, $targetAttr, $goalObj, $goalAttr, $weightAttr, $offsetAttr, $velocityAttr, $expressionString, $goalAttribute;
    
    if (size($goals) != size($targets)) error "number of goals don't match number of targets";
    
    $expressionString = "float $dt = 1.0 / 24.0;\nfloat $d, $w, $a;\n\n";
    
    for ($i = 0; $i < size($goals); $i++) {
        $goal = $goals[$i];
        $target = $targets[$i];
        
        $array = stringToStringArray($goal, ".");
        $goalObj = $array[0];
        $goalAttr = $array[1];
    
        $array = stringToStringArray($target, ".");
        $targetObj = $array[0];
        $targetAttr = $array[1];
        
        $weightAttr = ($targetAttr + "To" + $goalObj + $goalAttr + "Weight");
        if (!`objExists ($targetObj + "." + $weightAttr)`) {
            addAttr -ln $weightAttr -min 0 -max 1 -dv .5 $targetObj;
            setAttr -k true ($targetObj + "." + $weightAttr);
        }
        $offsetAttr = ($targetAttr + "To" + $goalObj + $goalAttr + "Offset");
        if (!`objExists ($targetObj + "." + $offsetAttr)`) {
            addAttr -ln $offsetAttr -min 0 -max 1 -dv 0 $targetObj;
            setAttr -k true ($targetObj + "." + $offsetAttr);
        }
        $velocityAttr = ($targetAttr + "Velocity");
        if (!`objExists ($targetObj + "." + $velocityAttr)`) {
            addAttr -ln $velocityAttr -min 0 -max 1 -dv 0 $targetObj;
            setAttr -k true ($targetObj + "." + $velocityAttr);
        }
        
        $weightAttr = ($targetObj + "." + $weightAttr);
        $offsetAttr = ($targetObj + "." + $offsetAttr);
        $velocityAttr = ($targetObj + "." + $velocityAttr);
        
        $expressionString +=     ("if (" + $weightAttr + " < .2) {\n" + 
                        "\t" + $target + " = 0;\n" + 
                    "} else {\n" + 
                        "\tif (frame == `playbackOptions -q -min`) {\n" + 
                            "\t\t" + $target + " = " + $goal + " + " + $offsetAttr + ";\n" + 
                            "\t\t" + $velocityAttr + " = 0.0;\n" + 
                        "\t}\n" + 
                        "\t$d = " + $goal + " + " + $offsetAttr + " - " + $target + ";\n" + 
                        "\t$w = pow(" + $weightAttr + ", 3);\n" + 
                        "\t$a = $w * (($d / $dt) - " + $velocityAttr + ") / $dt;\n" + 
                        "\t" + $velocityAttr + " = " + $velocityAttr + " + $a * $dt;\n" + 
                        "\t" + $target + " = " + $target + " + " + $velocityAttr + " * $dt;\n" + 
                    "}\n\n");
    }
    expression -s $expressionString;
}

//-------------------------------------------------------------dkAttrGoalRig---------------------------------------------------------------------
global proc dkAttrGoalRig (string $attrs[]) {
    string $ctrls[], $groups[], $goalString, $targetString, $array[], $name;
    $ctrls = `ls -sl`;
    $groups = `nas_group 0 Group`;
    for ($i = 0; $i < size($groups); $i++) {
        $array = stringToStringArray($groups[$i], "|");
        $array = stringToStringArray($array[size($array)-1], "_");
        stringArrayRemoveAtIndex((size($array)-1), $array);
        $name = stringArrayToString($array, "_");
        $name += "_GoalAttr_Group";
        $groups[$i] = `rename $groups[$i] $name`;
    }
    
    
    for ($i = 0; $i < size($ctrls)-1; $i++) {
        for ($j = 0; $j < size($attrs); $j++) {
            if ($i == 0 && $j == 0) {
                $goalString = ("{\"" + $ctrls[0] + "." + $attrs[$j] + "\"");
                $targetString = ("{\"" + $groups[$i+1] + "." + $attrs[$j] + "\"");
            } else {
                $goalString += (", \"" + $ctrls[0] + "." + $attrs[$j] + "\"");
                $targetString += (", \"" + $groups[$i+1] + "." + $attrs[$j] + "\"");
            }
        }
        if (!`objExists ($ctrls[0] + "." + $ctrls[$i+1] + "Weight")`) {
            addAttr -ln ($ctrls[$i+1] + "Weight") -min 0 -max 1 -dv .5 $ctrls[0];
            setAttr -k true ($ctrls[0] + "." + $ctrls[$i+1] + "Weight");
        }
    }
    print "\n";
    print ("dkAttrGoal " + $goalString + "} " + $targetString + "};");
    print "\n";
    eval("dkAttrGoal " + $goalString + "} " + $targetString + "};");
    //stringArrayRemoveAtIndex(0, $ctrls);
    select -r $ctrls[0];
}

//-------------------------------------------------------------dkCutHalves---------------------------------------------------------------------
global proc dkCutHalves(int $start, int $end, int $res) {
    string $locs[], $array[], $geo, $cut, $cuts[];
    float $wp1[], $wp2[], $halfWp[], $baseWp[], $endWp[], $cutWp[], $rotates[];
    clear $cuts;
    
    $array = `ls -sl`;
    $locs = {$array[0], $array[1]};
    $geo = $array[2];
    if (size($locs) != 2) error "please select only two locators before running";
    
    $wp1 = `xform -q -ws -rp $locs[0]`;
    $wp2 = `xform -q -ws -rp $locs[1]`;
    $halfWp = {($wp1[0] + $wp2[0])/2, ($wp1[1] + $wp2[1])/2, ($wp1[2] + $wp2[2])/2};
    
    if ($start) {
        $array = `polyCut -ws 1 -cd "X" -ch 1 $geo`;
        $cut = $array[0];
        setAttr ($cut + ".cutPlaneCenterX") $wp1[0];
        setAttr ($cut + ".cutPlaneCenterY") $wp1[1];
        setAttr ($cut + ".cutPlaneCenterZ") $wp1[2];
        $cuts[size($cuts)] = $cut;
    }
    if ($end) {
        $array = `polyCut -ws 1 -cd "X" -ch 1 $geo`;
        $cut = $array[0];
        setAttr ($cut + ".cutPlaneCenterX") $wp2[0];
        setAttr ($cut + ".cutPlaneCenterY") $wp2[1];
        setAttr ($cut + ".cutPlaneCenterZ") $wp2[2];
        $cuts[size($cuts)] = $cut;
    }
    
    $array = `polyCut -ws 1 -cd "X" -ch 1 $geo`;
    $cut = $array[0];
    setAttr ($cut + ".cutPlaneCenterX") $halfWp[0];
    setAttr ($cut + ".cutPlaneCenterY") $halfWp[1];
    setAttr ($cut + ".cutPlaneCenterZ") $halfWp[2];
    $cuts[size($cuts)] = $cut;
    
    $baseWp = $halfWp;
    $endWp = $halfWp;
    for ($i = 0; $i < $res; $i++) {
        $array = `polyCut -ws 1 -cd "X" -ch 1 $geo`;
        $cut = $array[0];
        $baseWp = {($wp1[0] + $baseWp[0])/2, ($wp1[1] + $baseWp[1])/2, ($wp1[2] + $baseWp[2])/2};
        setAttr ($cut + ".cutPlaneCenterX") $baseWp[0];
        setAttr ($cut + ".cutPlaneCenterY") $baseWp[1];
        setAttr ($cut + ".cutPlaneCenterZ") $baseWp[2];
        $cuts[size($cuts)] = $cut;
        $array = `polyCut -ws 1 -cd "X" -ch 1 $geo`;
        $cut = $array[0];
        $endWp = {($wp2[0] + $endWp[0])/2, ($wp2[1] + $endWp[1])/2, ($wp2[2] + $endWp[2])/2};
        setAttr ($cut + ".cutPlaneCenterX") $endWp[0];
        setAttr ($cut + ".cutPlaneCenterY") $endWp[1];
        setAttr ($cut + ".cutPlaneCenterZ") $endWp[2];
        $cuts[size($cuts)] = $cut;
    }
    
    select -r $locs[1] $locs[0];
    dkAim z y y;
    $rotates = `getAttr ($locs[0] + ".rotate")`;
    for ($i = 0; $i < size($cuts); $i++) {
        setAttr ($cuts[$i] + ".cutPlaneRotateX") $rotates[0];
        setAttr ($cuts[$i] + ".cutPlaneRotateY") $rotates[1];
        setAttr ($cuts[$i] + ".cutPlaneRotateZ") $rotates[2];
    }
    select -r $geo;
}

//-------------------------------------------------------------dkRecord---------------------------------------------------------------------
//records frequency of marking menu input from user into a file
global proc dkRecord (string $path, int $button, string $position) {
    if (size($path)) {
        global string $dkRecordData[];
        int $fileId;

        $sourceCommand = ("source \"" + $path + "\";");
        eval $sourceCommand;
    
        $dkRecordData[size($dkRecordData)] = $button;
        $dkRecordData[size($dkRecordData)] = $position;
        $fileId = `fopen $path "w"`;
        fprint $fileId "$dkRecordData={";
        for ($i = 0; $i < size($dkRecordData); $i++) if (size($dkRecordData[$i])) fprint $fileId ("\"" + $dkRecordData[$i] + "\",");
        fprint $fileId "\"\"};";
        fclose $fileId;
    }
}

//-------------------------------------------------------------dkAutoSave---------------------------------------------------------------------
//mode is add one more to the progress counter and save if counter reaches frequency
//dkAutoSaveUI must be run before dkAutoSave can work because the UI stores the start time
global proc dkAutoSave(int $mode) {
    global string $dkAutoSaveProgressBar, $dkAutoSaveElapsedText;
    global int $dkAutoSaveClicks, $dkAutoSaveStartTime, $cWordSpeedRateCount, $dkAutoSaveFrequency;
    string $animCurves[], $curveSels[], $sels[], $filename, $time;
    int $indices[], $indexSels[], $totalTime, $min, $sec;
    
    if ($mode) {
        $dkAutoSaveClicks++;
        $totalTime = `timerX -st $dkAutoSaveStartTime`;
        $min = $totalTime/60;
        $sec = $totalTime - $min*60;
        $time = ($min + ":" + `nas_framePadding "##" $sec`);
        if (`text -exists $dkAutoSaveElapsedText`) text -e -label $time $dkAutoSaveElapsedText;
        if (($dkAutoSaveClicks%$dkAutoSaveFrequency) == 0) {
            /*$curveSels = `keyframe -q -sl -n`;
            for ($curve in $curveSels) {
                $indexSels = `keyframe -q -sl -iv $curve`;
                for ($index in $indexSels) {
                    $animCurves[size($animCurves)] = $curve;
                    $indices[size($indices)] = $index;
                }
            }*/
            $sels = `ls -sl -long`;
            $filename = `file -q -sn`;
            if (size($filename)) incrementalSaveScene;
            else dkSaveSceneAs;
            print ("Scene saved as " + `file -q -sn` + " and backed up in \"incrementalSave\" folder\n");
            select -r $sels;
            //for ($i = 0; $i < size($animCurves); $i++) selectKey -add -index $indices[$i] $animCurves[$i];
            $dkAutoSaveStartTime = `timerX`;
            if (`text -exists $dkAutoSaveElapsedText`) text -e -label "0:00" $dkAutoSaveElapsedText;
            
            /*if (`optionVar -exists "cWordClub"`) {
                if ($cWordSpeedRateCount%5 == 0) cWordSpeedRate 1;
                $cWordSpeedRateCount++;
            }*/
        }
    } else $dkAutoSaveClicks = 0;
    if (`progressBar -exists $dkAutoSaveProgressBar`) progressBar -e -progress ($dkAutoSaveClicks%$dkAutoSaveFrequency) $dkAutoSaveProgressBar;
}

global proc dkAutoSaveFreqDialog() {
    global string $dkAutoSaveProgressBar;
    global int $dkAutoSaveFrequency;
    if (`optionVar -exists "dkAutoSaveFrequencyPref"` && `optionVar -q "dkAutoSaveFrequencyPref"` > 10) $dkAutoSaveFrequency = `optionVar -q "dkAutoSaveFrequencyPref"`;
    else $dkAutoSaveFrequency = 10;
    if (`promptDialog -b "OK" -b "Cancel" -cb "Cancel" -db "OK" -ds "Cancel" -m "After how many selection changes should dkAutoSave save?" -ma "center" -title "Frequency" -tx $dkAutoSaveFrequency` == "OK") {
        $dkAutoSaveFrequency = `promptDialog -q -tx`;
        if ($dkAutoSaveFrequency < 10) {
            confirmDialog -b "OK" -m "Frequency was set to low. Defaulting to 10." -ma "center";
            $dkAutoSaveFrequency = 10;
        }
        if (`optionVar -exists "dkAutoSaveFrequencyPref"`) optionVar -rm "dkAutoSaveFrequencyPref";
        optionVar -intValue "dkAutoSaveFrequencyPref" $dkAutoSaveFrequency;
            
        if (`progressBar -exists $dkAutoSaveProgressBar`) {
            progressBar -e -progress 0 -maxValue $dkAutoSaveFrequency $dkAutoSaveProgressBar;
            dkAutoSave 0;
        }
    }
}

global proc dkAutoSaveUI() {
    global int $dkAutoSaveClicks, $dkAutoSaveRun, $dkAutoSaveSelectionChangedJobNum, $dkAutoSaveTimeChangedJobNum, $dkAutoSaveNewSceneJobNum, $dkAutoSaveSceneSavedJobNum, $dkAutoSaveSceneOpenedJobNum, $dkAutoSaveStartTime, $dkAutoSaveFrequency;
    global string $dkAutoSaveProgressBar, $dkAutoSaveButton, $dkAutoSaveElapsedText;
    string $hideButton, $disableButton, $form, $time, $freqButton;
    int $amount, $frequency;
    
    if (!$dkAutoSaveRun) {
        $dkAutoSaveRun = 1;
        if (`button -exists $dkAutoSaveButton`) button -e -bgc .4 .8 .4 $dkAutoSaveButton;
        $dkAutoSaveStartTime = `timerX`;
        if (`optionVar -exists "dkAutoSaveFrequencyPref"`) $dkAutoSaveFrequency = `optionVar -q "dkAutoSaveFrequencyPref"`;
        else $dkAutoSaveFrequency = 100;
        if (`window -exists dkRigging_1_0_1`) dkRiggingUI;
        
        dkAutoSave 1;
        //enable incremental save
        if (`checkBoxGrp -exists incrementalSaveEnabled`) checkBoxGrp -e -value1 1 incrementalSaveEnabled;
        if (`checkBoxGrp -exists incrementalSaveLimit`) checkBoxGrp -e -enable 1 -value1 1 incrementalSaveLimit;
        if (`intSliderGrp -exists incrementalSaveLimitNo`) intSliderGrp -e -enable 1 -value 20 incrementalSaveLimitNo;
        optionVar -intValue isIncrementalSaveEnabled 1;
        optionVar -intValue incrementalSaveLimitBackups 1;
        optionVar -intValue incrementalSaveMaxBackups 20;
        //create script jobs that will add or reset to the autosave counter
        $dkAutoSaveSelectionChangedJobNum = `scriptJob -event SelectionChanged "dkAutoSave 1"`;
        $dkAutoSaveTimeChangedJobNum = `scriptJob -event timeChanged "dkAutoSave 1"`;
        $dkAutoSaveNewSceneJobNum = `scriptJob -event deleteAll "dkAutoSave 0"`;
        $dkAutoSaveSceneSavedJobNum = `scriptJob -event NewSceneOpened "dkAutoSave 0"`;
        $dkAutoSaveSceneOpenedJobNum = `scriptJob -event SceneOpened "dkAutoSave 0"`;
    }
    
     $window = `nas_window dkAutoSave 1 0 1`;
         $form = `formLayout`;
             $dkAutoSaveProgressBar = `progressBar -progress ($dkAutoSaveClicks%$dkAutoSaveFrequency) -maxValue $dkAutoSaveFrequency`;
             $hideButton = `button -label "Hide" -command ("deleteUI " + $window)`;
             $dkAutoSaveElapsedText = `text -label "0:00" -al "center"`;
             $disableButton = `button -label "Disable" -command ("scriptJob -kill " + $dkAutoSaveSelectionChangedJobNum + ";scriptJob -kill " + $dkAutoSaveTimeChangedJobNum + ";scriptJob -kill " + $dkAutoSaveNewSceneJobNum + ";scriptJob -kill " + $dkAutoSaveSceneSavedJobNum + ";scriptJob -kill " + $dkAutoSaveSceneOpenedJobNum + ";$dkAutoSaveRun=0;$dkAutoSaveClicks=0;deleteUI " + $window + ";if (`button -exists $dkAutoSaveButton`) button -e -bgc .831 .816 .784 $dkAutoSaveButton;if (`window -exists dkRigging_1_0_0`) dkRiggingUI;")`;
            $freqButton = `button -label "Frequency" -command "dkAutoSaveFreqDialog"`;
            
         formLayout -e
             -af $dkAutoSaveProgressBar "top" 0
             -af $dkAutoSaveProgressBar "left" 0
             -af $dkAutoSaveProgressBar "right" 0
             
             -ac $hideButton "top" 0 $dkAutoSaveProgressBar
             -af $hideButton "left" 0
             -ap $hideButton "right" 0 33
            -af $hideButton "bottom" 0
             
             -ac $dkAutoSaveElapsedText "top" 0 $dkAutoSaveProgressBar
             -ap $dkAutoSaveElapsedText "left" 0 33
             -ap $dkAutoSaveElapsedText "right" 0 66
             
             -ac $freqButton "top" 0 $dkAutoSaveElapsedText
             -ap $freqButton "left" 0 33
             -ap $freqButton "right" 0 66
            -af $freqButton "bottom" 0
             
             -ac $disableButton "top" 0 $dkAutoSaveProgressBar
             -ap $disableButton "left" 0 66
             -af $disableButton "right" 0
            -af $disableButton "bottom" 0
             $form;
    showWindow $window;
    window -e -wh 248 97 $window;
}

//-------------------------------------------------------------dkStringArrayToFloatArray---------------------------------------------------------------------
//returns a float array from an input string array
global proc float[] dkStringArrayToFloatArray(string $stringArray[]) {
    float $floatArray[];
    for ($i = 0; $i < size($stringArray); $i++) $floatArray[$i] = $stringArray[$i];
    return $floatArray;
}

//-------------------------------------------------------------dkFloatArrayToStringArray---------------------------------------------------------------------
//returns a string array from an input float array
global proc string[] dkFloatArrayToStringArray(float $floatArray[]) {
    string $stringArray[];
    for ($i = 0; $i < size($floatArray); $i++) $stringArray[$i] = $floatArray[$i];
    return $stringArray;
}

//-------------------------------------------------------------dkSceneLevel---------------------------------------------------------------------
//returns the scene path x folders above the scene file where x is $upLevel
global proc string dkSceneLevel(int $upLevel) {
    string $scenePath, $path, $array[];
    int $amount;

    $scenePath = `file -q -loc`;
    if ($scenePath != "unknown") {
        $array = stringToStringArray($scenePath, "/");
        $path = `substring $scenePath 1 (size($scenePath) - size($array[size($array)-1]))`;
        for ($i = 0; $i < $upLevel-1; $i++) {
            $array = stringToStringArray($path, "/");
            $amount = (size($path) - 1 - size($array[size($array)-1]));
            if ($amount > 0) $path = `substring $path 1 $amount`;
            else error "You tried to go too many levels up from your scene.";
        }
    }
    return $path;
}

//-------------------------------------------------------------dkZeroDefaultAttrs---------------------------------------------------------------------
global proc dkZeroDefaultAttrs() {
    string $sels[], $attrs[];
    int $value;
    
    $sels = `ls -sl`;
    $attrs = {"tx", "ty", "tz", "rx", "ry", "rz", "sx", "sy", "sz"};
    for ($sel in $sels) {
        for ($attr in $attrs) {
            if (`gmatch $attr "s?"`) $value = 1;
            else $value = 0;
            if (`getAttr -k ($sel + "." + $attr)`) catchQuiet(`setAttr ($sel + "." + $attr) $value`);
        }
    }
}

//-------------------------------------------------------------dkToggleImagePlanes---------------------------------------------------------------------
//toggles image planes on and off
global proc dkToggleImagePlanes() {
    string $imagePlanes[], $panels[];
    
    $imagePlanes = `ls -type imagePlane`;
    $panels = `nas_getVisibleModelPanels`;
    if (!size($imagePlanes)) error "No image planes in this scene.\n";
    if (`getAttr ($imagePlanes[0] + ".displayMode")` == 0) {
        for ($imagePlane in $imagePlanes) setAttr ($imagePlane + ".displayMode") 3;
        for ($panel in $panels) modelEditor -e -cameras 1 $panel;
    } else {
        for ($imagePlane in $imagePlanes) setAttr ($imagePlane + ".displayMode") 0;
        for ($panel in $panels) modelEditor -e -cameras 0 $panel;
    }
}

//-------------------------------------------------------------dkRadioCheckBoxGrp---------------------------------------------------------------------
global proc string[] dkRadioCheckBoxGrp (string $textLabel, int $textWidth, string $radioLabels[], string $defaults[], string $checkBoxLabel, int $checkBoxWidth, string $commands[]) {
    string $form, $text, $radioForm, $radioButtons[], $formLayoutCommand, $array[], $checkBox;
    $form = `formLayout`;
        $text = `text -align left -w $textWidth -label $textLabel`;
        $radioForm = `formLayout`;
            radioCollection;
                for ($i = 0; $i < size($radioLabels); $i++) {
                    $radioButtons[$i] = `radioButton -align left -label $radioLabels[$i] -onCommand $commands[$i]`;
                    if ($defaults[$i] == "1") radioButton -e -select $radioButtons[$i];
                }
            setParent..;
        $formLayoutCommand = "formLayout -e \n";
        for ($i = 0; $i < size($radioButtons); $i++) {
            if ($i == 0) $formLayoutCommand += ("-af " + $radioButtons[$i] + " \"top\" 0 \n-ap " + $radioButtons[$i] + " \"right\" 0 " + ((100/size($radioButtons)) * ($i+1)) + " \n-af " + $radioButtons[$i] + " \"bottom\" 0 \n-af " + $radioButtons[$i] + " \"left\" 0 \n\n");
            else if ($i == (size($radioButtons)-1)) $formLayoutCommand += ("-af " + $radioButtons[$i] + " \"top\" 0 \n-af " + $radioButtons[$i] + " \"right\" 0 \n-af " + $radioButtons[$i] + " \"bottom\" 0 \n-ap " + $radioButtons[$i] + " \"left\" 0 " + ((100/size($radioButtons)) * $i) + " \n");
            else $formLayoutCommand += ("-af " + $radioButtons[$i] + " \"top\" 0 \n-ap " + $radioButtons[$i] + " \"right\" 0 " + ((100/size($radioButtons)) * ($i+1)) + " \n-af " + $radioButtons[$i] + " \"bottom\" 0 \n-ac " + $radioButtons[$i] + " \"left\" 0 " + $radioButtons[$i-1] + " \n\n");
        }
        $formLayoutCommand += ($radioForm + ";");
        eval $formLayoutCommand;
        if (size($checkBoxLabel)) {
            if (size($commands) >= (size($radioLabels)+2)) $checkBox = `checkBoxGrp -numberOfCheckBoxes 1 -label1 $checkBoxLabel -cw 1 $checkBoxWidth -cal 1 center -onCommand $commands[size($commands)-2] -offCommand $commands[size($commands)-1]`;
            else $checkBox = `checkBoxGrp -numberOfCheckBoxes 1 -label1 $checkBoxLabel -cw 1 $checkBoxWidth -cal 1 center`;
            formLayout -e 
            -af $text "top" 0
            -af $text "bottom" 0
            -af $text "left" 0
            
            -af $radioForm "top" 0
            -ac $radioForm "left" 0 $text
            -ac $radioForm "right" 0 $checkBox
            -af $radioForm "bottom" 0
            
            -af $checkBox "top" 0
            -af $checkBox "right" 0
            -af $checkBox "bottom" 0
            $form;
        } else {
            formLayout -e 
            -af $text "top" 0
            -af $text "left" 0
            -af $text "bottom" 0
            
            -af $radioForm "top" 0
            -ac $radioForm "left" 0 $text
            -af $radioForm "right" 5
            -af $radioForm "bottom" 0
            $form;
        }
    setParent..;
    $array[0] = $form;
    $array = stringArrayCatenate ($array, $radioButtons);
    if (size($checkBoxLabel)) $array[size($array)] = $checkBox;
    return $array;
}

//-------------------------------------------------------------dkCheckboxGrp---------------------------------------------------------------------
global proc string[] dkCheckboxGrp(string $textLabel, int $textWidth, string $checkboxLabels[], int $defaults[]) {
    string $form, $text, $checkboxForm, $checkboxes[], $cmd, $array[];
    $form = `formLayout`;
        $text = `text -align left -w $textWidth -label $textLabel`;
        $checkboxForm = `formLayout`;
            for ($i = 0; $i < size($checkboxLabels); $i++) $checkboxes[$i] = `checkBox -align left -label $checkboxLabels[$i] -value $defaults[$i]`;
            setParent..;
        $cmd = "formLayout -e \n";
        for ($i = 0; $i < size($checkboxes); $i++) {
            if ($i == 0) $cmd += ("-af " + $checkboxes[$i] + " \"top\" 0 \n-ap " + $checkboxes[$i] + " \"right\" 0 " + ((100/size($checkboxes)) * ($i+1)) + " \n-af " + $checkboxes[$i] + " \"bottom\" 0 \n-af " + $checkboxes[$i] + " \"left\" 0 \n\n");
            else if ($i == (size($checkboxes)-1)) $cmd += ("-af " + $checkboxes[$i] + " \"top\" 0 \n-af " + $checkboxes[$i] + " \"right\" 0 \n-af " + $checkboxes[$i] + " \"bottom\" 0 \n-ap " + $checkboxes[$i] + " \"left\" 0 " + ((100/size($checkboxes)) * $i) + " \n");
            else $cmd += ("-af " + $checkboxes[$i] + " \"top\" 0 \n-ap " + $checkboxes[$i] + " \"right\" 0 " + ((100/size($checkboxes)) * ($i+1)) + " \n-af " + $checkboxes[$i] + " \"bottom\" 0 \n-ac " + $checkboxes[$i] + " \"left\" 0 " + $checkboxes[$i-1] + " \n\n");
        }
        $cmd += ($checkboxForm + ";");
        eval $cmd;
        setParent..;
    formLayout -e 
        -af $text "top" 0
        -af $text "left" 0
        -af $text "bottom" 0
        
        -af $checkboxForm "top" 0
        -ac $checkboxForm "left" 0 $text
        -af $checkboxForm "right" 5
        -af $checkboxForm "bottom" 0
        $form;
    $array[0] = $form;
    $array = stringArrayCatenate ($array, $checkboxes);
    return $array;
}

//-------------------------------------------------------------dkResolution---------------------------------------------------------------------
global proc dkResolution(int $res){
    string $smooths[], $array[], $layerComponents[];
    $smooths = `ls "*:*.smooth"`;
    $array = `ls "*:*.Smooth"`;
    appendStringArray($smooths, $array, size($array));
    $array = `ls "*:*.smoothLevels"`;
    appendStringArray($smooths, $array, size($array));
    $array = `ls "*.smooth"`;
    appendStringArray($smooths, $array, size($array));
    for ($smooth in $smooths) {
        cutKey -cl -t ":" -f ":" $smooth;
        if ($res) {
            $array = `listAttr -k $smooth`;
            if (size($array) == 0) {
                catchQuiet(`setAttr $smooth 1`);
                catchQuiet(`setAttr $smooth 2`);
            }
            else {
                setKeyframe -t 101 -v 2 $smooth;
                if (!`keyframe -q -kc $smooth`) setKeyframe -t 101 -v 1 $smooth;
            }
        }
        else setAttr $smooth $res;
    }
    
    $layerComponents = {
        "rocket", "LowRes", "FullRes", 
        "bigjet", "BigJet_LowRes", "BigJet_FullRes", 
        "clawnabber", "ClawNabber_LoRes", "ClawNabber_FullRes", 
        "icecream_train", "LOW_Res", "HIGH_Res", 
        "melody", "lowRes_layer", "highRes_layer", 
        "train", "LOW_Res", "HIGH_Res", 
        "violin_fairy", "low_res", "cello_geo_layer", 
        "chimp_234", "lowres_layer", "hires_layer", 
        "rocket_chimp_234", "LowRes", "FullRes", 
        "rocket_fire_truck_237:rocket_235_b1", "LowRes", "FullRes"
    };
                                            
    for ($i = 0; $i < size($layerComponents); $i+=3) {
        if (`objExists ($layerComponents[$i] + "*:" + $layerComponents[$i+1])`) setAttr ($layerComponents[$i] + "*:" + $layerComponents[$i+1] + ".v") (1 - $res);
        if (`objExists ($layerComponents[$i] + "*:" + $layerComponents[$i+2])`) setAttr ($layerComponents[$i] + "*:" + $layerComponents[$i+2] + ".v") $res;
    }
    //print ("Smooth as a" + `cWordResult` + "!");
    print $smooths;
}

//-------------------------------------------------------------dkXray---------------------------------------------------------------------
global proc dkXray() {
    string $panels[] = `nas_getVisibleModelPanels`;
    for ($panel in $panels) modelEditor -e -xray (1-`modelEditor -q -xray $panel`) $panel;
}

//-------------------------------------------------------------dkShow---------------------------------------------------------------------
//turns off everything in the show menu and turns on specified type
global proc dkShow(string $type, int $toggle, string $editor) {
    global int $clipboardIsolateState;
    string $panel, $animArcs[], $sels[], $models[], $arcCurves[];

    if ($editor == "") $editor = `getPanel -withFocus`;
    modelEditor -e -planes 0 -joints 0 -ikHandles 0 -deformers 0 -dynamics 0 -dimensions 0 -pivots 0 -handles 0 -textures 0 -strokes 0 $editor;        //hides any unnecessary types concerning animation
    switch ($type) {
        case "others":
            modelEditor -e -cameras $toggle -lights $toggle -locators $toggle $editor;
            break;
        case "cameras":
            modelEditor -e -cameras $toggle $editor;
            break;
        case "model":
            modelEditor -e -nurbsSurfaces $toggle -polymeshes $toggle $editor;
            break;
        case "controls":
            modelEditor -e -nurbsCurves $toggle $editor;
            break;
        case "all":
            modelEditor -e -allObjects $toggle $editor;
            break;
        case "grid":
            modelEditor -e -grid $toggle $editor;
            break;
        case "menubar":
            $panel = `modelEditor -q -panel $editor`;
            modelPanel -e -mbv $toggle $panel;
            break;
        case "animArcs":
            $animArcs = `ls "anim_arc_group*"`;
            for ($i = 0; $i < size($animArcs); $i++) setAttr ($animArcs[$i] + ".v") $toggle;
            break;
        default:
            break;
    }
}

//-------------------------------------------------------------dkView---------------------------------------------------------------------
//pops up a view of a camera with controls for showing and hiding objects
global proc dkView (string $cam) {
    string $window, $mainForm, $pane, $panel, $editor, $form, $column;
    
    $window = `nas_window dkView 1 1 0`;
        $mainForm = `formLayout`;
            $pane = `paneLayout -configuration "vertical2" -paneSize 1 15 100`;
                $panel = `modelPanel -camera $cam -mbv 0`;
                    $editor = `modelPanel -q -modelEditor $panel`;
                    modelEditor -e -da smoothShaded -allObjects 0 -grid 0 -nurbsCurves 1 -nurbsSurfaces 1 -polymeshes 1 $panel;
                    setParent ..;
                
                $form = `formLayout`;
                    $column = `columnLayout -adjustableColumn true`;
                        
                        checkBox -label "Models" -onc ("dkShow model 1 " + $editor) -ofc ("dkShow model 0 " + $editor) -v 1;
                        checkBox -label "Controls" -onc ("dkShow controls 1 " + $editor) -ofc ("dkShow controls 0 " + $editor) -v 1;
                        checkBox -label "Others" -onc ("dkShow others 1 " + $editor) -ofc ("dkShow others 0 " + $editor);
                        checkBox -label "Grid" -onc ("dkShow grid 1 " + $editor) -ofc ("dkShow grid 0 " + $editor);
                        checkBox -label "Menu" -onc ("dkShow menubar 1 " + $editor) -ofc ("dkShow menubar 0 " + $editor);
                        dkShow animArcs 0 $editor;
                        //checkBox -label "Anim Arcs" -onc ("dkShow animArcs 1 " + $editor) -ofc ("dkShow animArcs 0 " + $editor);
                        checkBox -label "Isolate" -onc "dkIsolate" -ofc "dkIsolate";
                    setParent ..;
                        
                formLayout -edit
                     -attachForm $column "top" 0 
                     -attachForm $column "left" 0 
                     -attachForm $column "right" 0 
                     -attachForm $column "bottom" 0
                     $form;
                 setParent ..;
        
            paneLayout -e -setPane $panel 2 $pane;
            setParent..;
        timePort -h 15 dkViewTime;
        formLayout -e
            -af $pane "top" 0
            -af $pane "left" 0
            -af $pane "right" 0
            -ac $pane "bottom" 0 dkViewTime
            
            -an dkViewTime "top"
            -af dkViewTime "left" 0
            -af dkViewTime "right" 0
            -af dkViewTime "bottom" 0
            $mainForm;
    window -e -wh 460 400 $window;
    showWindow $window;
}

//a picker UI that executes dkView with selected camera
global proc dkViewPicker() {
    string $window, $form, $column, $collection, $cams[], $button1, $button2;
    
    $window = `nas_window dkViewCustom 1 0 0`;
        $form = `formLayout`;
             $column = `columnLayout -adjustableColumn true`;
                 $collection = `radioCollection`;
                 $cams = `ls -type camera`;
                $cams = `listRelatives -parent $cams`;
                for ($cam in $cams) radioButton -label $cam -align "left";
                 setParent..;
            $button1 = `button -label "Pop-up!" -c ("string $dkViewCustomChoice = `radioCollection -q -sl " + $collection + "`;dkView `radioButton -q -label $dkViewCustomChoice`;deleteUI " + $window)`;
            $button2 = `button -label "Cancel" -c ("deleteUI " + $window)`;
        formLayout -e 
            -af $column "top" 0
            -af $column "left" 0
            -af $column "right" 0

            -ac $button1 "top" 0 $column
            -af $button1 "left" 0
            -ap $button1 "right" 0 50

            -ac $button2 "top" 0 $column
            -ap $button2 "left" 0 50
            -af $button2 "right" 0
            $form;
    window -e -wh 200 (27 + (size($cams)*16) + 31) $window;
    showWindow $window;
}

global proc deformDotCluster(){
    python("import sys");
    python("if 'J:/Crew/Dave_kim/scripts/nucleus' not in sys.path: sys.path.append('J:/Crew/Dave_kim/scripts/nucleus')");
    python("import deformer");

    string $sels[], $ctrls[], $verts[], $cmd, $ctrlcmd;
    $sels = `ls -sl -fl`;
    for ($sel in $sels) if (`nodeType $sel` == "transform") $ctrls[size($ctrls)] = $sel;

    if (size($ctrls) == 1) {
        $ctrlcmd = ("['"+$ctrls[0]+"']");
    } else {
        $ctrlcmd = ("['" + $ctrls[0] + "'");
        for ($i=1;$i<size($ctrls);$i++) $ctrlcmd += (", '"+$ctrls[$i]+"'");
        $ctrlcmd += "]";
    }

    $verts = stringArrayRemove($ctrls, $sels);
    $cmd = ("['" + $verts[0] + "'");
    for ($i=1;$i<size($verts);$i++) $cmd += (", '"+$verts[$i]+"'");
    $cmd += "]";

    python(("deformer.cluster(ctrls=" + $ctrlcmd + ", verts=" + $cmd + ")"));
}

//-------------------------------------------------------------
// UI Loaders
//-------------------------------------------------------------

global proc nas_rig_IK()
{
    nas_rigIKUI;
}

global proc nas_rig_FK() 
{
    nas_rigFKUI;
}

global proc nas_rig_Auto() 
{
    nas_autoRigUI;
}

global proc nas_rig_ToolBox()
{
    nas_riggingUI;
}


//create a tool for making an ikfk switch
//make a hotkey for ctrl+f to bring up a search window "nas_search"
